<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/dependencies/openzeppelin/contracts/IERC20.sol</b>
<code>
  1 |     | <span class='unexecuted'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  6 |     | <span class='neutral'> */</span>
  7 |     | <span class='neutral'>interface IERC20 {</span>
  8 |     | <span class='neutral'>  /**</span>
  9 |     | <span class='neutral'>   * @dev Returns the amount of tokens in existence.</span>
 10 |     | <span class='neutral'>   */</span>
 11 |     | <span class='neutral'>  function totalSupply() external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  /**</span>
 14 |     | <span class='neutral'>   * @dev Returns the amount of tokens owned by `account`.</span>
 15 |     | <span class='neutral'>   */</span>
 16 |     | <span class='neutral'>  function balanceOf(address account) external view returns (uint256);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>  /**</span>
 19 |     | <span class='neutral'>   * @dev Moves `amount` tokens from the caller&#39;s account to `recipient`.</span>
 20 |     | <span class='neutral'>   *</span>
 21 |     | <span class='neutral'>   * Returns a boolean value indicating whether the operation succeeded.</span>
 22 |     | <span class='neutral'>   *</span>
 23 |     | <span class='neutral'>   * Emits a {Transfer} event.</span>
 24 |     | <span class='neutral'>   */</span>
 25 |     | <span class='neutral'>  function transfer(address recipient, uint256 amount) external returns (bool);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>  /**</span>
 28 |     | <span class='neutral'>   * @dev Returns the remaining number of tokens that `spender` will be</span>
 29 |     | <span class='neutral'>   * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 30 |     | <span class='neutral'>   * zero by default.</span>
 31 |     | <span class='neutral'>   *</span>
 32 |     | <span class='neutral'>   * This value changes when {approve} or {transferFrom} are called.</span>
 33 |     | <span class='neutral'>   */</span>
 34 |     | <span class='neutral'>  function allowance(address owner, address spender) external view returns (uint256);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>  /**</span>
 37 |     | <span class='neutral'>   * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 38 |     | <span class='neutral'>   *</span>
 39 |     | <span class='neutral'>   * Returns a boolean value indicating whether the operation succeeded.</span>
 40 |     | <span class='neutral'>   *</span>
 41 |     | <span class='neutral'>   * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 42 |     | <span class='neutral'>   * that someone may use both the old and the new allowance by unfortunate</span>
 43 |     | <span class='neutral'>   * transaction ordering. One possible solution to mitigate this race</span>
 44 |     | <span class='neutral'>   * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 45 |     | <span class='neutral'>   * desired value afterwards:</span>
 46 |     | <span class='neutral'>   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 47 |     | <span class='neutral'>   *</span>
 48 |     | <span class='neutral'>   * Emits an {Approval} event.</span>
 49 |     | <span class='neutral'>   */</span>
 50 |     | <span class='neutral'>  function approve(address spender, uint256 amount) external returns (bool);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>  /**</span>
 53 |     | <span class='neutral'>   * @dev Moves `amount` tokens from `sender` to `recipient` using the</span>
 54 |     | <span class='neutral'>   * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 55 |     | <span class='neutral'>   * allowance.</span>
 56 |     | <span class='neutral'>   *</span>
 57 |     | <span class='neutral'>   * Returns a boolean value indicating whether the operation succeeded.</span>
 58 |     | <span class='neutral'>   *</span>
 59 |     | <span class='neutral'>   * Emits a {Transfer} event.</span>
 60 |     | <span class='neutral'>   */</span>
 61 |     | <span class='neutral'>  function transferFrom(</span>
 62 |     | <span class='neutral'>    address sender,</span>
 63 |     | <span class='neutral'>    address recipient,</span>
 64 |     | <span class='neutral'>    uint256 amount</span>
 65 |     | <span class='neutral'>  ) external returns (bool);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>  /**</span>
 68 |     | <span class='neutral'>   * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 69 |     | <span class='neutral'>   * another (`to`).</span>
 70 |     | <span class='neutral'>   *</span>
 71 |     | <span class='neutral'>   * Note that `value` may be zero.</span>
 72 |     | <span class='neutral'>   */</span>
 73 |     | <span class='neutral'>  event Transfer(address indexed from, address indexed to, uint256 value);</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>  /**</span>
 76 |     | <span class='neutral'>   * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 77 |     | <span class='neutral'>   * a call to {approve}. `value` is the new allowance.</span>
 78 |     | <span class='neutral'>   */</span>
 79 |     | <span class='neutral'>  event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 80 |     | <span class='neutral'>}</span>
 81 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IAToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &#39;../dependencies/openzeppelin/contracts/IERC20.sol&#39;;</span>
   5 |     | <span class='neutral'>import {IScaledBalanceToken} from &#39;./IScaledBalanceToken.sol&#39;;</span>
   6 |     | <span class='neutral'>import {IInitializableAToken} from &#39;./IInitializableAToken.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @title IAToken</span>
  10 |     | <span class='neutral'> * @author Aave</span>
  11 |     | <span class='neutral'> * @notice Defines the basic interface for an AToken.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='neutral'>interface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {</span>
  14 |     | <span class='neutral'>  /**</span>
  15 |     | <span class='neutral'>   * @dev Emitted during the transfer action</span>
  16 |     | <span class='neutral'>   * @param from The user whose tokens are being transferred</span>
  17 |     | <span class='neutral'>   * @param to The recipient</span>
  18 |     | <span class='neutral'>   * @param value The scaled amount being transferred</span>
  19 |     | <span class='neutral'>   * @param index The next liquidity index of the reserve</span>
  20 |     | <span class='neutral'>   */</span>
  21 |     | <span class='neutral'>  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>  /**</span>
  24 |     | <span class='neutral'>   * @notice Mints `amount` aTokens to `user`</span>
  25 |     | <span class='neutral'>   * @param caller The address performing the mint</span>
  26 |     | <span class='neutral'>   * @param onBehalfOf The address of the user that will receive the minted aTokens</span>
  27 |     | <span class='neutral'>   * @param amount The amount of tokens getting minted</span>
  28 |     | <span class='neutral'>   * @param index The next liquidity index of the reserve</span>
  29 |     | <span class='neutral'>   * @return `true` if the the previous balance of the user was 0</span>
  30 |     | <span class='neutral'>   */</span>
  31 |     | <span class='neutral'>  function mint(</span>
  32 |     | <span class='neutral'>    address caller,</span>
  33 |     | <span class='neutral'>    address onBehalfOf,</span>
  34 |     | <span class='neutral'>    uint256 amount,</span>
  35 |     | <span class='neutral'>    uint256 index</span>
  36 |     | <span class='neutral'>  ) external returns (bool);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>  /**</span>
  39 |     | <span class='neutral'>   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`</span>
  40 |     | <span class='neutral'>   * @dev In some instances, the mint event could be emitted from a burn transaction</span>
  41 |     | <span class='neutral'>   * if the amount to burn is less than the interest that the user accrued</span>
  42 |     | <span class='neutral'>   * @param from The address from which the aTokens will be burned</span>
  43 |     | <span class='neutral'>   * @param receiverOfUnderlying The address that will receive the underlying</span>
  44 |     | <span class='neutral'>   * @param amount The amount being burned</span>
  45 |     | <span class='neutral'>   * @param index The next liquidity index of the reserve</span>
  46 |     | <span class='neutral'>   */</span>
  47 |     | <span class='neutral'>  function burn(</span>
  48 |     | <span class='neutral'>    address from,</span>
  49 |     | <span class='neutral'>    address receiverOfUnderlying,</span>
  50 |     | <span class='neutral'>    uint256 amount,</span>
  51 |     | <span class='neutral'>    uint256 index</span>
  52 |     | <span class='neutral'>  ) external;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>  /**</span>
  55 |     | <span class='neutral'>   * @notice Mints aTokens to the reserve treasury</span>
  56 |     | <span class='neutral'>   * @param amount The amount of tokens getting minted</span>
  57 |     | <span class='neutral'>   * @param index The next liquidity index of the reserve</span>
  58 |     | <span class='neutral'>   */</span>
  59 |     | <span class='neutral'>  function mintToTreasury(uint256 amount, uint256 index) external;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>  /**</span>
  62 |     | <span class='neutral'>   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken</span>
  63 |     | <span class='neutral'>   * @param from The address getting liquidated, current owner of the aTokens</span>
  64 |     | <span class='neutral'>   * @param to The recipient</span>
  65 |     | <span class='neutral'>   * @param value The amount of tokens getting transferred</span>
  66 |     | <span class='neutral'>   */</span>
  67 |     | <span class='neutral'>  function transferOnLiquidation(</span>
  68 |     | <span class='neutral'>    address from,</span>
  69 |     | <span class='neutral'>    address to,</span>
  70 |     | <span class='neutral'>    uint256 value</span>
  71 |     | <span class='neutral'>  ) external;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>  /**</span>
  74 |     | <span class='neutral'>   * @notice Transfers the underlying asset to `target`.</span>
  75 |     | <span class='neutral'>   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()</span>
  76 |     | <span class='neutral'>   * @param target The recipient of the underlying</span>
  77 |     | <span class='neutral'>   * @param amount The amount getting transferred</span>
  78 |     | <span class='neutral'>   */</span>
  79 |     | <span class='neutral'>  function transferUnderlyingTo(address target, uint256 amount) external;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>  /**</span>
  82 |     | <span class='neutral'>   * @notice Handles the underlying received by the aToken after the transfer has been completed.</span>
  83 |     | <span class='neutral'>   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the</span>
  84 |     | <span class='neutral'>   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying</span>
  85 |     | <span class='neutral'>   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.</span>
  86 |     | <span class='neutral'>   * @param user The user executing the repayment</span>
  87 |     | <span class='neutral'>   * @param onBehalfOf The address of the user who will get his debt reduced/removed</span>
  88 |     | <span class='neutral'>   * @param amount The amount getting repaid</span>
  89 |     | <span class='neutral'>   */</span>
  90 |     | <span class='neutral'>  function handleRepayment(</span>
  91 |     | <span class='neutral'>    address user,</span>
  92 |     | <span class='neutral'>    address onBehalfOf,</span>
  93 |     | <span class='neutral'>    uint256 amount</span>
  94 |     | <span class='neutral'>  ) external;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>  /**</span>
  97 |     | <span class='neutral'>   * @notice Allow passing a signed message to approve spending</span>
  98 |     | <span class='neutral'>   * @dev implements the permit function as for</span>
  99 |     | <span class='neutral'>   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md</span>
 100 |     | <span class='neutral'>   * @param owner The owner of the funds</span>
 101 |     | <span class='neutral'>   * @param spender The spender</span>
 102 |     | <span class='neutral'>   * @param value The amount</span>
 103 |     | <span class='neutral'>   * @param deadline The deadline timestamp, type(uint256).max for max deadline</span>
 104 |     | <span class='neutral'>   * @param v Signature param</span>
 105 |     | <span class='neutral'>   * @param s Signature param</span>
 106 |     | <span class='neutral'>   * @param r Signature param</span>
 107 |     | <span class='neutral'>   */</span>
 108 |     | <span class='neutral'>  function permit(</span>
 109 |     | <span class='neutral'>    address owner,</span>
 110 |     | <span class='neutral'>    address spender,</span>
 111 |     | <span class='neutral'>    uint256 value,</span>
 112 |     | <span class='neutral'>    uint256 deadline,</span>
 113 |     | <span class='neutral'>    uint8 v,</span>
 114 |     | <span class='neutral'>    bytes32 r,</span>
 115 |     | <span class='neutral'>    bytes32 s</span>
 116 |     | <span class='neutral'>  ) external;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>  /**</span>
 119 |     | <span class='neutral'>   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)</span>
 120 |     | <span class='neutral'>   * @return The address of the underlying asset</span>
 121 |     | <span class='neutral'>   */</span>
 122 |     | <span class='neutral'>  function UNDERLYING_ASSET_ADDRESS() external view returns (address);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>  /**</span>
 125 |     | <span class='neutral'>   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.</span>
 126 |     | <span class='neutral'>   * @return Address of the Aave treasury</span>
 127 |     | <span class='neutral'>   */</span>
 128 |     | <span class='neutral'>  function RESERVE_TREASURY_ADDRESS() external view returns (address);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>  /**</span>
 131 |     | <span class='neutral'>   * @notice Get the domain separator for the token</span>
 132 |     | <span class='neutral'>   * @dev Return cached value if chainId matches cache, otherwise recomputes separator</span>
 133 |     | <span class='neutral'>   * @return The domain separator of the token at current chain</span>
 134 |     | <span class='neutral'>   */</span>
 135 |     | <span class='neutral'>  function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>  /**</span>
 138 |     | <span class='neutral'>   * @notice Returns the nonce for owner.</span>
 139 |     | <span class='neutral'>   * @param owner The address of the owner</span>
 140 |     | <span class='neutral'>   * @return The nonce of the owner</span>
 141 |     | <span class='neutral'>   */</span>
 142 |     | <span class='neutral'>  function nonces(address owner) external view returns (uint256);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>  /**</span>
 145 |     | <span class='neutral'>   * @notice Rescue and transfer tokens locked in this contract</span>
 146 |     | <span class='neutral'>   * @param token The address of the token</span>
 147 |     | <span class='neutral'>   * @param to The address of the recipient</span>
 148 |     | <span class='neutral'>   * @param amount The amount of token to transfer</span>
 149 |     | <span class='neutral'>   */</span>
 150 |     | <span class='neutral'>  function rescueTokens(</span>
 151 |     | <span class='neutral'>    address token,</span>
 152 |     | <span class='neutral'>    address to,</span>
 153 |     | <span class='neutral'>    uint256 amount</span>
 154 |     | <span class='neutral'>  ) external;</span>
 155 |     | <span class='neutral'>}</span>
 156 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IAaveIncentivesController.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title IAaveIncentivesController</span>
  6 |     | <span class='neutral'> * @author Aave</span>
  7 |     | <span class='neutral'> * @notice Defines the basic interface for an Aave Incentives Controller.</span>
  8 |     | <span class='neutral'> * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface IAaveIncentivesController {</span>
 11 |     | <span class='neutral'>  /**</span>
 12 |     | <span class='neutral'>   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.</span>
 13 |     | <span class='neutral'>   * @dev The units of `totalSupply` and `userBalance` should be the same.</span>
 14 |     | <span class='neutral'>   * @param user The address of the user whose asset balance has changed</span>
 15 |     | <span class='neutral'>   * @param totalSupply The total supply of the asset prior to user balance change</span>
 16 |     | <span class='neutral'>   * @param userBalance The previous user balance prior to balance change</span>
 17 |     | <span class='neutral'>   */</span>
 18 |     | <span class='neutral'>  function handleAction(</span>
 19 |     | <span class='neutral'>    address user,</span>
 20 |     | <span class='neutral'>    uint256 totalSupply,</span>
 21 |     | <span class='neutral'>    uint256 userBalance</span>
 22 |     | <span class='neutral'>  ) external;</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IInitializableAToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAaveIncentivesController} from &#39;./IAaveIncentivesController.sol&#39;;</span>
  5 |     | <span class='neutral'>import {IPool} from &#39;./IPool.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @title IInitializableAToken</span>
  9 |     | <span class='neutral'> * @author Aave</span>
 10 |     | <span class='neutral'> * @notice Interface for the initialize function on AToken</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IInitializableAToken {</span>
 13 |     | <span class='neutral'>  /**</span>
 14 |     | <span class='neutral'>   * @dev Emitted when an aToken is initialized</span>
 15 |     | <span class='neutral'>   * @param underlyingAsset The address of the underlying asset</span>
 16 |     | <span class='neutral'>   * @param pool The address of the associated pool</span>
 17 |     | <span class='neutral'>   * @param treasury The address of the treasury</span>
 18 |     | <span class='neutral'>   * @param incentivesController The address of the incentives controller for this aToken</span>
 19 |     | <span class='neutral'>   * @param aTokenDecimals The decimals of the underlying</span>
 20 |     | <span class='neutral'>   * @param aTokenName The name of the aToken</span>
 21 |     | <span class='neutral'>   * @param aTokenSymbol The symbol of the aToken</span>
 22 |     | <span class='neutral'>   * @param params A set of encoded parameters for additional initialization</span>
 23 |     | <span class='neutral'>   */</span>
 24 |     | <span class='neutral'>  event Initialized(</span>
 25 |     | <span class='neutral'>    address indexed underlyingAsset,</span>
 26 |     | <span class='neutral'>    address indexed pool,</span>
 27 |     | <span class='neutral'>    address treasury,</span>
 28 |     | <span class='neutral'>    address incentivesController,</span>
 29 |     | <span class='neutral'>    uint8 aTokenDecimals,</span>
 30 |     | <span class='neutral'>    string aTokenName,</span>
 31 |     | <span class='neutral'>    string aTokenSymbol,</span>
 32 |     | <span class='neutral'>    bytes params</span>
 33 |     | <span class='neutral'>  );</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>  /**</span>
 36 |     | <span class='neutral'>   * @notice Initializes the aToken</span>
 37 |     | <span class='neutral'>   * @param pool The pool contract that is initializing this contract</span>
 38 |     | <span class='neutral'>   * @param treasury The address of the Aave treasury, receiving the fees on this aToken</span>
 39 |     | <span class='neutral'>   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)</span>
 40 |     | <span class='neutral'>   * @param incentivesController The smart contract managing potential incentives distribution</span>
 41 |     | <span class='neutral'>   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset&#39;s</span>
 42 |     | <span class='neutral'>   * @param aTokenName The name of the aToken</span>
 43 |     | <span class='neutral'>   * @param aTokenSymbol The symbol of the aToken</span>
 44 |     | <span class='neutral'>   * @param params A set of encoded parameters for additional initialization</span>
 45 |     | <span class='neutral'>   */</span>
 46 |     | <span class='neutral'>  function initialize(</span>
 47 |     | <span class='neutral'>    IPool pool,</span>
 48 |     | <span class='neutral'>    address treasury,</span>
 49 |     | <span class='neutral'>    address underlyingAsset,</span>
 50 |     | <span class='neutral'>    IAaveIncentivesController incentivesController,</span>
 51 |     | <span class='neutral'>    uint8 aTokenDecimals,</span>
 52 |     | <span class='neutral'>    string calldata aTokenName,</span>
 53 |     | <span class='neutral'>    string calldata aTokenSymbol,</span>
 54 |     | <span class='neutral'>    bytes calldata params</span>
 55 |     | <span class='neutral'>  ) external;</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IInitializableDebtToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IAaveIncentivesController} from &#39;./IAaveIncentivesController.sol&#39;;</span>
  5 |     | <span class='neutral'>import {IPool} from &#39;./IPool.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @title IInitializableDebtToken</span>
  9 |     | <span class='neutral'> * @author Aave</span>
 10 |     | <span class='neutral'> * @notice Interface for the initialize function common between debt tokens</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IInitializableDebtToken {</span>
 13 |     | <span class='neutral'>  /**</span>
 14 |     | <span class='neutral'>   * @dev Emitted when a debt token is initialized</span>
 15 |     | <span class='neutral'>   * @param underlyingAsset The address of the underlying asset</span>
 16 |     | <span class='neutral'>   * @param pool The address of the associated pool</span>
 17 |     | <span class='neutral'>   * @param incentivesController The address of the incentives controller for this aToken</span>
 18 |     | <span class='neutral'>   * @param debtTokenDecimals The decimals of the debt token</span>
 19 |     | <span class='neutral'>   * @param debtTokenName The name of the debt token</span>
 20 |     | <span class='neutral'>   * @param debtTokenSymbol The symbol of the debt token</span>
 21 |     | <span class='neutral'>   * @param params A set of encoded parameters for additional initialization</span>
 22 |     | <span class='neutral'>   */</span>
 23 |     | <span class='neutral'>  event Initialized(</span>
 24 |     | <span class='neutral'>    address indexed underlyingAsset,</span>
 25 |     | <span class='neutral'>    address indexed pool,</span>
 26 |     | <span class='neutral'>    address incentivesController,</span>
 27 |     | <span class='neutral'>    uint8 debtTokenDecimals,</span>
 28 |     | <span class='neutral'>    string debtTokenName,</span>
 29 |     | <span class='neutral'>    string debtTokenSymbol,</span>
 30 |     | <span class='neutral'>    bytes params</span>
 31 |     | <span class='neutral'>  );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>  /**</span>
 34 |     | <span class='neutral'>   * @notice Initializes the debt token.</span>
 35 |     | <span class='neutral'>   * @param pool The pool contract that is initializing this contract</span>
 36 |     | <span class='neutral'>   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)</span>
 37 |     | <span class='neutral'>   * @param incentivesController The smart contract managing potential incentives distribution</span>
 38 |     | <span class='neutral'>   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset&#39;s</span>
 39 |     | <span class='neutral'>   * @param debtTokenName The name of the token</span>
 40 |     | <span class='neutral'>   * @param debtTokenSymbol The symbol of the token</span>
 41 |     | <span class='neutral'>   * @param params A set of encoded parameters for additional initialization</span>
 42 |     | <span class='neutral'>   */</span>
 43 |     | <span class='neutral'>  function initialize(</span>
 44 |     | <span class='neutral'>    IPool pool,</span>
 45 |     | <span class='neutral'>    address underlyingAsset,</span>
 46 |     | <span class='neutral'>    IAaveIncentivesController incentivesController,</span>
 47 |     | <span class='neutral'>    uint8 debtTokenDecimals,</span>
 48 |     | <span class='neutral'>    string memory debtTokenName,</span>
 49 |     | <span class='neutral'>    string memory debtTokenSymbol,</span>
 50 |     | <span class='neutral'>    bytes calldata params</span>
 51 |     | <span class='neutral'>  ) external;</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IPoolAddressesProvider} from &#39;./IPoolAddressesProvider.sol&#39;;</span>
   5 |     | <span class='neutral'>import {DataTypes} from &#39;../protocol/libraries/types/DataTypes.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @title IPool</span>
   9 |     | <span class='neutral'> * @author Aave</span>
  10 |     | <span class='neutral'> * @notice Defines the basic interface for an Aave Pool.</span>
  11 |     | <span class='neutral'> */</span>
  12 |     | <span class='neutral'>interface IPool {</span>
  13 |     | <span class='neutral'>  /**</span>
  14 |     | <span class='neutral'>   * @dev Emitted on mintUnbacked()</span>
  15 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
  16 |     | <span class='neutral'>   * @param user The address initiating the supply</span>
  17 |     | <span class='neutral'>   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens</span>
  18 |     | <span class='neutral'>   * @param amount The amount of supplied assets</span>
  19 |     | <span class='neutral'>   * @param referralCode The referral code used</span>
  20 |     | <span class='neutral'>   */</span>
  21 |     | <span class='neutral'>  event MintUnbacked(</span>
  22 |     | <span class='neutral'>    address indexed reserve,</span>
  23 |     | <span class='neutral'>    address user,</span>
  24 |     | <span class='neutral'>    address indexed onBehalfOf,</span>
  25 |     | <span class='neutral'>    uint256 amount,</span>
  26 |     | <span class='neutral'>    uint16 indexed referralCode</span>
  27 |     | <span class='neutral'>  );</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>  /**</span>
  30 |     | <span class='neutral'>   * @dev Emitted on backUnbacked()</span>
  31 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
  32 |     | <span class='neutral'>   * @param backer The address paying for the backing</span>
  33 |     | <span class='neutral'>   * @param amount The amount added as backing</span>
  34 |     | <span class='neutral'>   * @param fee The amount paid in fees</span>
  35 |     | <span class='neutral'>   */</span>
  36 |     | <span class='neutral'>  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>  /**</span>
  39 |     | <span class='neutral'>   * @dev Emitted on supply()</span>
  40 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
  41 |     | <span class='neutral'>   * @param user The address initiating the supply</span>
  42 |     | <span class='neutral'>   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens</span>
  43 |     | <span class='neutral'>   * @param amount The amount supplied</span>
  44 |     | <span class='neutral'>   * @param referralCode The referral code used</span>
  45 |     | <span class='neutral'>   */</span>
  46 |     | <span class='neutral'>  event Supply(</span>
  47 |     | <span class='neutral'>    address indexed reserve,</span>
  48 |     | <span class='neutral'>    address user,</span>
  49 |     | <span class='neutral'>    address indexed onBehalfOf,</span>
  50 |     | <span class='neutral'>    uint256 amount,</span>
  51 |     | <span class='neutral'>    uint16 indexed referralCode</span>
  52 |     | <span class='neutral'>  );</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>  /**</span>
  55 |     | <span class='neutral'>   * @dev Emitted on withdraw()</span>
  56 |     | <span class='neutral'>   * @param reserve The address of the underlying asset being withdrawn</span>
  57 |     | <span class='neutral'>   * @param user The address initiating the withdrawal, owner of aTokens</span>
  58 |     | <span class='neutral'>   * @param to The address that will receive the underlying</span>
  59 |     | <span class='neutral'>   * @param amount The amount to be withdrawn</span>
  60 |     | <span class='neutral'>   */</span>
  61 |     | <span class='neutral'>  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>  /**</span>
  64 |     | <span class='neutral'>   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened</span>
  65 |     | <span class='neutral'>   * @param reserve The address of the underlying asset being borrowed</span>
  66 |     | <span class='neutral'>   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just</span>
  67 |     | <span class='neutral'>   * initiator of the transaction on flashLoan()</span>
  68 |     | <span class='neutral'>   * @param onBehalfOf The address that will be getting the debt</span>
  69 |     | <span class='neutral'>   * @param amount The amount borrowed out</span>
  70 |     | <span class='neutral'>   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable</span>
  71 |     | <span class='neutral'>   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray</span>
  72 |     | <span class='neutral'>   * @param referralCode The referral code used</span>
  73 |     | <span class='neutral'>   */</span>
  74 |     | <span class='neutral'>  event Borrow(</span>
  75 |     | <span class='neutral'>    address indexed reserve,</span>
  76 |     | <span class='neutral'>    address user,</span>
  77 |     | <span class='neutral'>    address indexed onBehalfOf,</span>
  78 |     | <span class='neutral'>    uint256 amount,</span>
  79 |     | <span class='neutral'>    DataTypes.InterestRateMode interestRateMode,</span>
  80 |     | <span class='neutral'>    uint256 borrowRate,</span>
  81 |     | <span class='neutral'>    uint16 indexed referralCode</span>
  82 |     | <span class='neutral'>  );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>  /**</span>
  85 |     | <span class='neutral'>   * @dev Emitted on repay()</span>
  86 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
  87 |     | <span class='neutral'>   * @param user The beneficiary of the repayment, getting his debt reduced</span>
  88 |     | <span class='neutral'>   * @param repayer The address of the user initiating the repay(), providing the funds</span>
  89 |     | <span class='neutral'>   * @param amount The amount repaid</span>
  90 |     | <span class='neutral'>   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly</span>
  91 |     | <span class='neutral'>   */</span>
  92 |     | <span class='neutral'>  event Repay(</span>
  93 |     | <span class='neutral'>    address indexed reserve,</span>
  94 |     | <span class='neutral'>    address indexed user,</span>
  95 |     | <span class='neutral'>    address indexed repayer,</span>
  96 |     | <span class='neutral'>    uint256 amount,</span>
  97 |     | <span class='neutral'>    bool useATokens</span>
  98 |     | <span class='neutral'>  );</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>  /**</span>
 101 |     | <span class='neutral'>   * @dev Emitted on swapBorrowRateMode()</span>
 102 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
 103 |     | <span class='neutral'>   * @param user The address of the user swapping his rate mode</span>
 104 |     | <span class='neutral'>   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable</span>
 105 |     | <span class='neutral'>   */</span>
 106 |     | <span class='neutral'>  event SwapBorrowRateMode(</span>
 107 |     | <span class='neutral'>    address indexed reserve,</span>
 108 |     | <span class='neutral'>    address indexed user,</span>
 109 |     | <span class='neutral'>    DataTypes.InterestRateMode interestRateMode</span>
 110 |     | <span class='neutral'>  );</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>  /**</span>
 113 |     | <span class='neutral'>   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets</span>
 114 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 115 |     | <span class='neutral'>   * @param totalDebt The total isolation mode debt for the reserve</span>
 116 |     | <span class='neutral'>   */</span>
 117 |     | <span class='neutral'>  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>  /**</span>
 120 |     | <span class='neutral'>   * @dev Emitted when the user selects a certain asset category for eMode</span>
 121 |     | <span class='neutral'>   * @param user The address of the user</span>
 122 |     | <span class='neutral'>   * @param categoryId The category id</span>
 123 |     | <span class='neutral'>   */</span>
 124 |     | <span class='neutral'>  event UserEModeSet(address indexed user, uint8 categoryId);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>  /**</span>
 127 |     | <span class='neutral'>   * @dev Emitted on setUserUseReserveAsCollateral()</span>
 128 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
 129 |     | <span class='neutral'>   * @param user The address of the user enabling the usage as collateral</span>
 130 |     | <span class='neutral'>   */</span>
 131 |     | <span class='neutral'>  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>  /**</span>
 134 |     | <span class='neutral'>   * @dev Emitted on setUserUseReserveAsCollateral()</span>
 135 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
 136 |     | <span class='neutral'>   * @param user The address of the user enabling the usage as collateral</span>
 137 |     | <span class='neutral'>   */</span>
 138 |     | <span class='neutral'>  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>  /**</span>
 141 |     | <span class='neutral'>   * @dev Emitted on rebalanceStableBorrowRate()</span>
 142 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
 143 |     | <span class='neutral'>   * @param user The address of the user for which the rebalance has been executed</span>
 144 |     | <span class='neutral'>   */</span>
 145 |     | <span class='neutral'>  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>  /**</span>
 148 |     | <span class='neutral'>   * @dev Emitted on flashLoan()</span>
 149 |     | <span class='neutral'>   * @param target The address of the flash loan receiver contract</span>
 150 |     | <span class='neutral'>   * @param initiator The address initiating the flash loan</span>
 151 |     | <span class='neutral'>   * @param asset The address of the asset being flash borrowed</span>
 152 |     | <span class='neutral'>   * @param amount The amount flash borrowed</span>
 153 |     | <span class='neutral'>   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt</span>
 154 |     | <span class='neutral'>   * @param premium The fee flash borrowed</span>
 155 |     | <span class='neutral'>   * @param referralCode The referral code used</span>
 156 |     | <span class='neutral'>   */</span>
 157 |     | <span class='neutral'>  event FlashLoan(</span>
 158 |     | <span class='neutral'>    address indexed target,</span>
 159 |     | <span class='neutral'>    address initiator,</span>
 160 |     | <span class='neutral'>    address indexed asset,</span>
 161 |     | <span class='neutral'>    uint256 amount,</span>
 162 |     | <span class='neutral'>    DataTypes.InterestRateMode interestRateMode,</span>
 163 |     | <span class='neutral'>    uint256 premium,</span>
 164 |     | <span class='neutral'>    uint16 indexed referralCode</span>
 165 |     | <span class='neutral'>  );</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>  /**</span>
 168 |     | <span class='neutral'>   * @dev Emitted when a borrower is liquidated.</span>
 169 |     | <span class='neutral'>   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation</span>
 170 |     | <span class='neutral'>   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation</span>
 171 |     | <span class='neutral'>   * @param user The address of the borrower getting liquidated</span>
 172 |     | <span class='neutral'>   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover</span>
 173 |     | <span class='neutral'>   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator</span>
 174 |     | <span class='neutral'>   * @param liquidator The address of the liquidator</span>
 175 |     | <span class='neutral'>   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants</span>
 176 |     | <span class='neutral'>   * to receive the underlying collateral asset directly</span>
 177 |     | <span class='neutral'>   */</span>
 178 |     | <span class='neutral'>  event LiquidationCall(</span>
 179 |     | <span class='neutral'>    address indexed collateralAsset,</span>
 180 |     | <span class='neutral'>    address indexed debtAsset,</span>
 181 |     | <span class='neutral'>    address indexed user,</span>
 182 |     | <span class='neutral'>    uint256 debtToCover,</span>
 183 |     | <span class='neutral'>    uint256 liquidatedCollateralAmount,</span>
 184 |     | <span class='neutral'>    address liquidator,</span>
 185 |     | <span class='neutral'>    bool receiveAToken</span>
 186 |     | <span class='neutral'>  );</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>  /**</span>
 189 |     | <span class='neutral'>   * @dev Emitted when the state of a reserve is updated.</span>
 190 |     | <span class='neutral'>   * @param reserve The address of the underlying asset of the reserve</span>
 191 |     | <span class='neutral'>   * @param liquidityRate The next liquidity rate</span>
 192 |     | <span class='neutral'>   * @param stableBorrowRate The next stable borrow rate</span>
 193 |     | <span class='neutral'>   * @param variableBorrowRate The next variable borrow rate</span>
 194 |     | <span class='neutral'>   * @param liquidityIndex The next liquidity index</span>
 195 |     | <span class='neutral'>   * @param variableBorrowIndex The next variable borrow index</span>
 196 |     | <span class='neutral'>   */</span>
 197 |     | <span class='neutral'>  event ReserveDataUpdated(</span>
 198 |     | <span class='neutral'>    address indexed reserve,</span>
 199 |     | <span class='neutral'>    uint256 liquidityRate,</span>
 200 |     | <span class='neutral'>    uint256 stableBorrowRate,</span>
 201 |     | <span class='neutral'>    uint256 variableBorrowRate,</span>
 202 |     | <span class='neutral'>    uint256 liquidityIndex,</span>
 203 |     | <span class='neutral'>    uint256 variableBorrowIndex</span>
 204 |     | <span class='neutral'>  );</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>  /**</span>
 207 |     | <span class='neutral'>   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.</span>
 208 |     | <span class='neutral'>   * @param reserve The address of the reserve</span>
 209 |     | <span class='neutral'>   * @param amountMinted The amount minted to the treasury</span>
 210 |     | <span class='neutral'>   */</span>
 211 |     | <span class='neutral'>  event MintedToTreasury(address indexed reserve, uint256 amountMinted);</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>  /**</span>
 214 |     | <span class='neutral'>   * @notice Mints an `amount` of aTokens to the `onBehalfOf`</span>
 215 |     | <span class='neutral'>   * @param asset The address of the underlying asset to mint</span>
 216 |     | <span class='neutral'>   * @param amount The amount to mint</span>
 217 |     | <span class='neutral'>   * @param onBehalfOf The address that will receive the aTokens</span>
 218 |     | <span class='neutral'>   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.</span>
 219 |     | <span class='neutral'>   *   0 if the action is executed directly by the user, without any middle-man</span>
 220 |     | <span class='neutral'>   */</span>
 221 |     | <span class='neutral'>  function mintUnbacked(</span>
 222 |     | <span class='neutral'>    address asset,</span>
 223 |     | <span class='neutral'>    uint256 amount,</span>
 224 |     | <span class='neutral'>    address onBehalfOf,</span>
 225 |     | <span class='neutral'>    uint16 referralCode</span>
 226 |     | <span class='neutral'>  ) external;</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>  /**</span>
 229 |     | <span class='neutral'>   * @notice Back the current unbacked underlying with `amount` and pay `fee`.</span>
 230 |     | <span class='neutral'>   * @param asset The address of the underlying asset to back</span>
 231 |     | <span class='neutral'>   * @param amount The amount to back</span>
 232 |     | <span class='neutral'>   * @param fee The amount paid in fees</span>
 233 |     | <span class='neutral'>   * @return The backed amount</span>
 234 |     | <span class='neutral'>   */</span>
 235 |     | <span class='neutral'>  function backUnbacked(</span>
 236 |     | <span class='neutral'>    address asset,</span>
 237 |     | <span class='neutral'>    uint256 amount,</span>
 238 |     | <span class='neutral'>    uint256 fee</span>
 239 |     | <span class='neutral'>  ) external returns (uint256);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>  /**</span>
 242 |     | <span class='neutral'>   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.</span>
 243 |     | <span class='neutral'>   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC</span>
 244 |     | <span class='neutral'>   * @param asset The address of the underlying asset to supply</span>
 245 |     | <span class='neutral'>   * @param amount The amount to be supplied</span>
 246 |     | <span class='neutral'>   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user</span>
 247 |     | <span class='neutral'>   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens</span>
 248 |     | <span class='neutral'>   *   is a different wallet</span>
 249 |     | <span class='neutral'>   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.</span>
 250 |     | <span class='neutral'>   *   0 if the action is executed directly by the user, without any middle-man</span>
 251 |     | <span class='neutral'>   */</span>
 252 |     | <span class='neutral'>  function supply(</span>
 253 |     | <span class='neutral'>    address asset,</span>
 254 |     | <span class='neutral'>    uint256 amount,</span>
 255 |     | <span class='neutral'>    address onBehalfOf,</span>
 256 |     | <span class='neutral'>    uint16 referralCode</span>
 257 |     | <span class='neutral'>  ) external;</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>  /**</span>
 260 |     | <span class='neutral'>   * @notice Supply with transfer approval of asset to be supplied done via permit function</span>
 261 |     | <span class='neutral'>   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713</span>
 262 |     | <span class='neutral'>   * @param asset The address of the underlying asset to supply</span>
 263 |     | <span class='neutral'>   * @param amount The amount to be supplied</span>
 264 |     | <span class='neutral'>   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user</span>
 265 |     | <span class='neutral'>   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens</span>
 266 |     | <span class='neutral'>   *   is a different wallet</span>
 267 |     | <span class='neutral'>   * @param deadline The deadline timestamp that the permit is valid</span>
 268 |     | <span class='neutral'>   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.</span>
 269 |     | <span class='neutral'>   *   0 if the action is executed directly by the user, without any middle-man</span>
 270 |     | <span class='neutral'>   * @param permitV The V parameter of ERC712 permit sig</span>
 271 |     | <span class='neutral'>   * @param permitR The R parameter of ERC712 permit sig</span>
 272 |     | <span class='neutral'>   * @param permitS The S parameter of ERC712 permit sig</span>
 273 |     | <span class='neutral'>   */</span>
 274 |     | <span class='neutral'>  function supplyWithPermit(</span>
 275 |     | <span class='neutral'>    address asset,</span>
 276 |     | <span class='neutral'>    uint256 amount,</span>
 277 |     | <span class='neutral'>    address onBehalfOf,</span>
 278 |     | <span class='neutral'>    uint16 referralCode,</span>
 279 |     | <span class='neutral'>    uint256 deadline,</span>
 280 |     | <span class='neutral'>    uint8 permitV,</span>
 281 |     | <span class='neutral'>    bytes32 permitR,</span>
 282 |     | <span class='neutral'>    bytes32 permitS</span>
 283 |     | <span class='neutral'>  ) external;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>  /**</span>
 286 |     | <span class='neutral'>   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned</span>
 287 |     | <span class='neutral'>   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC</span>
 288 |     | <span class='neutral'>   * @param asset The address of the underlying asset to withdraw</span>
 289 |     | <span class='neutral'>   * @param amount The underlying amount to be withdrawn</span>
 290 |     | <span class='neutral'>   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance</span>
 291 |     | <span class='neutral'>   * @param to The address that will receive the underlying, same as msg.sender if the user</span>
 292 |     | <span class='neutral'>   *   wants to receive it on his own wallet, or a different address if the beneficiary is a</span>
 293 |     | <span class='neutral'>   *   different wallet</span>
 294 |     | <span class='neutral'>   * @return The final amount withdrawn</span>
 295 |     | <span class='neutral'>   */</span>
 296 |     | <span class='neutral'>  function withdraw(</span>
 297 |     | <span class='neutral'>    address asset,</span>
 298 |     | <span class='neutral'>    uint256 amount,</span>
 299 |     | <span class='neutral'>    address to</span>
 300 |     | <span class='neutral'>  ) external returns (uint256);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>  /**</span>
 303 |     | <span class='neutral'>   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower</span>
 304 |     | <span class='neutral'>   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the</span>
 305 |     | <span class='neutral'>   * corresponding debt token (StableDebtToken or VariableDebtToken)</span>
 306 |     | <span class='neutral'>   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet</span>
 307 |     | <span class='neutral'>   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`</span>
 308 |     | <span class='neutral'>   * @param asset The address of the underlying asset to borrow</span>
 309 |     | <span class='neutral'>   * @param amount The amount to be borrowed</span>
 310 |     | <span class='neutral'>   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable</span>
 311 |     | <span class='neutral'>   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.</span>
 312 |     | <span class='neutral'>   *   0 if the action is executed directly by the user, without any middle-man</span>
 313 |     | <span class='neutral'>   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself</span>
 314 |     | <span class='neutral'>   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator</span>
 315 |     | <span class='neutral'>   * if he has been given credit delegation allowance</span>
 316 |     | <span class='neutral'>   */</span>
 317 |     | <span class='neutral'>  function borrow(</span>
 318 |     | <span class='neutral'>    address asset,</span>
 319 |     | <span class='neutral'>    uint256 amount,</span>
 320 |     | <span class='neutral'>    uint256 interestRateMode,</span>
 321 |     | <span class='neutral'>    uint16 referralCode,</span>
 322 |     | <span class='neutral'>    address onBehalfOf</span>
 323 |     | <span class='neutral'>  ) external;</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>  /**</span>
 326 |     | <span class='neutral'>   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned</span>
 327 |     | <span class='neutral'>   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address</span>
 328 |     | <span class='neutral'>   * @param asset The address of the borrowed underlying asset previously borrowed</span>
 329 |     | <span class='neutral'>   * @param amount The amount to repay</span>
 330 |     | <span class='neutral'>   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`</span>
 331 |     | <span class='neutral'>   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable</span>
 332 |     | <span class='neutral'>   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the</span>
 333 |     | <span class='neutral'>   * user calling the function if he wants to reduce/remove his own debt, or the address of any other</span>
 334 |     | <span class='neutral'>   * other borrower whose debt should be removed</span>
 335 |     | <span class='neutral'>   * @return The final amount repaid</span>
 336 |     | <span class='neutral'>   */</span>
 337 |     | <span class='neutral'>  function repay(</span>
 338 |     | <span class='neutral'>    address asset,</span>
 339 |     | <span class='neutral'>    uint256 amount,</span>
 340 |     | <span class='neutral'>    uint256 interestRateMode,</span>
 341 |     | <span class='neutral'>    address onBehalfOf</span>
 342 |     | <span class='neutral'>  ) external returns (uint256);</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>  /**</span>
 345 |     | <span class='neutral'>   * @notice Repay with transfer approval of asset to be repaid done via permit function</span>
 346 |     | <span class='neutral'>   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713</span>
 347 |     | <span class='neutral'>   * @param asset The address of the borrowed underlying asset previously borrowed</span>
 348 |     | <span class='neutral'>   * @param amount The amount to repay</span>
 349 |     | <span class='neutral'>   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`</span>
 350 |     | <span class='neutral'>   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable</span>
 351 |     | <span class='neutral'>   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the</span>
 352 |     | <span class='neutral'>   * user calling the function if he wants to reduce/remove his own debt, or the address of any other</span>
 353 |     | <span class='neutral'>   * other borrower whose debt should be removed</span>
 354 |     | <span class='neutral'>   * @param deadline The deadline timestamp that the permit is valid</span>
 355 |     | <span class='neutral'>   * @param permitV The V parameter of ERC712 permit sig</span>
 356 |     | <span class='neutral'>   * @param permitR The R parameter of ERC712 permit sig</span>
 357 |     | <span class='neutral'>   * @param permitS The S parameter of ERC712 permit sig</span>
 358 |     | <span class='neutral'>   * @return The final amount repaid</span>
 359 |     | <span class='neutral'>   */</span>
 360 |     | <span class='neutral'>  function repayWithPermit(</span>
 361 |     | <span class='neutral'>    address asset,</span>
 362 |     | <span class='neutral'>    uint256 amount,</span>
 363 |     | <span class='neutral'>    uint256 interestRateMode,</span>
 364 |     | <span class='neutral'>    address onBehalfOf,</span>
 365 |     | <span class='neutral'>    uint256 deadline,</span>
 366 |     | <span class='neutral'>    uint8 permitV,</span>
 367 |     | <span class='neutral'>    bytes32 permitR,</span>
 368 |     | <span class='neutral'>    bytes32 permitS</span>
 369 |     | <span class='neutral'>  ) external returns (uint256);</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>  /**</span>
 372 |     | <span class='neutral'>   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the</span>
 373 |     | <span class='neutral'>   * equivalent debt tokens</span>
 374 |     | <span class='neutral'>   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens</span>
 375 |     | <span class='neutral'>   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken</span>
 376 |     | <span class='neutral'>   * balance is not enough to cover the whole debt</span>
 377 |     | <span class='neutral'>   * @param asset The address of the borrowed underlying asset previously borrowed</span>
 378 |     | <span class='neutral'>   * @param amount The amount to repay</span>
 379 |     | <span class='neutral'>   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`</span>
 380 |     | <span class='neutral'>   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable</span>
 381 |     | <span class='neutral'>   * @return The final amount repaid</span>
 382 |     | <span class='neutral'>   */</span>
 383 |     | <span class='neutral'>  function repayWithATokens(</span>
 384 |     | <span class='neutral'>    address asset,</span>
 385 |     | <span class='neutral'>    uint256 amount,</span>
 386 |     | <span class='neutral'>    uint256 interestRateMode</span>
 387 |     | <span class='neutral'>  ) external returns (uint256);</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>  /**</span>
 390 |     | <span class='neutral'>   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa</span>
 391 |     | <span class='neutral'>   * @param asset The address of the underlying asset borrowed</span>
 392 |     | <span class='neutral'>   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable</span>
 393 |     | <span class='neutral'>   */</span>
 394 |     | <span class='neutral'>  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>  /**</span>
 397 |     | <span class='neutral'>   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.</span>
 398 |     | <span class='neutral'>   * - Users can be rebalanced if the following conditions are satisfied:</span>
 399 |     | <span class='neutral'>   *     1. Usage ratio is above 95%</span>
 400 |     | <span class='neutral'>   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too</span>
 401 |     | <span class='neutral'>   *        much has been borrowed at a stable rate and suppliers are not earning enough</span>
 402 |     | <span class='neutral'>   * @param asset The address of the underlying asset borrowed</span>
 403 |     | <span class='neutral'>   * @param user The address of the user to be rebalanced</span>
 404 |     | <span class='neutral'>   */</span>
 405 |     | <span class='neutral'>  function rebalanceStableBorrowRate(address asset, address user) external;</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'>  /**</span>
 408 |     | <span class='neutral'>   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral</span>
 409 |     | <span class='neutral'>   * @param asset The address of the underlying asset supplied</span>
 410 |     | <span class='neutral'>   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise</span>
 411 |     | <span class='neutral'>   */</span>
 412 |     | <span class='neutral'>  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>  /**</span>
 415 |     | <span class='neutral'>   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1</span>
 416 |     | <span class='neutral'>   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives</span>
 417 |     | <span class='neutral'>   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk</span>
 418 |     | <span class='neutral'>   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation</span>
 419 |     | <span class='neutral'>   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation</span>
 420 |     | <span class='neutral'>   * @param user The address of the borrower getting liquidated</span>
 421 |     | <span class='neutral'>   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover</span>
 422 |     | <span class='neutral'>   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants</span>
 423 |     | <span class='neutral'>   * to receive the underlying collateral asset directly</span>
 424 |     | <span class='neutral'>   */</span>
 425 |     | <span class='neutral'>  function liquidationCall(</span>
 426 |     | <span class='neutral'>    address collateralAsset,</span>
 427 |     | <span class='neutral'>    address debtAsset,</span>
 428 |     | <span class='neutral'>    address user,</span>
 429 |     | <span class='neutral'>    uint256 debtToCover,</span>
 430 |     | <span class='neutral'>    bool receiveAToken</span>
 431 |     | <span class='neutral'>  ) external;</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>  /**</span>
 434 |     | <span class='neutral'>   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,</span>
 435 |     | <span class='neutral'>   * as long as the amount taken plus a fee is returned.</span>
 436 |     | <span class='neutral'>   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept</span>
 437 |     | <span class='neutral'>   * into consideration. For further details please visit https://docs.aave.com/developers/</span>
 438 |     | <span class='neutral'>   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface</span>
 439 |     | <span class='neutral'>   * @param assets The addresses of the assets being flash-borrowed</span>
 440 |     | <span class='neutral'>   * @param amounts The amounts of the assets being flash-borrowed</span>
 441 |     | <span class='neutral'>   * @param interestRateModes Types of the debt to open if the flash loan is not returned:</span>
 442 |     | <span class='neutral'>   *   0 -&gt; Don&#39;t open any debt, just revert if funds can&#39;t be transferred from the receiver</span>
 443 |     | <span class='neutral'>   *   1 -&gt; Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address</span>
 444 |     | <span class='neutral'>   *   2 -&gt; Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address</span>
 445 |     | <span class='neutral'>   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2</span>
 446 |     | <span class='neutral'>   * @param params Variadic packed params to pass to the receiver as extra information</span>
 447 |     | <span class='neutral'>   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.</span>
 448 |     | <span class='neutral'>   *   0 if the action is executed directly by the user, without any middle-man</span>
 449 |     | <span class='neutral'>   */</span>
 450 |     | <span class='neutral'>  function flashLoan(</span>
 451 |     | <span class='neutral'>    address receiverAddress,</span>
 452 |     | <span class='neutral'>    address[] calldata assets,</span>
 453 |     | <span class='neutral'>    uint256[] calldata amounts,</span>
 454 |     | <span class='neutral'>    uint256[] calldata interestRateModes,</span>
 455 |     | <span class='neutral'>    address onBehalfOf,</span>
 456 |     | <span class='neutral'>    bytes calldata params,</span>
 457 |     | <span class='neutral'>    uint16 referralCode</span>
 458 |     | <span class='neutral'>  ) external;</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>  /**</span>
 461 |     | <span class='neutral'>   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,</span>
 462 |     | <span class='neutral'>   * as long as the amount taken plus a fee is returned.</span>
 463 |     | <span class='neutral'>   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept</span>
 464 |     | <span class='neutral'>   * into consideration. For further details please visit https://docs.aave.com/developers/</span>
 465 |     | <span class='neutral'>   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface</span>
 466 |     | <span class='neutral'>   * @param asset The address of the asset being flash-borrowed</span>
 467 |     | <span class='neutral'>   * @param amount The amount of the asset being flash-borrowed</span>
 468 |     | <span class='neutral'>   * @param params Variadic packed params to pass to the receiver as extra information</span>
 469 |     | <span class='neutral'>   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.</span>
 470 |     | <span class='neutral'>   *   0 if the action is executed directly by the user, without any middle-man</span>
 471 |     | <span class='neutral'>   */</span>
 472 |     | <span class='neutral'>  function flashLoanSimple(</span>
 473 |     | <span class='neutral'>    address receiverAddress,</span>
 474 |     | <span class='neutral'>    address asset,</span>
 475 |     | <span class='neutral'>    uint256 amount,</span>
 476 |     | <span class='neutral'>    bytes calldata params,</span>
 477 |     | <span class='neutral'>    uint16 referralCode</span>
 478 |     | <span class='neutral'>  ) external;</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>  /**</span>
 481 |     | <span class='neutral'>   * @notice Returns the user account data across all the reserves</span>
 482 |     | <span class='neutral'>   * @param user The address of the user</span>
 483 |     | <span class='neutral'>   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed</span>
 484 |     | <span class='neutral'>   * @return totalDebtBase The total debt of the user in the base currency used by the price feed</span>
 485 |     | <span class='neutral'>   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed</span>
 486 |     | <span class='neutral'>   * @return currentLiquidationThreshold The liquidation threshold of the user</span>
 487 |     | <span class='neutral'>   * @return ltv The loan to value of The user</span>
 488 |     | <span class='neutral'>   * @return healthFactor The current health factor of the user</span>
 489 |     | <span class='neutral'>   */</span>
 490 |     | <span class='neutral'>  function getUserAccountData(address user)</span>
 491 |     | <span class='neutral'>    external</span>
 492 |     | <span class='neutral'>    view</span>
 493 |     | <span class='neutral'>    returns (</span>
 494 |     | <span class='neutral'>      uint256 totalCollateralBase,</span>
 495 |     | <span class='neutral'>      uint256 totalDebtBase,</span>
 496 |     | <span class='neutral'>      uint256 availableBorrowsBase,</span>
 497 |     | <span class='neutral'>      uint256 currentLiquidationThreshold,</span>
 498 |     | <span class='neutral'>      uint256 ltv,</span>
 499 |     | <span class='neutral'>      uint256 healthFactor</span>
 500 |     | <span class='neutral'>    );</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>  /**</span>
 503 |     | <span class='neutral'>   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an</span>
 504 |     | <span class='neutral'>   * interest rate strategy</span>
 505 |     | <span class='neutral'>   * @dev Only callable by the PoolConfigurator contract</span>
 506 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 507 |     | <span class='neutral'>   * @param aTokenAddress The address of the aToken that will be assigned to the reserve</span>
 508 |     | <span class='neutral'>   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve</span>
 509 |     | <span class='neutral'>   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve</span>
 510 |     | <span class='neutral'>   * @param interestRateStrategyAddress The address of the interest rate strategy contract</span>
 511 |     | <span class='neutral'>   */</span>
 512 |     | <span class='neutral'>  function initReserve(</span>
 513 |     | <span class='neutral'>    address asset,</span>
 514 |     | <span class='neutral'>    address aTokenAddress,</span>
 515 |     | <span class='neutral'>    address stableDebtAddress,</span>
 516 |     | <span class='neutral'>    address variableDebtAddress,</span>
 517 |     | <span class='neutral'>    address interestRateStrategyAddress</span>
 518 |     | <span class='neutral'>  ) external;</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>  /**</span>
 521 |     | <span class='neutral'>   * @notice Drop a reserve</span>
 522 |     | <span class='neutral'>   * @dev Only callable by the PoolConfigurator contract</span>
 523 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 524 |     | <span class='neutral'>   */</span>
 525 |     | <span class='neutral'>  function dropReserve(address asset) external;</span>
 526 |     | <span class='neutral'></span>
 527 |     | <span class='neutral'>  /**</span>
 528 |     | <span class='neutral'>   * @notice Updates the address of the interest rate strategy contract</span>
 529 |     | <span class='neutral'>   * @dev Only callable by the PoolConfigurator contract</span>
 530 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 531 |     | <span class='neutral'>   * @param rateStrategyAddress The address of the interest rate strategy contract</span>
 532 |     | <span class='neutral'>   */</span>
 533 |     | <span class='neutral'>  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)</span>
 534 |     | <span class='neutral'>    external;</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='neutral'>  /**</span>
 537 |     | <span class='neutral'>   * @notice Sets the configuration bitmap of the reserve as a whole</span>
 538 |     | <span class='neutral'>   * @dev Only callable by the PoolConfigurator contract</span>
 539 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 540 |     | <span class='neutral'>   * @param configuration The new configuration bitmap</span>
 541 |     | <span class='neutral'>   */</span>
 542 |     | <span class='neutral'>  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)</span>
 543 |     | <span class='neutral'>    external;</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='neutral'>  /**</span>
 546 |     | <span class='neutral'>   * @notice Returns the configuration of the reserve</span>
 547 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 548 |     | <span class='neutral'>   * @return The configuration of the reserve</span>
 549 |     | <span class='neutral'>   */</span>
 550 |     | <span class='neutral'>  function getConfiguration(address asset)</span>
 551 |     | <span class='neutral'>    external</span>
 552 |     | <span class='neutral'>    view</span>
 553 |     | <span class='neutral'>    returns (DataTypes.ReserveConfigurationMap memory);</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='neutral'>  /**</span>
 556 |     | <span class='neutral'>   * @notice Returns the configuration of the user across all the reserves</span>
 557 |     | <span class='neutral'>   * @param user The user address</span>
 558 |     | <span class='neutral'>   * @return The configuration of the user</span>
 559 |     | <span class='neutral'>   */</span>
 560 |     | <span class='neutral'>  function getUserConfiguration(address user)</span>
 561 |     | <span class='neutral'>    external</span>
 562 |     | <span class='neutral'>    view</span>
 563 |     | <span class='neutral'>    returns (DataTypes.UserConfigurationMap memory);</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>  /**</span>
 566 |     | <span class='neutral'>   * @notice Returns the normalized income of the reserve</span>
 567 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 568 |     | <span class='neutral'>   * @return The reserve&#39;s normalized income</span>
 569 |     | <span class='neutral'>   */</span>
 570 |     | <span class='neutral'>  function getReserveNormalizedIncome(address asset) external view returns (uint256);</span>
 571 |     | <span class='neutral'></span>
 572 |     | <span class='neutral'>  /**</span>
 573 |     | <span class='neutral'>   * @notice Returns the normalized variable debt per unit of asset</span>
 574 |     | <span class='neutral'>   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a</span>
 575 |     | <span class='neutral'>   * &quot;dynamic&quot; variable index based on time, current stored index and virtual rate at the current</span>
 576 |     | <span class='neutral'>   * moment (approx. a borrower would get if opening a position). This means that is always used in</span>
 577 |     | <span class='neutral'>   * combination with variable debt supply/balances.</span>
 578 |     | <span class='neutral'>   * If using this function externally, consider that is possible to have an increasing normalized</span>
 579 |     | <span class='neutral'>   * variable debt that is not equivalent to how the variable debt index would be updated in storage</span>
 580 |     | <span class='neutral'>   * (e.g. only updates with non-zero variable debt supply)</span>
 581 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 582 |     | <span class='neutral'>   * @return The reserve normalized variable debt</span>
 583 |     | <span class='neutral'>   */</span>
 584 |     | <span class='neutral'>  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);</span>
 585 |     | <span class='neutral'></span>
 586 |     | <span class='neutral'>  /**</span>
 587 |     | <span class='neutral'>   * @notice Returns the state and configuration of the reserve</span>
 588 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 589 |     | <span class='neutral'>   * @return The state and configuration data of the reserve</span>
 590 |     | <span class='neutral'>   */</span>
 591 |     | <span class='neutral'>  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);</span>
 592 |     | <span class='neutral'></span>
 593 |     | <span class='neutral'>  /**</span>
 594 |     | <span class='neutral'>   * @notice Validates and finalizes an aToken transfer</span>
 595 |     | <span class='neutral'>   * @dev Only callable by the overlying aToken of the `asset`</span>
 596 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the aToken</span>
 597 |     | <span class='neutral'>   * @param from The user from which the aTokens are transferred</span>
 598 |     | <span class='neutral'>   * @param to The user receiving the aTokens</span>
 599 |     | <span class='neutral'>   * @param amount The amount being transferred/withdrawn</span>
 600 |     | <span class='neutral'>   * @param balanceFromBefore The aToken balance of the `from` user before the transfer</span>
 601 |     | <span class='neutral'>   * @param balanceToBefore The aToken balance of the `to` user before the transfer</span>
 602 |     | <span class='neutral'>   */</span>
 603 |     | <span class='neutral'>  function finalizeTransfer(</span>
 604 |     | <span class='neutral'>    address asset,</span>
 605 |     | <span class='neutral'>    address from,</span>
 606 |     | <span class='neutral'>    address to,</span>
 607 |     | <span class='neutral'>    uint256 amount,</span>
 608 |     | <span class='neutral'>    uint256 balanceFromBefore,</span>
 609 |     | <span class='neutral'>    uint256 balanceToBefore</span>
 610 |     | <span class='neutral'>  ) external;</span>
 611 |     | <span class='neutral'></span>
 612 |     | <span class='neutral'>  /**</span>
 613 |     | <span class='neutral'>   * @notice Returns the list of the underlying assets of all the initialized reserves</span>
 614 |     | <span class='neutral'>   * @dev It does not include dropped reserves</span>
 615 |     | <span class='neutral'>   * @return The addresses of the underlying assets of the initialized reserves</span>
 616 |     | <span class='neutral'>   */</span>
 617 |     | <span class='neutral'>  function getReservesList() external view returns (address[] memory);</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='neutral'>  /**</span>
 620 |     | <span class='neutral'>   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct</span>
 621 |     | <span class='neutral'>   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct</span>
 622 |     | <span class='neutral'>   * @return The address of the reserve associated with id</span>
 623 |     | <span class='neutral'>   */</span>
 624 |     | <span class='neutral'>  function getReserveAddressById(uint16 id) external view returns (address);</span>
 625 |     | <span class='neutral'></span>
 626 |     | <span class='neutral'>  /**</span>
 627 |     | <span class='neutral'>   * @notice Returns the PoolAddressesProvider connected to this contract</span>
 628 |     | <span class='neutral'>   * @return The address of the PoolAddressesProvider</span>
 629 |     | <span class='neutral'>   */</span>
 630 |     | <span class='neutral'>  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);</span>
 631 |     | <span class='neutral'></span>
 632 |     | <span class='neutral'>  /**</span>
 633 |     | <span class='neutral'>   * @notice Updates the protocol fee on the bridging</span>
 634 |     | <span class='neutral'>   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury</span>
 635 |     | <span class='neutral'>   */</span>
 636 |     | <span class='neutral'>  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='neutral'>  /**</span>
 639 |     | <span class='neutral'>   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:</span>
 640 |     | <span class='neutral'>   * - A part is sent to aToken holders as extra, one time accumulated interest</span>
 641 |     | <span class='neutral'>   * - A part is collected by the protocol treasury</span>
 642 |     | <span class='neutral'>   * @dev The total premium is calculated on the total borrowed amount</span>
 643 |     | <span class='neutral'>   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`</span>
 644 |     | <span class='neutral'>   * @dev Only callable by the PoolConfigurator contract</span>
 645 |     | <span class='neutral'>   * @param flashLoanPremiumTotal The total premium, expressed in bps</span>
 646 |     | <span class='neutral'>   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps</span>
 647 |     | <span class='neutral'>   */</span>
 648 |     | <span class='neutral'>  function updateFlashloanPremiums(</span>
 649 |     | <span class='neutral'>    uint128 flashLoanPremiumTotal,</span>
 650 |     | <span class='neutral'>    uint128 flashLoanPremiumToProtocol</span>
 651 |     | <span class='neutral'>  ) external;</span>
 652 |     | <span class='neutral'></span>
 653 |     | <span class='neutral'>  /**</span>
 654 |     | <span class='neutral'>   * @notice Configures a new category for the eMode.</span>
 655 |     | <span class='neutral'>   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.</span>
 656 |     | <span class='neutral'>   * The category 0 is reserved as it&#39;s the default for volatile assets</span>
 657 |     | <span class='neutral'>   * @param id The id of the category</span>
 658 |     | <span class='neutral'>   * @param config The configuration of the category</span>
 659 |     | <span class='neutral'>   */</span>
 660 |     | <span class='neutral'>  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;</span>
 661 |     | <span class='neutral'></span>
 662 |     | <span class='neutral'>  /**</span>
 663 |     | <span class='neutral'>   * @notice Returns the data of an eMode category</span>
 664 |     | <span class='neutral'>   * @param id The id of the category</span>
 665 |     | <span class='neutral'>   * @return The configuration data of the category</span>
 666 |     | <span class='neutral'>   */</span>
 667 |     | <span class='neutral'>  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);</span>
 668 |     | <span class='neutral'></span>
 669 |     | <span class='neutral'>  /**</span>
 670 |     | <span class='neutral'>   * @notice Allows a user to use the protocol in eMode</span>
 671 |     | <span class='neutral'>   * @param categoryId The id of the category</span>
 672 |     | <span class='neutral'>   */</span>
 673 |     | <span class='neutral'>  function setUserEMode(uint8 categoryId) external;</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='neutral'>  /**</span>
 676 |     | <span class='neutral'>   * @notice Returns the eMode the user is using</span>
 677 |     | <span class='neutral'>   * @param user The address of the user</span>
 678 |     | <span class='neutral'>   * @return The eMode id</span>
 679 |     | <span class='neutral'>   */</span>
 680 |     | <span class='neutral'>  function getUserEMode(address user) external view returns (uint256);</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='neutral'>  /**</span>
 683 |     | <span class='neutral'>   * @notice Resets the isolation mode total debt of the given asset to zero</span>
 684 |     | <span class='neutral'>   * @dev It requires the given asset has zero debt ceiling</span>
 685 |     | <span class='neutral'>   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt</span>
 686 |     | <span class='neutral'>   */</span>
 687 |     | <span class='neutral'>  function resetIsolationModeTotalDebt(address asset) external;</span>
 688 |     | <span class='neutral'></span>
 689 |     | <span class='neutral'>  /**</span>
 690 |     | <span class='neutral'>   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate</span>
 691 |     | <span class='neutral'>   * @return The percentage of available liquidity to borrow, expressed in bps</span>
 692 |     | <span class='neutral'>   */</span>
 693 |     | <span class='neutral'>  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);</span>
 694 |     | <span class='neutral'></span>
 695 |     | <span class='neutral'>  /**</span>
 696 |     | <span class='neutral'>   * @notice Returns the total fee on flash loans</span>
 697 |     | <span class='neutral'>   * @return The total fee on flashloans</span>
 698 |     | <span class='neutral'>   */</span>
 699 |     | <span class='neutral'>  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);</span>
 700 |     | <span class='neutral'></span>
 701 |     | <span class='neutral'>  /**</span>
 702 |     | <span class='neutral'>   * @notice Returns the part of the bridge fees sent to protocol</span>
 703 |     | <span class='neutral'>   * @return The bridge fee sent to the protocol treasury</span>
 704 |     | <span class='neutral'>   */</span>
 705 |     | <span class='neutral'>  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);</span>
 706 |     | <span class='neutral'></span>
 707 |     | <span class='neutral'>  /**</span>
 708 |     | <span class='neutral'>   * @notice Returns the part of the flashloan fees sent to protocol</span>
 709 |     | <span class='neutral'>   * @return The flashloan fee sent to the protocol treasury</span>
 710 |     | <span class='neutral'>   */</span>
 711 |     | <span class='neutral'>  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);</span>
 712 |     | <span class='neutral'></span>
 713 |     | <span class='neutral'>  /**</span>
 714 |     | <span class='neutral'>   * @notice Returns the maximum number of reserves supported to be listed in this Pool</span>
 715 |     | <span class='neutral'>   * @return The maximum number of reserves supported</span>
 716 |     | <span class='neutral'>   */</span>
 717 |     | <span class='neutral'>  function MAX_NUMBER_RESERVES() external view returns (uint16);</span>
 718 |     | <span class='neutral'></span>
 719 |     | <span class='neutral'>  /**</span>
 720 |     | <span class='neutral'>   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens</span>
 721 |     | <span class='neutral'>   * @param assets The list of reserves for which the minting needs to be executed</span>
 722 |     | <span class='neutral'>   */</span>
 723 |     | <span class='neutral'>  function mintToTreasury(address[] calldata assets) external;</span>
 724 |     | <span class='neutral'></span>
 725 |     | <span class='neutral'>  /**</span>
 726 |     | <span class='neutral'>   * @notice Rescue and transfer tokens locked in this contract</span>
 727 |     | <span class='neutral'>   * @param token The address of the token</span>
 728 |     | <span class='neutral'>   * @param to The address of the recipient</span>
 729 |     | <span class='neutral'>   * @param amount The amount of token to transfer</span>
 730 |     | <span class='neutral'>   */</span>
 731 |     | <span class='neutral'>  function rescueTokens(</span>
 732 |     | <span class='neutral'>    address token,</span>
 733 |     | <span class='neutral'>    address to,</span>
 734 |     | <span class='neutral'>    uint256 amount</span>
 735 |     | <span class='neutral'>  ) external;</span>
 736 |     | <span class='neutral'></span>
 737 |     | <span class='neutral'>  /**</span>
 738 |     | <span class='neutral'>   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.</span>
 739 |     | <span class='neutral'>   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC</span>
 740 |     | <span class='neutral'>   * @dev Deprecated: Use the `supply` function instead</span>
 741 |     | <span class='neutral'>   * @param asset The address of the underlying asset to supply</span>
 742 |     | <span class='neutral'>   * @param amount The amount to be supplied</span>
 743 |     | <span class='neutral'>   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user</span>
 744 |     | <span class='neutral'>   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens</span>
 745 |     | <span class='neutral'>   *   is a different wallet</span>
 746 |     | <span class='neutral'>   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.</span>
 747 |     | <span class='neutral'>   *   0 if the action is executed directly by the user, without any middle-man</span>
 748 |     | <span class='neutral'>   */</span>
 749 |     | <span class='neutral'>  function deposit(</span>
 750 |     | <span class='neutral'>    address asset,</span>
 751 |     | <span class='neutral'>    uint256 amount,</span>
 752 |     | <span class='neutral'>    address onBehalfOf,</span>
 753 |     | <span class='neutral'>    uint16 referralCode</span>
 754 |     | <span class='neutral'>  ) external;</span>
 755 |     | <span class='neutral'>}</span>
 756 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title IPoolAddressesProvider</span>
   6 |     | <span class='neutral'> * @author Aave</span>
   7 |     | <span class='neutral'> * @notice Defines the basic interface for a Pool Addresses Provider.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IPoolAddressesProvider {</span>
  10 |     | <span class='neutral'>  /**</span>
  11 |     | <span class='neutral'>   * @dev Emitted when the market identifier is updated.</span>
  12 |     | <span class='neutral'>   * @param oldMarketId The old id of the market</span>
  13 |     | <span class='neutral'>   * @param newMarketId The new id of the market</span>
  14 |     | <span class='neutral'>   */</span>
  15 |     | <span class='neutral'>  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>  /**</span>
  18 |     | <span class='neutral'>   * @dev Emitted when the pool is updated.</span>
  19 |     | <span class='neutral'>   * @param oldAddress The old address of the Pool</span>
  20 |     | <span class='neutral'>   * @param newAddress The new address of the Pool</span>
  21 |     | <span class='neutral'>   */</span>
  22 |     | <span class='neutral'>  event PoolUpdated(address indexed oldAddress, address indexed newAddress);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>  /**</span>
  25 |     | <span class='neutral'>   * @dev Emitted when the pool configurator is updated.</span>
  26 |     | <span class='neutral'>   * @param oldAddress The old address of the PoolConfigurator</span>
  27 |     | <span class='neutral'>   * @param newAddress The new address of the PoolConfigurator</span>
  28 |     | <span class='neutral'>   */</span>
  29 |     | <span class='neutral'>  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>  /**</span>
  32 |     | <span class='neutral'>   * @dev Emitted when the price oracle is updated.</span>
  33 |     | <span class='neutral'>   * @param oldAddress The old address of the PriceOracle</span>
  34 |     | <span class='neutral'>   * @param newAddress The new address of the PriceOracle</span>
  35 |     | <span class='neutral'>   */</span>
  36 |     | <span class='neutral'>  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>  /**</span>
  39 |     | <span class='neutral'>   * @dev Emitted when the ACL manager is updated.</span>
  40 |     | <span class='neutral'>   * @param oldAddress The old address of the ACLManager</span>
  41 |     | <span class='neutral'>   * @param newAddress The new address of the ACLManager</span>
  42 |     | <span class='neutral'>   */</span>
  43 |     | <span class='neutral'>  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>  /**</span>
  46 |     | <span class='neutral'>   * @dev Emitted when the ACL admin is updated.</span>
  47 |     | <span class='neutral'>   * @param oldAddress The old address of the ACLAdmin</span>
  48 |     | <span class='neutral'>   * @param newAddress The new address of the ACLAdmin</span>
  49 |     | <span class='neutral'>   */</span>
  50 |     | <span class='neutral'>  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>  /**</span>
  53 |     | <span class='neutral'>   * @dev Emitted when the price oracle sentinel is updated.</span>
  54 |     | <span class='neutral'>   * @param oldAddress The old address of the PriceOracleSentinel</span>
  55 |     | <span class='neutral'>   * @param newAddress The new address of the PriceOracleSentinel</span>
  56 |     | <span class='neutral'>   */</span>
  57 |     | <span class='neutral'>  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>  /**</span>
  60 |     | <span class='neutral'>   * @dev Emitted when the pool data provider is updated.</span>
  61 |     | <span class='neutral'>   * @param oldAddress The old address of the PoolDataProvider</span>
  62 |     | <span class='neutral'>   * @param newAddress The new address of the PoolDataProvider</span>
  63 |     | <span class='neutral'>   */</span>
  64 |     | <span class='neutral'>  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>  /**</span>
  67 |     | <span class='neutral'>   * @dev Emitted when a new proxy is created.</span>
  68 |     | <span class='neutral'>   * @param id The identifier of the proxy</span>
  69 |     | <span class='neutral'>   * @param proxyAddress The address of the created proxy contract</span>
  70 |     | <span class='neutral'>   * @param implementationAddress The address of the implementation contract</span>
  71 |     | <span class='neutral'>   */</span>
  72 |     | <span class='neutral'>  event ProxyCreated(</span>
  73 |     | <span class='neutral'>    bytes32 indexed id,</span>
  74 |     | <span class='neutral'>    address indexed proxyAddress,</span>
  75 |     | <span class='neutral'>    address indexed implementationAddress</span>
  76 |     | <span class='neutral'>  );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>  /**</span>
  79 |     | <span class='neutral'>   * @dev Emitted when a new non-proxied contract address is registered.</span>
  80 |     | <span class='neutral'>   * @param id The identifier of the contract</span>
  81 |     | <span class='neutral'>   * @param oldAddress The address of the old contract</span>
  82 |     | <span class='neutral'>   * @param newAddress The address of the new contract</span>
  83 |     | <span class='neutral'>   */</span>
  84 |     | <span class='neutral'>  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>  /**</span>
  87 |     | <span class='neutral'>   * @dev Emitted when the implementation of the proxy registered with id is updated</span>
  88 |     | <span class='neutral'>   * @param id The identifier of the contract</span>
  89 |     | <span class='neutral'>   * @param proxyAddress The address of the proxy contract</span>
  90 |     | <span class='neutral'>   * @param oldImplementationAddress The address of the old implementation contract</span>
  91 |     | <span class='neutral'>   * @param newImplementationAddress The address of the new implementation contract</span>
  92 |     | <span class='neutral'>   */</span>
  93 |     | <span class='neutral'>  event AddressSetAsProxy(</span>
  94 |     | <span class='neutral'>    bytes32 indexed id,</span>
  95 |     | <span class='neutral'>    address indexed proxyAddress,</span>
  96 |     | <span class='neutral'>    address oldImplementationAddress,</span>
  97 |     | <span class='neutral'>    address indexed newImplementationAddress</span>
  98 |     | <span class='neutral'>  );</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>  /**</span>
 101 |     | <span class='neutral'>   * @notice Returns the id of the Aave market to which this contract points to.</span>
 102 |     | <span class='neutral'>   * @return The market id</span>
 103 |     | <span class='neutral'>   */</span>
 104 |     | <span class='neutral'>  function getMarketId() external view returns (string memory);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>  /**</span>
 107 |     | <span class='neutral'>   * @notice Associates an id with a specific PoolAddressesProvider.</span>
 108 |     | <span class='neutral'>   * @dev This can be used to create an onchain registry of PoolAddressesProviders to</span>
 109 |     | <span class='neutral'>   * identify and validate multiple Aave markets.</span>
 110 |     | <span class='neutral'>   * @param newMarketId The market id</span>
 111 |     | <span class='neutral'>   */</span>
 112 |     | <span class='neutral'>  function setMarketId(string calldata newMarketId) external;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>  /**</span>
 115 |     | <span class='neutral'>   * @notice Returns an address by its identifier.</span>
 116 |     | <span class='neutral'>   * @dev The returned address might be an EOA or a contract, potentially proxied</span>
 117 |     | <span class='neutral'>   * @dev It returns ZERO if there is no registered address with the given id</span>
 118 |     | <span class='neutral'>   * @param id The id</span>
 119 |     | <span class='neutral'>   * @return The address of the registered for the specified id</span>
 120 |     | <span class='neutral'>   */</span>
 121 |     | <span class='neutral'>  function getAddress(bytes32 id) external view returns (address);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>  /**</span>
 124 |     | <span class='neutral'>   * @notice General function to update the implementation of a proxy registered with</span>
 125 |     | <span class='neutral'>   * certain `id`. If there is no proxy registered, it will instantiate one and</span>
 126 |     | <span class='neutral'>   * set as implementation the `newImplementationAddress`.</span>
 127 |     | <span class='neutral'>   * @dev IMPORTANT Use this function carefully, only for ids that don&#39;t have an explicit</span>
 128 |     | <span class='neutral'>   * setter function, in order to avoid unexpected consequences</span>
 129 |     | <span class='neutral'>   * @param id The id</span>
 130 |     | <span class='neutral'>   * @param newImplementationAddress The address of the new implementation</span>
 131 |     | <span class='neutral'>   */</span>
 132 |     | <span class='neutral'>  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>  /**</span>
 135 |     | <span class='neutral'>   * @notice Sets an address for an id replacing the address saved in the addresses map.</span>
 136 |     | <span class='neutral'>   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement</span>
 137 |     | <span class='neutral'>   * @param id The id</span>
 138 |     | <span class='neutral'>   * @param newAddress The address to set</span>
 139 |     | <span class='neutral'>   */</span>
 140 |     | <span class='neutral'>  function setAddress(bytes32 id, address newAddress) external;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>  /**</span>
 143 |     | <span class='neutral'>   * @notice Returns the address of the Pool proxy.</span>
 144 |     | <span class='neutral'>   * @return The Pool proxy address</span>
 145 |     | <span class='neutral'>   */</span>
 146 |     | <span class='neutral'>  function getPool() external view returns (address);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>  /**</span>
 149 |     | <span class='neutral'>   * @notice Updates the implementation of the Pool, or creates a proxy</span>
 150 |     | <span class='neutral'>   * setting the new `pool` implementation when the function is called for the first time.</span>
 151 |     | <span class='neutral'>   * @param newPoolImpl The new Pool implementation</span>
 152 |     | <span class='neutral'>   */</span>
 153 |     | <span class='neutral'>  function setPoolImpl(address newPoolImpl) external;</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>  /**</span>
 156 |     | <span class='neutral'>   * @notice Returns the address of the PoolConfigurator proxy.</span>
 157 |     | <span class='neutral'>   * @return The PoolConfigurator proxy address</span>
 158 |     | <span class='neutral'>   */</span>
 159 |     | <span class='neutral'>  function getPoolConfigurator() external view returns (address);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>  /**</span>
 162 |     | <span class='neutral'>   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy</span>
 163 |     | <span class='neutral'>   * setting the new `PoolConfigurator` implementation when the function is called for the first time.</span>
 164 |     | <span class='neutral'>   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation</span>
 165 |     | <span class='neutral'>   */</span>
 166 |     | <span class='neutral'>  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>  /**</span>
 169 |     | <span class='neutral'>   * @notice Returns the address of the price oracle.</span>
 170 |     | <span class='neutral'>   * @return The address of the PriceOracle</span>
 171 |     | <span class='neutral'>   */</span>
 172 |     | <span class='neutral'>  function getPriceOracle() external view returns (address);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>  /**</span>
 175 |     | <span class='neutral'>   * @notice Updates the address of the price oracle.</span>
 176 |     | <span class='neutral'>   * @param newPriceOracle The address of the new PriceOracle</span>
 177 |     | <span class='neutral'>   */</span>
 178 |     | <span class='neutral'>  function setPriceOracle(address newPriceOracle) external;</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>  /**</span>
 181 |     | <span class='neutral'>   * @notice Returns the address of the ACL manager.</span>
 182 |     | <span class='neutral'>   * @return The address of the ACLManager</span>
 183 |     | <span class='neutral'>   */</span>
 184 |     | <span class='neutral'>  function getACLManager() external view returns (address);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>  /**</span>
 187 |     | <span class='neutral'>   * @notice Updates the address of the ACL manager.</span>
 188 |     | <span class='neutral'>   * @param newAclManager The address of the new ACLManager</span>
 189 |     | <span class='neutral'>   */</span>
 190 |     | <span class='neutral'>  function setACLManager(address newAclManager) external;</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>  /**</span>
 193 |     | <span class='neutral'>   * @notice Returns the address of the ACL admin.</span>
 194 |     | <span class='neutral'>   * @return The address of the ACL admin</span>
 195 |     | <span class='neutral'>   */</span>
 196 |     | <span class='neutral'>  function getACLAdmin() external view returns (address);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>  /**</span>
 199 |     | <span class='neutral'>   * @notice Updates the address of the ACL admin.</span>
 200 |     | <span class='neutral'>   * @param newAclAdmin The address of the new ACL admin</span>
 201 |     | <span class='neutral'>   */</span>
 202 |     | <span class='neutral'>  function setACLAdmin(address newAclAdmin) external;</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>  /**</span>
 205 |     | <span class='neutral'>   * @notice Returns the address of the price oracle sentinel.</span>
 206 |     | <span class='neutral'>   * @return The address of the PriceOracleSentinel</span>
 207 |     | <span class='neutral'>   */</span>
 208 |     | <span class='neutral'>  function getPriceOracleSentinel() external view returns (address);</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>  /**</span>
 211 |     | <span class='neutral'>   * @notice Updates the address of the price oracle sentinel.</span>
 212 |     | <span class='neutral'>   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel</span>
 213 |     | <span class='neutral'>   */</span>
 214 |     | <span class='neutral'>  function setPriceOracleSentinel(address newPriceOracleSentinel) external;</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>  /**</span>
 217 |     | <span class='neutral'>   * @notice Returns the address of the data provider.</span>
 218 |     | <span class='neutral'>   * @return The address of the DataProvider</span>
 219 |     | <span class='neutral'>   */</span>
 220 |     | <span class='neutral'>  function getPoolDataProvider() external view returns (address);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>  /**</span>
 223 |     | <span class='neutral'>   * @notice Updates the address of the data provider.</span>
 224 |     | <span class='neutral'>   * @param newDataProvider The address of the new DataProvider</span>
 225 |     | <span class='neutral'>   */</span>
 226 |     | <span class='neutral'>  function setPoolDataProvider(address newDataProvider) external;</span>
 227 |     | <span class='neutral'>}</span>
 228 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IPoolDataProvider.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IPoolAddressesProvider} from &#39;./IPoolAddressesProvider.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title IPoolDataProvider</span>
   8 |     | <span class='neutral'> * @author Aave</span>
   9 |     | <span class='neutral'> * @notice Defines the basic interface of a PoolDataProvider</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface IPoolDataProvider {</span>
  12 |     | <span class='neutral'>  struct TokenData {</span>
  13 |     | <span class='neutral'>    string symbol;</span>
  14 |     | <span class='neutral'>    address tokenAddress;</span>
  15 |     | <span class='neutral'>  }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>  /**</span>
  18 |     | <span class='neutral'>   * @notice Returns the address for the PoolAddressesProvider contract.</span>
  19 |     | <span class='neutral'>   * @return The address for the PoolAddressesProvider contract</span>
  20 |     | <span class='neutral'>   */</span>
  21 |     | <span class='neutral'>  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>  /**</span>
  24 |     | <span class='neutral'>   * @notice Returns the list of the existing reserves in the pool.</span>
  25 |     | <span class='neutral'>   * @dev Handling MKR and ETH in a different way since they do not have standard `symbol` functions.</span>
  26 |     | <span class='neutral'>   * @return The list of reserves, pairs of symbols and addresses</span>
  27 |     | <span class='neutral'>   */</span>
  28 |     | <span class='neutral'>  function getAllReservesTokens() external view returns (TokenData[] memory);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>  /**</span>
  31 |     | <span class='neutral'>   * @notice Returns the list of the existing ATokens in the pool.</span>
  32 |     | <span class='neutral'>   * @return The list of ATokens, pairs of symbols and addresses</span>
  33 |     | <span class='neutral'>   */</span>
  34 |     | <span class='neutral'>  function getAllATokens() external view returns (TokenData[] memory);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>  /**</span>
  37 |     | <span class='neutral'>   * @notice Returns the configuration data of the reserve</span>
  38 |     | <span class='neutral'>   * @dev Not returning borrow and supply caps for compatibility, nor pause flag</span>
  39 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
  40 |     | <span class='neutral'>   * @return decimals The number of decimals of the reserve</span>
  41 |     | <span class='neutral'>   * @return ltv The ltv of the reserve</span>
  42 |     | <span class='neutral'>   * @return liquidationThreshold The liquidationThreshold of the reserve</span>
  43 |     | <span class='neutral'>   * @return liquidationBonus The liquidationBonus of the reserve</span>
  44 |     | <span class='neutral'>   * @return reserveFactor The reserveFactor of the reserve</span>
  45 |     | <span class='neutral'>   * @return usageAsCollateralEnabled True if the usage as collateral is enabled, false otherwise</span>
  46 |     | <span class='neutral'>   * @return borrowingEnabled True if borrowing is enabled, false otherwise</span>
  47 |     | <span class='neutral'>   * @return stableBorrowRateEnabled True if stable rate borrowing is enabled, false otherwise</span>
  48 |     | <span class='neutral'>   * @return isActive True if it is active, false otherwise</span>
  49 |     | <span class='neutral'>   * @return isFrozen True if it is frozen, false otherwise</span>
  50 |     | <span class='neutral'>   */</span>
  51 |     | <span class='neutral'>  function getReserveConfigurationData(address asset)</span>
  52 |     | <span class='neutral'>    external</span>
  53 |     | <span class='neutral'>    view</span>
  54 |     | <span class='neutral'>    returns (</span>
  55 |     | <span class='neutral'>      uint256 decimals,</span>
  56 |     | <span class='neutral'>      uint256 ltv,</span>
  57 |     | <span class='neutral'>      uint256 liquidationThreshold,</span>
  58 |     | <span class='neutral'>      uint256 liquidationBonus,</span>
  59 |     | <span class='neutral'>      uint256 reserveFactor,</span>
  60 |     | <span class='neutral'>      bool usageAsCollateralEnabled,</span>
  61 |     | <span class='neutral'>      bool borrowingEnabled,</span>
  62 |     | <span class='neutral'>      bool stableBorrowRateEnabled,</span>
  63 |     | <span class='neutral'>      bool isActive,</span>
  64 |     | <span class='neutral'>      bool isFrozen</span>
  65 |     | <span class='neutral'>    );</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>  /**</span>
  68 |     | <span class='neutral'>   * @notice Returns the efficiency mode category of the reserve</span>
  69 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
  70 |     | <span class='neutral'>   * @return The eMode id of the reserve</span>
  71 |     | <span class='neutral'>   */</span>
  72 |     | <span class='neutral'>  function getReserveEModeCategory(address asset) external view returns (uint256);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>  /**</span>
  75 |     | <span class='neutral'>   * @notice Returns the caps parameters of the reserve</span>
  76 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
  77 |     | <span class='neutral'>   * @return borrowCap The borrow cap of the reserve</span>
  78 |     | <span class='neutral'>   * @return supplyCap The supply cap of the reserve</span>
  79 |     | <span class='neutral'>   */</span>
  80 |     | <span class='neutral'>  function getReserveCaps(address asset)</span>
  81 |     | <span class='neutral'>    external</span>
  82 |     | <span class='neutral'>    view</span>
  83 |     | <span class='neutral'>    returns (uint256 borrowCap, uint256 supplyCap);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>  /**</span>
  86 |     | <span class='neutral'>   * @notice Returns if the pool is paused</span>
  87 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
  88 |     | <span class='neutral'>   * @return isPaused True if the pool is paused, false otherwise</span>
  89 |     | <span class='neutral'>   */</span>
  90 |     | <span class='neutral'>  function getPaused(address asset) external view returns (bool isPaused);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>  /**</span>
  93 |     | <span class='neutral'>   * @notice Returns the siloed borrowing flag</span>
  94 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
  95 |     | <span class='neutral'>   * @return True if the asset is siloed for borrowing</span>
  96 |     | <span class='neutral'>   */</span>
  97 |     | <span class='neutral'>  function getSiloedBorrowing(address asset) external view returns (bool);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>  /**</span>
 100 |     | <span class='neutral'>   * @notice Returns the protocol fee on the liquidation bonus</span>
 101 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 102 |     | <span class='neutral'>   * @return The protocol fee on liquidation</span>
 103 |     | <span class='neutral'>   */</span>
 104 |     | <span class='neutral'>  function getLiquidationProtocolFee(address asset) external view returns (uint256);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>  /**</span>
 107 |     | <span class='neutral'>   * @notice Returns the unbacked mint cap of the reserve</span>
 108 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 109 |     | <span class='neutral'>   * @return The unbacked mint cap of the reserve</span>
 110 |     | <span class='neutral'>   */</span>
 111 |     | <span class='neutral'>  function getUnbackedMintCap(address asset) external view returns (uint256);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>  /**</span>
 114 |     | <span class='neutral'>   * @notice Returns the debt ceiling of the reserve</span>
 115 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 116 |     | <span class='neutral'>   * @return The debt ceiling of the reserve</span>
 117 |     | <span class='neutral'>   */</span>
 118 |     | <span class='neutral'>  function getDebtCeiling(address asset) external view returns (uint256);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>  /**</span>
 121 |     | <span class='neutral'>   * @notice Returns the debt ceiling decimals</span>
 122 |     | <span class='neutral'>   * @return The debt ceiling decimals</span>
 123 |     | <span class='neutral'>   */</span>
 124 |     | <span class='neutral'>  function getDebtCeilingDecimals() external pure returns (uint256);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>  /**</span>
 127 |     | <span class='neutral'>   * @notice Returns the reserve data</span>
 128 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 129 |     | <span class='neutral'>   * @return unbacked The amount of unbacked tokens</span>
 130 |     | <span class='neutral'>   * @return accruedToTreasuryScaled The scaled amount of tokens accrued to treasury that is to be minted</span>
 131 |     | <span class='neutral'>   * @return totalAToken The total supply of the aToken</span>
 132 |     | <span class='neutral'>   * @return totalStableDebt The total stable debt of the reserve</span>
 133 |     | <span class='neutral'>   * @return totalVariableDebt The total variable debt of the reserve</span>
 134 |     | <span class='neutral'>   * @return liquidityRate The liquidity rate of the reserve</span>
 135 |     | <span class='neutral'>   * @return variableBorrowRate The variable borrow rate of the reserve</span>
 136 |     | <span class='neutral'>   * @return stableBorrowRate The stable borrow rate of the reserve</span>
 137 |     | <span class='neutral'>   * @return averageStableBorrowRate The average stable borrow rate of the reserve</span>
 138 |     | <span class='neutral'>   * @return liquidityIndex The liquidity index of the reserve</span>
 139 |     | <span class='neutral'>   * @return variableBorrowIndex The variable borrow index of the reserve</span>
 140 |     | <span class='neutral'>   * @return lastUpdateTimestamp The timestamp of the last update of the reserve</span>
 141 |     | <span class='neutral'>   */</span>
 142 |     | <span class='neutral'>  function getReserveData(address asset)</span>
 143 |     | <span class='neutral'>    external</span>
 144 |     | <span class='neutral'>    view</span>
 145 |     | <span class='neutral'>    returns (</span>
 146 |     | <span class='neutral'>      uint256 unbacked,</span>
 147 |     | <span class='neutral'>      uint256 accruedToTreasuryScaled,</span>
 148 |     | <span class='neutral'>      uint256 totalAToken,</span>
 149 |     | <span class='neutral'>      uint256 totalStableDebt,</span>
 150 |     | <span class='neutral'>      uint256 totalVariableDebt,</span>
 151 |     | <span class='neutral'>      uint256 liquidityRate,</span>
 152 |     | <span class='neutral'>      uint256 variableBorrowRate,</span>
 153 |     | <span class='neutral'>      uint256 stableBorrowRate,</span>
 154 |     | <span class='neutral'>      uint256 averageStableBorrowRate,</span>
 155 |     | <span class='neutral'>      uint256 liquidityIndex,</span>
 156 |     | <span class='neutral'>      uint256 variableBorrowIndex,</span>
 157 |     | <span class='neutral'>      uint40 lastUpdateTimestamp</span>
 158 |     | <span class='neutral'>    );</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>  /**</span>
 161 |     | <span class='neutral'>   * @notice Returns the total supply of aTokens for a given asset</span>
 162 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 163 |     | <span class='neutral'>   * @return The total supply of the aToken</span>
 164 |     | <span class='neutral'>   */</span>
 165 |     | <span class='neutral'>  function getATokenTotalSupply(address asset) external view returns (uint256);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>  /**</span>
 168 |     | <span class='neutral'>   * @notice Returns the total debt for a given asset</span>
 169 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 170 |     | <span class='neutral'>   * @return The total debt for asset</span>
 171 |     | <span class='neutral'>   */</span>
 172 |     | <span class='neutral'>  function getTotalDebt(address asset) external view returns (uint256);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>  /**</span>
 175 |     | <span class='neutral'>   * @notice Returns the user data in a reserve</span>
 176 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 177 |     | <span class='neutral'>   * @param user The address of the user</span>
 178 |     | <span class='neutral'>   * @return currentATokenBalance The current AToken balance of the user</span>
 179 |     | <span class='neutral'>   * @return currentStableDebt The current stable debt of the user</span>
 180 |     | <span class='neutral'>   * @return currentVariableDebt The current variable debt of the user</span>
 181 |     | <span class='neutral'>   * @return principalStableDebt The principal stable debt of the user</span>
 182 |     | <span class='neutral'>   * @return scaledVariableDebt The scaled variable debt of the user</span>
 183 |     | <span class='neutral'>   * @return stableBorrowRate The stable borrow rate of the user</span>
 184 |     | <span class='neutral'>   * @return liquidityRate The liquidity rate of the reserve</span>
 185 |     | <span class='neutral'>   * @return stableRateLastUpdated The timestamp of the last update of the user stable rate</span>
 186 |     | <span class='neutral'>   * @return usageAsCollateralEnabled True if the user is using the asset as collateral, false</span>
 187 |     | <span class='neutral'>   *         otherwise</span>
 188 |     | <span class='neutral'>   */</span>
 189 |     | <span class='neutral'>  function getUserReserveData(address asset, address user)</span>
 190 |     | <span class='neutral'>    external</span>
 191 |     | <span class='neutral'>    view</span>
 192 |     | <span class='neutral'>    returns (</span>
 193 |     | <span class='neutral'>      uint256 currentATokenBalance,</span>
 194 |     | <span class='neutral'>      uint256 currentStableDebt,</span>
 195 |     | <span class='neutral'>      uint256 currentVariableDebt,</span>
 196 |     | <span class='neutral'>      uint256 principalStableDebt,</span>
 197 |     | <span class='neutral'>      uint256 scaledVariableDebt,</span>
 198 |     | <span class='neutral'>      uint256 stableBorrowRate,</span>
 199 |     | <span class='neutral'>      uint256 liquidityRate,</span>
 200 |     | <span class='neutral'>      uint40 stableRateLastUpdated,</span>
 201 |     | <span class='neutral'>      bool usageAsCollateralEnabled</span>
 202 |     | <span class='neutral'>    );</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>  /**</span>
 205 |     | <span class='neutral'>   * @notice Returns the token addresses of the reserve</span>
 206 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 207 |     | <span class='neutral'>   * @return aTokenAddress The AToken address of the reserve</span>
 208 |     | <span class='neutral'>   * @return stableDebtTokenAddress The StableDebtToken address of the reserve</span>
 209 |     | <span class='neutral'>   * @return variableDebtTokenAddress The VariableDebtToken address of the reserve</span>
 210 |     | <span class='neutral'>   */</span>
 211 |     | <span class='neutral'>  function getReserveTokensAddresses(address asset)</span>
 212 |     | <span class='neutral'>    external</span>
 213 |     | <span class='neutral'>    view</span>
 214 |     | <span class='neutral'>    returns (</span>
 215 |     | <span class='neutral'>      address aTokenAddress,</span>
 216 |     | <span class='neutral'>      address stableDebtTokenAddress,</span>
 217 |     | <span class='neutral'>      address variableDebtTokenAddress</span>
 218 |     | <span class='neutral'>    );</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>  /**</span>
 221 |     | <span class='neutral'>   * @notice Returns the address of the Interest Rate strategy</span>
 222 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 223 |     | <span class='neutral'>   * @return irStrategyAddress The address of the Interest Rate strategy</span>
 224 |     | <span class='neutral'>   */</span>
 225 |     | <span class='neutral'>  function getInterestRateStrategyAddress(address asset)</span>
 226 |     | <span class='neutral'>    external</span>
 227 |     | <span class='neutral'>    view</span>
 228 |     | <span class='neutral'>    returns (address irStrategyAddress);</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>  /**</span>
 231 |     | <span class='neutral'>   * @notice Returns whether the reserve has FlashLoans enabled or disabled</span>
 232 |     | <span class='neutral'>   * @param asset The address of the underlying asset of the reserve</span>
 233 |     | <span class='neutral'>   * @return True if FlashLoans are enabled, false otherwise</span>
 234 |     | <span class='neutral'>   */</span>
 235 |     | <span class='neutral'>  function getFlashLoanEnabled(address asset) external view returns (bool);</span>
 236 |     | <span class='neutral'>}</span>
 237 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IScaledBalanceToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title IScaledBalanceToken</span>
  6 |     | <span class='neutral'> * @author Aave</span>
  7 |     | <span class='neutral'> * @notice Defines the basic interface for a scaled-balance token.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IScaledBalanceToken {</span>
 10 |     | <span class='neutral'>  /**</span>
 11 |     | <span class='neutral'>   * @dev Emitted after the mint action</span>
 12 |     | <span class='neutral'>   * @param caller The address performing the mint</span>
 13 |     | <span class='neutral'>   * @param onBehalfOf The address of the user that will receive the minted tokens</span>
 14 |     | <span class='neutral'>   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)</span>
 15 |     | <span class='neutral'>   * @param balanceIncrease The increase in scaled-up balance since the last action of &#39;onBehalfOf&#39;</span>
 16 |     | <span class='neutral'>   * @param index The next liquidity index of the reserve</span>
 17 |     | <span class='neutral'>   */</span>
 18 |     | <span class='neutral'>  event Mint(</span>
 19 |     | <span class='neutral'>    address indexed caller,</span>
 20 |     | <span class='neutral'>    address indexed onBehalfOf,</span>
 21 |     | <span class='neutral'>    uint256 value,</span>
 22 |     | <span class='neutral'>    uint256 balanceIncrease,</span>
 23 |     | <span class='neutral'>    uint256 index</span>
 24 |     | <span class='neutral'>  );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>  /**</span>
 27 |     | <span class='neutral'>   * @dev Emitted after the burn action</span>
 28 |     | <span class='neutral'>   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address</span>
 29 |     | <span class='neutral'>   * @param from The address from which the tokens will be burned</span>
 30 |     | <span class='neutral'>   * @param target The address that will receive the underlying, if any</span>
 31 |     | <span class='neutral'>   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)</span>
 32 |     | <span class='neutral'>   * @param balanceIncrease The increase in scaled-up balance since the last action of &#39;from&#39;</span>
 33 |     | <span class='neutral'>   * @param index The next liquidity index of the reserve</span>
 34 |     | <span class='neutral'>   */</span>
 35 |     | <span class='neutral'>  event Burn(</span>
 36 |     | <span class='neutral'>    address indexed from,</span>
 37 |     | <span class='neutral'>    address indexed target,</span>
 38 |     | <span class='neutral'>    uint256 value,</span>
 39 |     | <span class='neutral'>    uint256 balanceIncrease,</span>
 40 |     | <span class='neutral'>    uint256 index</span>
 41 |     | <span class='neutral'>  );</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>  /**</span>
 44 |     | <span class='neutral'>   * @notice Returns the scaled balance of the user.</span>
 45 |     | <span class='neutral'>   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve&#39;s liquidity index</span>
 46 |     | <span class='neutral'>   * at the moment of the update</span>
 47 |     | <span class='neutral'>   * @param user The user whose balance is calculated</span>
 48 |     | <span class='neutral'>   * @return The scaled balance of the user</span>
 49 |     | <span class='neutral'>   */</span>
 50 |     | <span class='neutral'>  function scaledBalanceOf(address user) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>  /**</span>
 53 |     | <span class='neutral'>   * @notice Returns the scaled balance of the user and the scaled total supply.</span>
 54 |     | <span class='neutral'>   * @param user The address of the user</span>
 55 |     | <span class='neutral'>   * @return The scaled balance of the user</span>
 56 |     | <span class='neutral'>   * @return The scaled total supply</span>
 57 |     | <span class='neutral'>   */</span>
 58 |     | <span class='neutral'>  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>  /**</span>
 61 |     | <span class='neutral'>   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)</span>
 62 |     | <span class='neutral'>   * @return The scaled total supply</span>
 63 |     | <span class='neutral'>   */</span>
 64 |     | <span class='neutral'>  function scaledTotalSupply() external view returns (uint256);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>  /**</span>
 67 |     | <span class='neutral'>   * @notice Returns last index interest was accrued to the user&#39;s balance</span>
 68 |     | <span class='neutral'>   * @param user The address of the user</span>
 69 |     | <span class='neutral'>   * @return The last index interest was accrued to the user&#39;s balance, expressed in ray</span>
 70 |     | <span class='neutral'>   */</span>
 71 |     | <span class='neutral'>  function getPreviousIndex(address user) external view returns (uint256);</span>
 72 |     | <span class='neutral'>}</span>
 73 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/interfaces/IVariableDebtToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IScaledBalanceToken} from &#39;./IScaledBalanceToken.sol&#39;;</span>
  5 |     | <span class='neutral'>import {IInitializableDebtToken} from &#39;./IInitializableDebtToken.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @title IVariableDebtToken</span>
  9 |     | <span class='neutral'> * @author Aave</span>
 10 |     | <span class='neutral'> * @notice Defines the basic interface for a variable debt token.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {</span>
 13 |     | <span class='neutral'>  /**</span>
 14 |     | <span class='neutral'>   * @notice Mints debt token to the `onBehalfOf` address</span>
 15 |     | <span class='neutral'>   * @param user The address receiving the borrowed underlying, being the delegatee in case</span>
 16 |     | <span class='neutral'>   * of credit delegate, or same as `onBehalfOf` otherwise</span>
 17 |     | <span class='neutral'>   * @param onBehalfOf The address receiving the debt tokens</span>
 18 |     | <span class='neutral'>   * @param amount The amount of debt being minted</span>
 19 |     | <span class='neutral'>   * @param index The variable debt index of the reserve</span>
 20 |     | <span class='neutral'>   * @return True if the previous balance of the user is 0, false otherwise</span>
 21 |     | <span class='neutral'>   * @return The scaled total debt of the reserve</span>
 22 |     | <span class='neutral'>   */</span>
 23 |     | <span class='neutral'>  function mint(</span>
 24 |     | <span class='neutral'>    address user,</span>
 25 |     | <span class='neutral'>    address onBehalfOf,</span>
 26 |     | <span class='neutral'>    uint256 amount,</span>
 27 |     | <span class='neutral'>    uint256 index</span>
 28 |     | <span class='neutral'>  ) external returns (bool, uint256);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>  /**</span>
 31 |     | <span class='neutral'>   * @notice Burns user variable debt</span>
 32 |     | <span class='neutral'>   * @dev In some instances, a burn transaction will emit a mint event</span>
 33 |     | <span class='neutral'>   * if the amount to burn is less than the interest that the user accrued</span>
 34 |     | <span class='neutral'>   * @param from The address from which the debt will be burned</span>
 35 |     | <span class='neutral'>   * @param amount The amount getting burned</span>
 36 |     | <span class='neutral'>   * @param index The variable debt index of the reserve</span>
 37 |     | <span class='neutral'>   * @return The scaled total debt of the reserve</span>
 38 |     | <span class='neutral'>   */</span>
 39 |     | <span class='neutral'>  function burn(</span>
 40 |     | <span class='neutral'>    address from,</span>
 41 |     | <span class='neutral'>    uint256 amount,</span>
 42 |     | <span class='neutral'>    uint256 index</span>
 43 |     | <span class='neutral'>  ) external returns (uint256);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>  /**</span>
 46 |     | <span class='neutral'>   * @notice Returns the address of the underlying asset of this debtToken (E.g. WETH for variableDebtWETH)</span>
 47 |     | <span class='neutral'>   * @return The address of the underlying asset</span>
 48 |     | <span class='neutral'>   */</span>
 49 |     | <span class='neutral'>  function UNDERLYING_ASSET_ADDRESS() external view returns (address);</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/protocol/libraries/helpers/Errors.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title Errors library</span>
   6 |     | <span class='neutral'> * @author Aave</span>
   7 |     | <span class='neutral'> * @notice Defines the error messages emitted by the different contracts of the Aave protocol</span>
   8 |     | <span class='unexecuted'> */</span>
   9 |     | <span class='neutral'>library Errors {</span>
  10 |     | <span class='unexecuted'>  string public constant CALLER_NOT_POOL_ADMIN = &#39;1&#39;; // &#39;The caller of the function is not a pool admin&#39;</span>
  11 |     | <span class='unexecuted'>  string public constant CALLER_NOT_EMERGENCY_ADMIN = &#39;2&#39;; // &#39;The caller of the function is not an emergency admin&#39;</span>
  12 |     | <span class='unexecuted'>  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = &#39;3&#39;; // &#39;The caller of the function is not a pool or emergency admin&#39;</span>
  13 |     | <span class='unexecuted'>  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = &#39;4&#39;; // &#39;The caller of the function is not a risk or pool admin&#39;</span>
  14 |     | <span class='unexecuted'>  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = &#39;5&#39;; // &#39;The caller of the function is not an asset listing or pool admin&#39;</span>
  15 |     | <span class='unexecuted'>  string public constant CALLER_NOT_BRIDGE = &#39;6&#39;; // &#39;The caller of the function is not a bridge&#39;</span>
  16 |     | <span class='unexecuted'>  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = &#39;7&#39;; // &#39;Pool addresses provider is not registered&#39;</span>
  17 |     | <span class='unexecuted'>  string public constant INVALID_ADDRESSES_PROVIDER_ID = &#39;8&#39;; // &#39;Invalid id for the pool addresses provider&#39;</span>
  18 |     | <span class='unexecuted'>  string public constant NOT_CONTRACT = &#39;9&#39;; // &#39;Address is not a contract&#39;</span>
  19 |     | <span class='unexecuted'>  string public constant CALLER_NOT_POOL_CONFIGURATOR = &#39;10&#39;; // &#39;The caller of the function is not the pool configurator&#39;</span>
  20 |     | <span class='unexecuted'>  string public constant CALLER_NOT_ATOKEN = &#39;11&#39;; // &#39;The caller of the function is not an AToken&#39;</span>
  21 |     | <span class='unexecuted'>  string public constant INVALID_ADDRESSES_PROVIDER = &#39;12&#39;; // &#39;The address of the pool addresses provider is invalid&#39;</span>
  22 |     | <span class='unexecuted'>  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = &#39;13&#39;; // &#39;Invalid return value of the flashloan executor function&#39;</span>
  23 |     | <span class='unexecuted'>  string public constant RESERVE_ALREADY_ADDED = &#39;14&#39;; // &#39;Reserve has already been added to reserve list&#39;</span>
  24 |     | <span class='unexecuted'>  string public constant NO_MORE_RESERVES_ALLOWED = &#39;15&#39;; // &#39;Maximum amount of reserves in the pool reached&#39;</span>
  25 |     | <span class='unexecuted'>  string public constant EMODE_CATEGORY_RESERVED = &#39;16&#39;; // &#39;Zero eMode category is reserved for volatile heterogeneous assets&#39;</span>
  26 |     | <span class='unexecuted'>  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = &#39;17&#39;; // &#39;Invalid eMode category assignment to asset&#39;</span>
  27 |     | <span class='unexecuted'>  string public constant RESERVE_LIQUIDITY_NOT_ZERO = &#39;18&#39;; // &#39;The liquidity of the reserve needs to be 0&#39;</span>
  28 |     | <span class='unexecuted'>  string public constant FLASHLOAN_PREMIUM_INVALID = &#39;19&#39;; // &#39;Invalid flashloan premium&#39;</span>
  29 |     | <span class='unexecuted'>  string public constant INVALID_RESERVE_PARAMS = &#39;20&#39;; // &#39;Invalid risk parameters for the reserve&#39;</span>
  30 |     | <span class='unexecuted'>  string public constant INVALID_EMODE_CATEGORY_PARAMS = &#39;21&#39;; // &#39;Invalid risk parameters for the eMode category&#39;</span>
  31 |     | <span class='unexecuted'>  string public constant BRIDGE_PROTOCOL_FEE_INVALID = &#39;22&#39;; // &#39;Invalid bridge protocol fee&#39;</span>
  32 |     | <span class='unexecuted'>  string public constant CALLER_MUST_BE_POOL = &#39;23&#39;; // &#39;The caller of this function must be a pool&#39;</span>
  33 |     | <span class='unexecuted'>  string public constant INVALID_MINT_AMOUNT = &#39;24&#39;; // &#39;Invalid amount to mint&#39;</span>
  34 |     | <span class='unexecuted'>  string public constant INVALID_BURN_AMOUNT = &#39;25&#39;; // &#39;Invalid amount to burn&#39;</span>
  35 |     | <span class='unexecuted'>  string public constant INVALID_AMOUNT = &#39;26&#39;; // &#39;Amount must be greater than 0&#39;</span>
  36 |     | <span class='unexecuted'>  string public constant RESERVE_INACTIVE = &#39;27&#39;; // &#39;Action requires an active reserve&#39;</span>
  37 |     | <span class='unexecuted'>  string public constant RESERVE_FROZEN = &#39;28&#39;; // &#39;Action cannot be performed because the reserve is frozen&#39;</span>
  38 |     | <span class='unexecuted'>  string public constant RESERVE_PAUSED = &#39;29&#39;; // &#39;Action cannot be performed because the reserve is paused&#39;</span>
  39 |     | <span class='unexecuted'>  string public constant BORROWING_NOT_ENABLED = &#39;30&#39;; // &#39;Borrowing is not enabled&#39;</span>
  40 |     | <span class='unexecuted'>  string public constant STABLE_BORROWING_NOT_ENABLED = &#39;31&#39;; // &#39;Stable borrowing is not enabled&#39;</span>
  41 |     | <span class='unexecuted'>  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = &#39;32&#39;; // &#39;User cannot withdraw more than the available balance&#39;</span>
  42 |     | <span class='unexecuted'>  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = &#39;33&#39;; // &#39;Invalid interest rate mode selected&#39;</span>
  43 |     | <span class='unexecuted'>  string public constant COLLATERAL_BALANCE_IS_ZERO = &#39;34&#39;; // &#39;The collateral balance is 0&#39;</span>
  44 |     | <span class='unexecuted'>  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = &#39;35&#39;; // &#39;Health factor is lesser than the liquidation threshold&#39;</span>
  45 |     | <span class='unexecuted'>  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = &#39;36&#39;; // &#39;There is not enough collateral to cover a new borrow&#39;</span>
  46 |     | <span class='unexecuted'>  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = &#39;37&#39;; // &#39;Collateral is (mostly) the same currency that is being borrowed&#39;</span>
  47 |     | <span class='unexecuted'>  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = &#39;38&#39;; // &#39;The requested amount is greater than the max loan size in stable rate mode&#39;</span>
  48 |     | <span class='unexecuted'>  string public constant NO_DEBT_OF_SELECTED_TYPE = &#39;39&#39;; // &#39;For repayment of a specific type of debt, the user needs to have debt that type&#39;</span>
  49 |     | <span class='unexecuted'>  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = &#39;40&#39;; // &#39;To repay on behalf of a user an explicit amount to repay is needed&#39;</span>
  50 |     | <span class='unexecuted'>  string public constant NO_OUTSTANDING_STABLE_DEBT = &#39;41&#39;; // &#39;User does not have outstanding stable rate debt on this reserve&#39;</span>
  51 |     | <span class='unexecuted'>  string public constant NO_OUTSTANDING_VARIABLE_DEBT = &#39;42&#39;; // &#39;User does not have outstanding variable rate debt on this reserve&#39;</span>
  52 |     | <span class='unexecuted'>  string public constant UNDERLYING_BALANCE_ZERO = &#39;43&#39;; // &#39;The underlying balance needs to be greater than 0&#39;</span>
  53 |     | <span class='unexecuted'>  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = &#39;44&#39;; // &#39;Interest rate rebalance conditions were not met&#39;</span>
  54 |     | <span class='unexecuted'>  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = &#39;45&#39;; // &#39;Health factor is not below the threshold&#39;</span>
  55 |     | <span class='unexecuted'>  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = &#39;46&#39;; // &#39;The collateral chosen cannot be liquidated&#39;</span>
  56 |     | <span class='unexecuted'>  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = &#39;47&#39;; // &#39;User did not borrow the specified currency&#39;</span>
  57 |     | <span class='unexecuted'>  string public constant INCONSISTENT_FLASHLOAN_PARAMS = &#39;49&#39;; // &#39;Inconsistent flashloan parameters&#39;</span>
  58 |     | <span class='unexecuted'>  string public constant BORROW_CAP_EXCEEDED = &#39;50&#39;; // &#39;Borrow cap is exceeded&#39;</span>
  59 |     | <span class='unexecuted'>  string public constant SUPPLY_CAP_EXCEEDED = &#39;51&#39;; // &#39;Supply cap is exceeded&#39;</span>
  60 |     | <span class='unexecuted'>  string public constant UNBACKED_MINT_CAP_EXCEEDED = &#39;52&#39;; // &#39;Unbacked mint cap is exceeded&#39;</span>
  61 |     | <span class='unexecuted'>  string public constant DEBT_CEILING_EXCEEDED = &#39;53&#39;; // &#39;Debt ceiling is exceeded&#39;</span>
  62 |     | <span class='unexecuted'>  string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = &#39;54&#39;; // &#39;Claimable rights over underlying not zero (aToken supply or accruedToTreasury)&#39;</span>
  63 |     | <span class='unexecuted'>  string public constant STABLE_DEBT_NOT_ZERO = &#39;55&#39;; // &#39;Stable debt supply is not zero&#39;</span>
  64 |     | <span class='unexecuted'>  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = &#39;56&#39;; // &#39;Variable debt supply is not zero&#39;</span>
  65 |     | <span class='unexecuted'>  string public constant LTV_VALIDATION_FAILED = &#39;57&#39;; // &#39;Ltv validation failed&#39;</span>
  66 |     | <span class='unexecuted'>  string public constant INCONSISTENT_EMODE_CATEGORY = &#39;58&#39;; // &#39;Inconsistent eMode category&#39;</span>
  67 |     | <span class='unexecuted'>  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = &#39;59&#39;; // &#39;Price oracle sentinel validation failed&#39;</span>
  68 |     | <span class='unexecuted'>  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = &#39;60&#39;; // &#39;Asset is not borrowable in isolation mode&#39;</span>
  69 |     | <span class='unexecuted'>  string public constant RESERVE_ALREADY_INITIALIZED = &#39;61&#39;; // &#39;Reserve has already been initialized&#39;</span>
  70 |     | <span class='unexecuted'>  string public constant USER_IN_ISOLATION_MODE = &#39;62&#39;; // &#39;User is in isolation mode&#39;</span>
  71 |     | <span class='unexecuted'>  string public constant INVALID_LTV = &#39;63&#39;; // &#39;Invalid ltv parameter for the reserve&#39;</span>
  72 |     | <span class='unexecuted'>  string public constant INVALID_LIQ_THRESHOLD = &#39;64&#39;; // &#39;Invalid liquidity threshold parameter for the reserve&#39;</span>
  73 |     | <span class='unexecuted'>  string public constant INVALID_LIQ_BONUS = &#39;65&#39;; // &#39;Invalid liquidity bonus parameter for the reserve&#39;</span>
  74 |     | <span class='unexecuted'>  string public constant INVALID_DECIMALS = &#39;66&#39;; // &#39;Invalid decimals parameter of the underlying asset of the reserve&#39;</span>
  75 |     | <span class='unexecuted'>  string public constant INVALID_RESERVE_FACTOR = &#39;67&#39;; // &#39;Invalid reserve factor parameter for the reserve&#39;</span>
  76 |     | <span class='unexecuted'>  string public constant INVALID_BORROW_CAP = &#39;68&#39;; // &#39;Invalid borrow cap for the reserve&#39;</span>
  77 |     | <span class='unexecuted'>  string public constant INVALID_SUPPLY_CAP = &#39;69&#39;; // &#39;Invalid supply cap for the reserve&#39;</span>
  78 |     | <span class='unexecuted'>  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = &#39;70&#39;; // &#39;Invalid liquidation protocol fee for the reserve&#39;</span>
  79 |     | <span class='unexecuted'>  string public constant INVALID_EMODE_CATEGORY = &#39;71&#39;; // &#39;Invalid eMode category for the reserve&#39;</span>
  80 |     | <span class='unexecuted'>  string public constant INVALID_UNBACKED_MINT_CAP = &#39;72&#39;; // &#39;Invalid unbacked mint cap for the reserve&#39;</span>
  81 |     | <span class='unexecuted'>  string public constant INVALID_DEBT_CEILING = &#39;73&#39;; // &#39;Invalid debt ceiling for the reserve</span>
  82 |     | <span class='unexecuted'>  string public constant INVALID_RESERVE_INDEX = &#39;74&#39;; // &#39;Invalid reserve index&#39;</span>
  83 |     | <span class='unexecuted'>  string public constant ACL_ADMIN_CANNOT_BE_ZERO = &#39;75&#39;; // &#39;ACL admin cannot be set to the zero address&#39;</span>
  84 |     | <span class='unexecuted'>  string public constant INCONSISTENT_PARAMS_LENGTH = &#39;76&#39;; // &#39;Array parameters that should be equal length are not&#39;</span>
  85 |     | <span class='unexecuted'>  string public constant ZERO_ADDRESS_NOT_VALID = &#39;77&#39;; // &#39;Zero address not valid&#39;</span>
  86 |     | <span class='unexecuted'>  string public constant INVALID_EXPIRATION = &#39;78&#39;; // &#39;Invalid expiration&#39;</span>
  87 |     | <span class='unexecuted'>  string public constant INVALID_SIGNATURE = &#39;79&#39;; // &#39;Invalid signature&#39;</span>
  88 |     | <span class='unexecuted'>  string public constant OPERATION_NOT_SUPPORTED = &#39;80&#39;; // &#39;Operation not supported&#39;</span>
  89 |     | <span class='unexecuted'>  string public constant DEBT_CEILING_NOT_ZERO = &#39;81&#39;; // &#39;Debt ceiling is not zero&#39;</span>
  90 |     | <span class='unexecuted'>  string public constant ASSET_NOT_LISTED = &#39;82&#39;; // &#39;Asset is not listed&#39;</span>
  91 |     | <span class='unexecuted'>  string public constant INVALID_OPTIMAL_USAGE_RATIO = &#39;83&#39;; // &#39;Invalid optimal usage ratio&#39;</span>
  92 |     | <span class='unexecuted'>  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = &#39;84&#39;; // &#39;Invalid optimal stable to total debt ratio&#39;</span>
  93 |     | <span class='unexecuted'>  string public constant UNDERLYING_CANNOT_BE_RESCUED = &#39;85&#39;; // &#39;The underlying asset cannot be rescued&#39;</span>
  94 |     | <span class='unexecuted'>  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = &#39;86&#39;; // &#39;Reserve has already been added to reserve list&#39;</span>
  95 |     | <span class='unexecuted'>  string public constant POOL_ADDRESSES_DO_NOT_MATCH = &#39;87&#39;; // &#39;The token implementation pool address and the pool address provided by the initializing pool do not match&#39;</span>
  96 |     | <span class='unexecuted'>  string public constant STABLE_BORROWING_ENABLED = &#39;88&#39;; // &#39;Stable borrowing is enabled&#39;</span>
  97 |     | <span class='unexecuted'>  string public constant SILOED_BORROWING_VIOLATION = &#39;89&#39;; // &#39;User is trying to borrow multiple assets including a siloed one&#39;</span>
  98 |     | <span class='unexecuted'>  string public constant RESERVE_DEBT_NOT_ZERO = &#39;90&#39;; // the total debt of the reserve needs to be 0</span>
  99 |     | <span class='unexecuted'>  string public constant FLASHLOAN_DISABLED = &#39;91&#39;; // FlashLoaning for this asset is disabled</span>
 100 |     | <span class='neutral'>}</span>
 101 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/aave-v3-core/contracts/protocol/libraries/types/DataTypes.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='unexecuted'></span>
   4 |     | <span class='neutral'>library DataTypes {</span>
   5 |     | <span class='neutral'>  struct ReserveData {</span>
   6 |     | <span class='neutral'>    //stores the reserve configuration</span>
   7 |     | <span class='neutral'>    ReserveConfigurationMap configuration;</span>
   8 |     | <span class='neutral'>    //the liquidity index. Expressed in ray</span>
   9 |     | <span class='neutral'>    uint128 liquidityIndex;</span>
  10 |     | <span class='neutral'>    //the current supply rate. Expressed in ray</span>
  11 |     | <span class='neutral'>    uint128 currentLiquidityRate;</span>
  12 |     | <span class='neutral'>    //variable borrow index. Expressed in ray</span>
  13 |     | <span class='neutral'>    uint128 variableBorrowIndex;</span>
  14 |     | <span class='neutral'>    //the current variable borrow rate. Expressed in ray</span>
  15 |     | <span class='neutral'>    uint128 currentVariableBorrowRate;</span>
  16 |     | <span class='neutral'>    //the current stable borrow rate. Expressed in ray</span>
  17 |     | <span class='neutral'>    uint128 currentStableBorrowRate;</span>
  18 |     | <span class='neutral'>    //timestamp of last update</span>
  19 |     | <span class='neutral'>    uint40 lastUpdateTimestamp;</span>
  20 |     | <span class='neutral'>    //the id of the reserve. Represents the position in the list of the active reserves</span>
  21 |     | <span class='neutral'>    uint16 id;</span>
  22 |     | <span class='neutral'>    //aToken address</span>
  23 |     | <span class='neutral'>    address aTokenAddress;</span>
  24 |     | <span class='neutral'>    //stableDebtToken address</span>
  25 |     | <span class='neutral'>    address stableDebtTokenAddress;</span>
  26 |     | <span class='neutral'>    //variableDebtToken address</span>
  27 |     | <span class='neutral'>    address variableDebtTokenAddress;</span>
  28 |     | <span class='neutral'>    //address of the interest rate strategy</span>
  29 |     | <span class='neutral'>    address interestRateStrategyAddress;</span>
  30 |     | <span class='neutral'>    //the current treasury balance, scaled</span>
  31 |     | <span class='neutral'>    uint128 accruedToTreasury;</span>
  32 |     | <span class='neutral'>    //the outstanding unbacked aTokens minted through the bridging feature</span>
  33 |     | <span class='neutral'>    uint128 unbacked;</span>
  34 |     | <span class='neutral'>    //the outstanding debt borrowed against this asset in isolation mode</span>
  35 |     | <span class='neutral'>    uint128 isolationModeTotalDebt;</span>
  36 |     | <span class='neutral'>  }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>  struct ReserveConfigurationMap {</span>
  39 |     | <span class='neutral'>    //bit 0-15: LTV</span>
  40 |     | <span class='neutral'>    //bit 16-31: Liq. threshold</span>
  41 |     | <span class='neutral'>    //bit 32-47: Liq. bonus</span>
  42 |     | <span class='neutral'>    //bit 48-55: Decimals</span>
  43 |     | <span class='neutral'>    //bit 56: reserve is active</span>
  44 |     | <span class='neutral'>    //bit 57: reserve is frozen</span>
  45 |     | <span class='neutral'>    //bit 58: borrowing is enabled</span>
  46 |     | <span class='neutral'>    //bit 59: stable rate borrowing enabled</span>
  47 |     | <span class='neutral'>    //bit 60: asset is paused</span>
  48 |     | <span class='neutral'>    //bit 61: borrowing in isolation mode is enabled</span>
  49 |     | <span class='neutral'>    //bit 62-63: reserved</span>
  50 |     | <span class='neutral'>    //bit 64-79: reserve factor</span>
  51 |     | <span class='neutral'>    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 =&gt; no cap</span>
  52 |     | <span class='neutral'>    //bit 116-151 supply cap in whole tokens, supplyCap == 0 =&gt; no cap</span>
  53 |     | <span class='neutral'>    //bit 152-167 liquidation protocol fee</span>
  54 |     | <span class='neutral'>    //bit 168-175 eMode category</span>
  55 |     | <span class='neutral'>    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 =&gt; minting disabled</span>
  56 |     | <span class='neutral'>    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals</span>
  57 |     | <span class='neutral'>    //bit 252-255 unused</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    uint256 data;</span>
  60 |     | <span class='neutral'>  }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>  struct UserConfigurationMap {</span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.</span>
  65 |     | <span class='neutral'>     * The first bit indicates if an asset is used as collateral by the user, the second whether an</span>
  66 |     | <span class='neutral'>     * asset is borrowed by the user.</span>
  67 |     | <span class='neutral'>     */</span>
  68 |     | <span class='neutral'>    uint256 data;</span>
  69 |     | <span class='neutral'>  }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>  struct EModeCategory {</span>
  72 |     | <span class='neutral'>    // each eMode category has a custom ltv and liquidation threshold</span>
  73 |     | <span class='neutral'>    uint16 ltv;</span>
  74 |     | <span class='neutral'>    uint16 liquidationThreshold;</span>
  75 |     | <span class='neutral'>    uint16 liquidationBonus;</span>
  76 |     | <span class='neutral'>    // each eMode category may or may not have a custom oracle to override the individual assets price oracles</span>
  77 |     | <span class='neutral'>    address priceSource;</span>
  78 |     | <span class='neutral'>    string label;</span>
  79 |     | <span class='neutral'>  }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>  enum InterestRateMode {</span>
  82 |     | <span class='neutral'>    NONE,</span>
  83 |     | <span class='neutral'>    STABLE,</span>
  84 |     | <span class='neutral'>    VARIABLE</span>
  85 |     | <span class='neutral'>  }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>  struct ReserveCache {</span>
  88 |     | <span class='neutral'>    uint256 currScaledVariableDebt;</span>
  89 |     | <span class='neutral'>    uint256 nextScaledVariableDebt;</span>
  90 |     | <span class='neutral'>    uint256 currPrincipalStableDebt;</span>
  91 |     | <span class='neutral'>    uint256 currAvgStableBorrowRate;</span>
  92 |     | <span class='neutral'>    uint256 currTotalStableDebt;</span>
  93 |     | <span class='neutral'>    uint256 nextAvgStableBorrowRate;</span>
  94 |     | <span class='neutral'>    uint256 nextTotalStableDebt;</span>
  95 |     | <span class='neutral'>    uint256 currLiquidityIndex;</span>
  96 |     | <span class='neutral'>    uint256 nextLiquidityIndex;</span>
  97 |     | <span class='neutral'>    uint256 currVariableBorrowIndex;</span>
  98 |     | <span class='neutral'>    uint256 nextVariableBorrowIndex;</span>
  99 |     | <span class='neutral'>    uint256 currLiquidityRate;</span>
 100 |     | <span class='neutral'>    uint256 currVariableBorrowRate;</span>
 101 |     | <span class='neutral'>    uint256 reserveFactor;</span>
 102 |     | <span class='neutral'>    ReserveConfigurationMap reserveConfiguration;</span>
 103 |     | <span class='neutral'>    address aTokenAddress;</span>
 104 |     | <span class='neutral'>    address stableDebtTokenAddress;</span>
 105 |     | <span class='neutral'>    address variableDebtTokenAddress;</span>
 106 |     | <span class='neutral'>    uint40 reserveLastUpdateTimestamp;</span>
 107 |     | <span class='neutral'>    uint40 stableDebtLastUpdateTimestamp;</span>
 108 |     | <span class='neutral'>  }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>  struct ExecuteLiquidationCallParams {</span>
 111 |     | <span class='neutral'>    uint256 reservesCount;</span>
 112 |     | <span class='neutral'>    uint256 debtToCover;</span>
 113 |     | <span class='neutral'>    address collateralAsset;</span>
 114 |     | <span class='neutral'>    address debtAsset;</span>
 115 |     | <span class='neutral'>    address user;</span>
 116 |     | <span class='neutral'>    bool receiveAToken;</span>
 117 |     | <span class='neutral'>    address priceOracle;</span>
 118 |     | <span class='neutral'>    uint8 userEModeCategory;</span>
 119 |     | <span class='neutral'>    address priceOracleSentinel;</span>
 120 |     | <span class='neutral'>  }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>  struct ExecuteSupplyParams {</span>
 123 |     | <span class='neutral'>    address asset;</span>
 124 |     | <span class='neutral'>    uint256 amount;</span>
 125 |     | <span class='neutral'>    address onBehalfOf;</span>
 126 |     | <span class='neutral'>    uint16 referralCode;</span>
 127 |     | <span class='neutral'>  }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>  struct ExecuteBorrowParams {</span>
 130 |     | <span class='neutral'>    address asset;</span>
 131 |     | <span class='neutral'>    address user;</span>
 132 |     | <span class='neutral'>    address onBehalfOf;</span>
 133 |     | <span class='neutral'>    uint256 amount;</span>
 134 |     | <span class='neutral'>    InterestRateMode interestRateMode;</span>
 135 |     | <span class='neutral'>    uint16 referralCode;</span>
 136 |     | <span class='neutral'>    bool releaseUnderlying;</span>
 137 |     | <span class='neutral'>    uint256 maxStableRateBorrowSizePercent;</span>
 138 |     | <span class='neutral'>    uint256 reservesCount;</span>
 139 |     | <span class='neutral'>    address oracle;</span>
 140 |     | <span class='neutral'>    uint8 userEModeCategory;</span>
 141 |     | <span class='neutral'>    address priceOracleSentinel;</span>
 142 |     | <span class='neutral'>  }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>  struct ExecuteRepayParams {</span>
 145 |     | <span class='neutral'>    address asset;</span>
 146 |     | <span class='neutral'>    uint256 amount;</span>
 147 |     | <span class='neutral'>    InterestRateMode interestRateMode;</span>
 148 |     | <span class='neutral'>    address onBehalfOf;</span>
 149 |     | <span class='neutral'>    bool useATokens;</span>
 150 |     | <span class='neutral'>  }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>  struct ExecuteWithdrawParams {</span>
 153 |     | <span class='neutral'>    address asset;</span>
 154 |     | <span class='neutral'>    uint256 amount;</span>
 155 |     | <span class='neutral'>    address to;</span>
 156 |     | <span class='neutral'>    uint256 reservesCount;</span>
 157 |     | <span class='neutral'>    address oracle;</span>
 158 |     | <span class='neutral'>    uint8 userEModeCategory;</span>
 159 |     | <span class='neutral'>  }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>  struct ExecuteSetUserEModeParams {</span>
 162 |     | <span class='neutral'>    uint256 reservesCount;</span>
 163 |     | <span class='neutral'>    address oracle;</span>
 164 |     | <span class='neutral'>    uint8 categoryId;</span>
 165 |     | <span class='neutral'>  }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>  struct FinalizeTransferParams {</span>
 168 |     | <span class='neutral'>    address asset;</span>
 169 |     | <span class='neutral'>    address from;</span>
 170 |     | <span class='neutral'>    address to;</span>
 171 |     | <span class='neutral'>    uint256 amount;</span>
 172 |     | <span class='neutral'>    uint256 balanceFromBefore;</span>
 173 |     | <span class='neutral'>    uint256 balanceToBefore;</span>
 174 |     | <span class='neutral'>    uint256 reservesCount;</span>
 175 |     | <span class='neutral'>    address oracle;</span>
 176 |     | <span class='neutral'>    uint8 fromEModeCategory;</span>
 177 |     | <span class='neutral'>  }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>  struct FlashloanParams {</span>
 180 |     | <span class='neutral'>    address receiverAddress;</span>
 181 |     | <span class='neutral'>    address[] assets;</span>
 182 |     | <span class='neutral'>    uint256[] amounts;</span>
 183 |     | <span class='neutral'>    uint256[] interestRateModes;</span>
 184 |     | <span class='neutral'>    address onBehalfOf;</span>
 185 |     | <span class='neutral'>    bytes params;</span>
 186 |     | <span class='neutral'>    uint16 referralCode;</span>
 187 |     | <span class='neutral'>    uint256 flashLoanPremiumToProtocol;</span>
 188 |     | <span class='neutral'>    uint256 flashLoanPremiumTotal;</span>
 189 |     | <span class='neutral'>    uint256 maxStableRateBorrowSizePercent;</span>
 190 |     | <span class='neutral'>    uint256 reservesCount;</span>
 191 |     | <span class='neutral'>    address addressesProvider;</span>
 192 |     | <span class='neutral'>    uint8 userEModeCategory;</span>
 193 |     | <span class='neutral'>    bool isAuthorizedFlashBorrower;</span>
 194 |     | <span class='neutral'>  }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>  struct FlashloanSimpleParams {</span>
 197 |     | <span class='neutral'>    address receiverAddress;</span>
 198 |     | <span class='neutral'>    address asset;</span>
 199 |     | <span class='neutral'>    uint256 amount;</span>
 200 |     | <span class='neutral'>    bytes params;</span>
 201 |     | <span class='neutral'>    uint16 referralCode;</span>
 202 |     | <span class='neutral'>    uint256 flashLoanPremiumToProtocol;</span>
 203 |     | <span class='neutral'>    uint256 flashLoanPremiumTotal;</span>
 204 |     | <span class='neutral'>  }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>  struct FlashLoanRepaymentParams {</span>
 207 |     | <span class='neutral'>    uint256 amount;</span>
 208 |     | <span class='neutral'>    uint256 totalPremium;</span>
 209 |     | <span class='neutral'>    uint256 flashLoanPremiumToProtocol;</span>
 210 |     | <span class='neutral'>    address asset;</span>
 211 |     | <span class='neutral'>    address receiverAddress;</span>
 212 |     | <span class='neutral'>    uint16 referralCode;</span>
 213 |     | <span class='neutral'>  }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>  struct CalculateUserAccountDataParams {</span>
 216 |     | <span class='neutral'>    UserConfigurationMap userConfig;</span>
 217 |     | <span class='neutral'>    uint256 reservesCount;</span>
 218 |     | <span class='neutral'>    address user;</span>
 219 |     | <span class='neutral'>    address oracle;</span>
 220 |     | <span class='neutral'>    uint8 userEModeCategory;</span>
 221 |     | <span class='neutral'>  }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>  struct ValidateBorrowParams {</span>
 224 |     | <span class='neutral'>    ReserveCache reserveCache;</span>
 225 |     | <span class='neutral'>    UserConfigurationMap userConfig;</span>
 226 |     | <span class='neutral'>    address asset;</span>
 227 |     | <span class='neutral'>    address userAddress;</span>
 228 |     | <span class='neutral'>    uint256 amount;</span>
 229 |     | <span class='neutral'>    InterestRateMode interestRateMode;</span>
 230 |     | <span class='neutral'>    uint256 maxStableLoanPercent;</span>
 231 |     | <span class='neutral'>    uint256 reservesCount;</span>
 232 |     | <span class='neutral'>    address oracle;</span>
 233 |     | <span class='neutral'>    uint8 userEModeCategory;</span>
 234 |     | <span class='neutral'>    address priceOracleSentinel;</span>
 235 |     | <span class='neutral'>    bool isolationModeActive;</span>
 236 |     | <span class='neutral'>    address isolationModeCollateralAddress;</span>
 237 |     | <span class='neutral'>    uint256 isolationModeDebtCeiling;</span>
 238 |     | <span class='neutral'>  }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>  struct ValidateLiquidationCallParams {</span>
 241 |     | <span class='neutral'>    ReserveCache debtReserveCache;</span>
 242 |     | <span class='neutral'>    uint256 totalDebt;</span>
 243 |     | <span class='neutral'>    uint256 healthFactor;</span>
 244 |     | <span class='neutral'>    address priceOracleSentinel;</span>
 245 |     | <span class='neutral'>  }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>  struct CalculateInterestRatesParams {</span>
 248 |     | <span class='neutral'>    uint256 unbacked;</span>
 249 |     | <span class='neutral'>    uint256 liquidityAdded;</span>
 250 |     | <span class='neutral'>    uint256 liquidityTaken;</span>
 251 |     | <span class='neutral'>    uint256 totalStableDebt;</span>
 252 |     | <span class='neutral'>    uint256 totalVariableDebt;</span>
 253 |     | <span class='neutral'>    uint256 averageStableBorrowRate;</span>
 254 |     | <span class='neutral'>    uint256 reserveFactor;</span>
 255 |     | <span class='neutral'>    address reserve;</span>
 256 |     | <span class='neutral'>    address aToken;</span>
 257 |     | <span class='neutral'>  }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>  struct InitReserveParams {</span>
 260 |     | <span class='neutral'>    address asset;</span>
 261 |     | <span class='neutral'>    address aTokenAddress;</span>
 262 |     | <span class='neutral'>    address stableDebtAddress;</span>
 263 |     | <span class='neutral'>    address variableDebtAddress;</span>
 264 |     | <span class='neutral'>    address interestRateStrategyAddress;</span>
 265 |     | <span class='neutral'>    uint16 reservesCount;</span>
 266 |     | <span class='neutral'>    uint16 maxNumberReserves;</span>
 267 |     | <span class='neutral'>  }</span>
 268 |     | <span class='neutral'>}</span>
 269 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/create3-factory/src/CREATE3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {CREATE3} from &quot;solmate/utils/CREATE3.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {ICREATE3Factory} from &quot;./ICREATE3Factory.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @title Factory for deploying contracts to deterministic addresses via CREATE3</span>
  9 |     | <span class='neutral'>/// @author zefram.eth</span>
 10 |     | <span class='neutral'>/// @notice Enables deploying contracts using CREATE3. Each deployer (msg.sender) has</span>
 11 |     | <span class='unexecuted'>/// its own namespace for deployed addresses.</span>
 12 |     | <span class='neutral'>contract CREATE3Factory is ICREATE3Factory {</span>
 13 |     | <span class='neutral'>    /// @inheritdoc	ICREATE3Factory</span>
 14 |     | <span class='unexecuted'>    function deploy(bytes32 salt, bytes memory creationCode)</span>
 15 |     | <span class='neutral'>        external</span>
 16 |     | <span class='neutral'>        payable</span>
 17 |     | <span class='neutral'>        override</span>
 18 |     | <span class='unexecuted'>        returns (address deployed)</span>
 19 |     | <span class='neutral'>    {</span>
 20 |     | <span class='neutral'>        // hash salt with the deployer address to give each deployer its own namespace</span>
 21 |     | <span class='unexecuted'>        salt = keccak256(abi.encodePacked(msg.sender, salt));</span>
 22 |     | <span class='unexecuted'>        return CREATE3.deploy(salt, creationCode, msg.value);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /// @inheritdoc	ICREATE3Factory</span>
 26 |     | <span class='unexecuted'>    function getDeployed(address deployer, bytes32 salt)</span>
 27 |     | <span class='neutral'>        external</span>
 28 |     | <span class='neutral'>        view</span>
 29 |     | <span class='neutral'>        override</span>
 30 |     | <span class='unexecuted'>        returns (address deployed)</span>
 31 |     | <span class='neutral'>    {</span>
 32 |     | <span class='neutral'>        // hash salt with the deployer address to give each deployer its own namespace</span>
 33 |     | <span class='unexecuted'>        salt = keccak256(abi.encodePacked(deployer, salt));</span>
 34 |     | <span class='unexecuted'>        return CREATE3.getDeployed(salt);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/create3-factory/src/ICREATE3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Factory for deploying contracts to deterministic addresses via CREATE3</span>
  5 |     | <span class='neutral'>/// @author zefram.eth</span>
  6 |     | <span class='neutral'>/// @notice Enables deploying contracts using CREATE3. Each deployer (msg.sender) has</span>
  7 |     | <span class='neutral'>/// its own namespace for deployed addresses.</span>
  8 |     | <span class='neutral'>interface ICREATE3Factory {</span>
  9 |     | <span class='neutral'>    /// @notice Deploys a contract using CREATE3</span>
 10 |     | <span class='neutral'>    /// @dev The provided salt is hashed together with msg.sender to generate the final salt</span>
 11 |     | <span class='neutral'>    /// @param salt The deployer-specific salt for determining the deployed contract&#39;s address</span>
 12 |     | <span class='neutral'>    /// @param creationCode The creation code of the contract to deploy</span>
 13 |     | <span class='neutral'>    /// @return deployed The address of the deployed contract</span>
 14 |     | <span class='neutral'>    function deploy(bytes32 salt, bytes memory creationCode)</span>
 15 |     | <span class='neutral'>        external</span>
 16 |     | <span class='neutral'>        payable</span>
 17 |     | <span class='neutral'>        returns (address deployed);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Predicts the address of a deployed contract</span>
 20 |     | <span class='neutral'>    /// @dev The provided salt is hashed together with the deployer address to generate the final salt</span>
 21 |     | <span class='neutral'>    /// @param deployer The deployer account that will call deploy()</span>
 22 |     | <span class='neutral'>    /// @param salt The deployer-specific salt for determining the deployed contract&#39;s address</span>
 23 |     | <span class='neutral'>    /// @return deployed The address of the contract that will be deployed</span>
 24 |     | <span class='neutral'>    function getDeployed(address deployer, bytes32 salt)</span>
 25 |     | <span class='neutral'>        external</span>
 26 |     | <span class='neutral'>        view</span>
 27 |     | <span class='neutral'>        returns (address deployed);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/lib/ds-test/src/test.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
   4 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
   5 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
   6 |     | <span class='neutral'>// (at your option) any later version.</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
   9 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  10 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  11 |     | <span class='neutral'>// GNU General Public License for more details.</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
  14 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  17 |     | <span class='unexecuted'></span>
  18 |     | <span class='neutral'>contract DSTest {</span>
  19 |     | <span class='neutral'>    event log                    (string);</span>
  20 |     | <span class='neutral'>    event logs                   (bytes);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event log_address            (address);</span>
  23 |     | <span class='neutral'>    event log_bytes32            (bytes32);</span>
  24 |     | <span class='neutral'>    event log_int                (int);</span>
  25 |     | <span class='neutral'>    event log_uint               (uint);</span>
  26 |     | <span class='neutral'>    event log_bytes              (bytes);</span>
  27 |     | <span class='neutral'>    event log_string             (string);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_named_address      (string key, address val);</span>
  30 |     | <span class='neutral'>    event log_named_bytes32      (string key, bytes32 val);</span>
  31 |     | <span class='neutral'>    event log_named_decimal_int  (string key, int val, uint decimals);</span>
  32 |     | <span class='neutral'>    event log_named_decimal_uint (string key, uint val, uint decimals);</span>
  33 |     | <span class='neutral'>    event log_named_int          (string key, int val);</span>
  34 |     | <span class='neutral'>    event log_named_uint         (string key, uint val);</span>
  35 |     | <span class='neutral'>    event log_named_bytes        (string key, bytes val);</span>
  36 |     | <span class='neutral'>    event log_named_string       (string key, string val);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    bool public IS_TEST = true;</span>
  39 |     | <span class='neutral'>    bool private _failed;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    address constant HEVM_ADDRESS =</span>
  42 |     | <span class='unexecuted'>        address(bytes20(uint160(uint256(keccak256(&#39;hevm cheat code&#39;)))));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    modifier mayRevert() { _; }</span>
  45 |     | <span class='neutral'>    modifier testopts(string memory) { _; }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function failed() public returns (bool) {</span>
  48 |     | <span class='unexecuted'>        if (_failed) {</span>
  49 |     | <span class='unexecuted'>            return _failed;</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='unexecuted'>            bool globalFailed = false;</span>
  52 |     | <span class='unexecuted'>            if (hasHEVMContext()) {</span>
  53 |     | <span class='unexecuted'>                (, bytes memory retdata) = HEVM_ADDRESS.call(</span>
  54 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
  55 |     | <span class='unexecuted'>                        bytes4(keccak256(&quot;load(address,bytes32)&quot;)),</span>
  56 |     | <span class='unexecuted'>                        abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;))</span>
  57 |     | <span class='neutral'>                    )</span>
  58 |     | <span class='neutral'>                );</span>
  59 |     | <span class='unexecuted'>                globalFailed = abi.decode(retdata, (bool));</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='unexecuted'>            return globalFailed;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    } </span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function fail() internal {</span>
  66 |     | <span class='unexecuted'>        if (hasHEVMContext()) {</span>
  67 |     | <span class='unexecuted'>            (bool status, ) = HEVM_ADDRESS.call(</span>
  68 |     | <span class='unexecuted'>                abi.encodePacked(</span>
  69 |     | <span class='unexecuted'>                    bytes4(keccak256(&quot;store(address,bytes32,bytes32)&quot;)),</span>
  70 |     | <span class='unexecuted'>                    abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;), bytes32(uint256(0x01)))</span>
  71 |     | <span class='neutral'>                )</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>            status; // Silence compiler warnings</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='unexecuted'>        _failed = true;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function hasHEVMContext() internal view returns (bool) {</span>
  79 |     | <span class='neutral'>        uint256 hevmCodeSize = 0;</span>
  80 |     | <span class='neutral'>        assembly {</span>
  81 |     | <span class='unexecuted'>            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='unexecuted'>        return hevmCodeSize &gt; 0;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    modifier logs_gas() {</span>
  87 |     | <span class='neutral'>        uint startGas = gasleft();</span>
  88 |     | <span class='neutral'>        _;</span>
  89 |     | <span class='neutral'>        uint endGas = gasleft();</span>
  90 |     | <span class='neutral'>        emit log_named_uint(&quot;gas&quot;, startGas - endGas);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function assertTrue(bool condition) internal {</span>
  94 |     | <span class='unexecuted'>        if (!condition) {</span>
  95 |     | <span class='unexecuted'>            emit log(&quot;Error: Assertion Failed&quot;);</span>
  96 |     | <span class='unexecuted'>            fail();</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function assertTrue(bool condition, string memory err) internal {</span>
 101 |     | <span class='unexecuted'>        if (!condition) {</span>
 102 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 103 |     | <span class='unexecuted'>            assertTrue(condition);</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function assertEq(address a, address b) internal {</span>
 108 |     | <span class='unexecuted'>        if (a != b) {</span>
 109 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [address]&quot;);</span>
 110 |     | <span class='unexecuted'>            emit log_named_address(&quot;  Expected&quot;, b);</span>
 111 |     | <span class='unexecuted'>            emit log_named_address(&quot;    Actual&quot;, a);</span>
 112 |     | <span class='neutral'>            fail();</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='unexecuted'>    function assertEq(address a, address b, string memory err) internal {</span>
 116 |     | <span class='unexecuted'>        if (a != b) {</span>
 117 |     | <span class='unexecuted'>            emit log_named_string (&quot;Error&quot;, err);</span>
 118 |     | <span class='unexecuted'>            assertEq(a, b);</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b) internal {</span>
 123 |     | <span class='neutral'>        if (a != b) {</span>
 124 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes32]&quot;);</span>
 125 |     | <span class='neutral'>            emit log_named_bytes32(&quot;  Expected&quot;, b);</span>
 126 |     | <span class='neutral'>            emit log_named_bytes32(&quot;    Actual&quot;, a);</span>
 127 |     | <span class='neutral'>            fail();</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b, string memory err) internal {</span>
 131 |     | <span class='neutral'>        if (a != b) {</span>
 132 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 133 |     | <span class='neutral'>            assertEq(a, b);</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b) internal {</span>
 137 |     | <span class='neutral'>        assertEq(a, b);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {</span>
 140 |     | <span class='neutral'>        assertEq(a, b, err);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(int a, int b) internal {</span>
 144 |     | <span class='neutral'>        if (a != b) {</span>
 145 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int]&quot;);</span>
 146 |     | <span class='neutral'>            emit log_named_int(&quot;  Expected&quot;, b);</span>
 147 |     | <span class='neutral'>            emit log_named_int(&quot;    Actual&quot;, a);</span>
 148 |     | <span class='neutral'>            fail();</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'>    function assertEq(int a, int b, string memory err) internal {</span>
 152 |     | <span class='neutral'>        if (a != b) {</span>
 153 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 154 |     | <span class='neutral'>            assertEq(a, b);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='unexecuted'>    function assertEq(uint a, uint b) internal {</span>
 158 |     | <span class='unexecuted'>        if (a != b) {</span>
 159 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [uint]&quot;);</span>
 160 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 161 |     | <span class='unexecuted'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 162 |     | <span class='unexecuted'>            fail();</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='unexecuted'>    function assertEq(uint a, uint b, string memory err) internal {</span>
 166 |     | <span class='unexecuted'>        if (a != b) {</span>
 167 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 168 |     | <span class='unexecuted'>            assertEq(a, b);</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals) internal {</span>
 172 |     | <span class='neutral'>        if (a != b) {</span>
 173 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal int]&quot;);</span>
 174 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Expected&quot;, b, decimals);</span>
 175 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;    Actual&quot;, a, decimals);</span>
 176 |     | <span class='neutral'>            fail();</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 180 |     | <span class='neutral'>        if (a != b) {</span>
 181 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 182 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals) internal {</span>
 186 |     | <span class='neutral'>        if (a != b) {</span>
 187 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal uint]&quot;);</span>
 188 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Expected&quot;, b, decimals);</span>
 189 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;    Actual&quot;, a, decimals);</span>
 190 |     | <span class='neutral'>            fail();</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 194 |     | <span class='neutral'>        if (a != b) {</span>
 195 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 196 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>    function assertGt(uint a, uint b) internal {</span>
 201 |     | <span class='unexecuted'>        if (a &lt;= b) {</span>
 202 |     | <span class='unexecuted'>            emit log(&quot;Error: a &gt; b not satisfied [uint]&quot;);</span>
 203 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 204 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 205 |     | <span class='neutral'>            fail();</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='unexecuted'>    function assertGt(uint a, uint b, string memory err) internal {</span>
 209 |     | <span class='unexecuted'>        if (a &lt;= b) {</span>
 210 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 211 |     | <span class='unexecuted'>            assertGt(a, b);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'>    function assertGt(int a, int b) internal {</span>
 215 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 216 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [int]&quot;);</span>
 217 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 218 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 219 |     | <span class='neutral'>            fail();</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>    function assertGt(int a, int b, string memory err) internal {</span>
 223 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 224 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 225 |     | <span class='neutral'>            assertGt(a, b);</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals) internal {</span>
 229 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 230 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal int]&quot;);</span>
 231 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 232 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 233 |     | <span class='neutral'>            fail();</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 237 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 238 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 239 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 240 |     | <span class='neutral'>        }</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals) internal {</span>
 243 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 244 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal uint]&quot;);</span>
 245 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 246 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 247 |     | <span class='neutral'>            fail();</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 251 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 252 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 253 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    function assertGe(uint a, uint b) internal {</span>
 258 |     | <span class='neutral'>        if (a &lt; b) {</span>
 259 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [uint]&quot;);</span>
 260 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 261 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 262 |     | <span class='neutral'>            fail();</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'>    function assertGe(uint a, uint b, string memory err) internal {</span>
 266 |     | <span class='neutral'>        if (a &lt; b) {</span>
 267 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 268 |     | <span class='neutral'>            assertGe(a, b);</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'>    function assertGe(int a, int b) internal {</span>
 272 |     | <span class='neutral'>        if (a &lt; b) {</span>
 273 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [int]&quot;);</span>
 274 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 275 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 276 |     | <span class='neutral'>            fail();</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'>    function assertGe(int a, int b, string memory err) internal {</span>
 280 |     | <span class='neutral'>        if (a &lt; b) {</span>
 281 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 282 |     | <span class='neutral'>            assertGe(a, b);</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals) internal {</span>
 286 |     | <span class='neutral'>        if (a &lt; b) {</span>
 287 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal int]&quot;);</span>
 288 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 289 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 290 |     | <span class='neutral'>            fail();</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 294 |     | <span class='neutral'>        if (a &lt; b) {</span>
 295 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 296 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 297 |     | <span class='neutral'>        }</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals) internal {</span>
 300 |     | <span class='neutral'>        if (a &lt; b) {</span>
 301 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal uint]&quot;);</span>
 302 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 303 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 304 |     | <span class='neutral'>            fail();</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 308 |     | <span class='neutral'>        if (a &lt; b) {</span>
 309 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 310 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='unexecuted'>    function assertLt(uint a, uint b) internal {</span>
 315 |     | <span class='unexecuted'>        if (a &gt;= b) {</span>
 316 |     | <span class='unexecuted'>            emit log(&quot;Error: a &lt; b not satisfied [uint]&quot;);</span>
 317 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 318 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 319 |     | <span class='neutral'>            fail();</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='unexecuted'>    function assertLt(uint a, uint b, string memory err) internal {</span>
 323 |     | <span class='unexecuted'>        if (a &gt;= b) {</span>
 324 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 325 |     | <span class='unexecuted'>            assertLt(a, b);</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'>    function assertLt(int a, int b) internal {</span>
 329 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 330 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [int]&quot;);</span>
 331 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 332 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 333 |     | <span class='neutral'>            fail();</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'>    function assertLt(int a, int b, string memory err) internal {</span>
 337 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 338 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 339 |     | <span class='neutral'>            assertLt(a, b);</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals) internal {</span>
 343 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 344 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal int]&quot;);</span>
 345 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 346 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 347 |     | <span class='neutral'>            fail();</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 351 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 352 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 353 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals) internal {</span>
 357 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 358 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal uint]&quot;);</span>
 359 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 360 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 361 |     | <span class='neutral'>            fail();</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 365 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 366 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 367 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function assertLe(uint a, uint b) internal {</span>
 372 |     | <span class='neutral'>        if (a &gt; b) {</span>
 373 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [uint]&quot;);</span>
 374 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 375 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 376 |     | <span class='neutral'>            fail();</span>
 377 |     | <span class='neutral'>        }</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>    function assertLe(uint a, uint b, string memory err) internal {</span>
 380 |     | <span class='neutral'>        if (a &gt; b) {</span>
 381 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 382 |     | <span class='neutral'>            assertLe(a, b);</span>
 383 |     | <span class='neutral'>        }</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'>    function assertLe(int a, int b) internal {</span>
 386 |     | <span class='neutral'>        if (a &gt; b) {</span>
 387 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [int]&quot;);</span>
 388 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 389 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 390 |     | <span class='neutral'>            fail();</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'>    function assertLe(int a, int b, string memory err) internal {</span>
 394 |     | <span class='neutral'>        if (a &gt; b) {</span>
 395 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 396 |     | <span class='neutral'>            assertLe(a, b);</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals) internal {</span>
 400 |     | <span class='neutral'>        if (a &gt; b) {</span>
 401 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal int]&quot;);</span>
 402 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 403 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 404 |     | <span class='neutral'>            fail();</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 408 |     | <span class='neutral'>        if (a &gt; b) {</span>
 409 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 410 |     | <span class='neutral'>            assertLeDecimal(a, b, decimals);</span>
 411 |     | <span class='neutral'>        }</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals) internal {</span>
 414 |     | <span class='neutral'>        if (a &gt; b) {</span>
 415 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal uint]&quot;);</span>
 416 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 417 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 418 |     | <span class='neutral'>            fail();</span>
 419 |     | <span class='neutral'>        }</span>
 420 |     | <span class='neutral'>    }</span>
 421 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 422 |     | <span class='neutral'>        if (a &gt; b) {</span>
 423 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 424 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 425 |     | <span class='neutral'>        }</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertEq(string memory a, string memory b) internal {</span>
 429 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 430 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [string]&quot;);</span>
 431 |     | <span class='neutral'>            emit log_named_string(&quot;  Expected&quot;, b);</span>
 432 |     | <span class='neutral'>            emit log_named_string(&quot;    Actual&quot;, a);</span>
 433 |     | <span class='neutral'>            fail();</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'>    function assertEq(string memory a, string memory b, string memory err) internal {</span>
 437 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 438 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 439 |     | <span class='neutral'>            assertEq(a, b);</span>
 440 |     | <span class='neutral'>        }</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {</span>
 444 |     | <span class='neutral'>        ok = true;</span>
 445 |     | <span class='neutral'>        if (a.length == b.length) {</span>
 446 |     | <span class='neutral'>            for (uint i = 0; i &lt; a.length; i++) {</span>
 447 |     | <span class='neutral'>                if (a[i] != b[i]) {</span>
 448 |     | <span class='neutral'>                    ok = false;</span>
 449 |     | <span class='neutral'>                }</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>        } else {</span>
 452 |     | <span class='neutral'>            ok = false;</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b) internal {</span>
 456 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 457 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes]&quot;);</span>
 458 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Expected&quot;, b);</span>
 459 |     | <span class='neutral'>            emit log_named_bytes(&quot;    Actual&quot;, a);</span>
 460 |     | <span class='neutral'>            fail();</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {</span>
 464 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 465 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 466 |     | <span class='neutral'>            assertEq0(a, b);</span>
 467 |     | <span class='neutral'>        }</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'>}</span>
 470 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/Base.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage} from &quot;./StdStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm, VmSafe} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract CommonBase {</span>
  8 |     | <span class='neutral'>    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.</span>
  9 |     | <span class='unexecuted'>    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));</span>
 10 |     | <span class='neutral'>    // console.sol and console2.sol work by executing a staticcall to this address.</span>
 11 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 12 |     | <span class='neutral'>    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.</span>
 13 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))));</span>
 14 |     | <span class='neutral'>    // Address of the test contract, deployed by the DEFAULT_SENDER.</span>
 15 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
 18 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 21 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
 27 |     | <span class='neutral'>    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 28 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 31 |     | <span class='neutral'>}</span>
 32 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/Script.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// 💬 ABOUT</span>
  5 |     | <span class='neutral'>// Standard Library&#39;s default Script.</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// 🧩 MODULES</span>
  8 |     | <span class='neutral'>import {ScriptBase} from &quot;./Base.sol&quot;;</span>
  9 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
 10 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 11 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 12 |     | <span class='neutral'>import {StdCheatsSafe} from &quot;./StdCheats.sol&quot;;</span>
 13 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 14 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 15 |     | <span class='neutral'>import {StdStorage, stdStorageSafe} from &quot;./StdStorage.sol&quot;;</span>
 16 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 17 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>// 📦 BOILERPLATE</span>
 20 |     | <span class='neutral'>import {ScriptBase} from &quot;./Base.sol&quot;;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>// ⭐️ SCRIPT</span>
 23 |     | <span class='neutral'>abstract contract Script is StdChains, StdCheatsSafe, StdUtils, ScriptBase {</span>
 24 |     | <span class='neutral'>    // Note: IS_SCRIPT() must return true.</span>
 25 |     | <span class='unexecuted'>    bool public IS_SCRIPT = true;</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DSTest} from &quot;ds-test/test.sol&quot;;</span>
   5 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions is DSTest {</span>
   8 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
   9 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  10 |     | <span class='neutral'>    event log_array(address[] val);</span>
  11 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  12 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  13 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function fail(string memory err) internal virtual {</span>
  16 |     | <span class='neutral'>        emit log_named_string(&quot;Error&quot;, err);</span>
  17 |     | <span class='neutral'>        fail();</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function assertFalse(bool data) internal virtual {</span>
  21 |     | <span class='neutral'>        assertTrue(!data);</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal virtual {</span>
  25 |     | <span class='neutral'>        assertTrue(!data, err);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function assertEq(bool a, bool b) internal virtual {</span>
  29 |     | <span class='unexecuted'>        if (a != b) {</span>
  30 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [bool]&quot;);</span>
  31 |     | <span class='unexecuted'>            emit log_named_string(&quot;  Expected&quot;, b ? &quot;true&quot; : &quot;false&quot;);</span>
  32 |     | <span class='unexecuted'>            emit log_named_string(&quot;    Actual&quot;, a ? &quot;true&quot; : &quot;false&quot;);</span>
  33 |     | <span class='neutral'>            fail();</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function assertEq(bool a, bool b, string memory err) internal virtual {</span>
  38 |     | <span class='unexecuted'>        if (a != b) {</span>
  39 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
  40 |     | <span class='unexecuted'>            assertEq(a, b);</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b) internal virtual {</span>
  45 |     | <span class='neutral'>        assertEq0(a, b);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {</span>
  49 |     | <span class='neutral'>        assertEq0(a, b, err);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {</span>
  53 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  54 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [uint[]]&quot;);</span>
  55 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  56 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  57 |     | <span class='neutral'>            fail();</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b) internal virtual {</span>
  62 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  63 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int[]]&quot;);</span>
  64 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  65 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  66 |     | <span class='neutral'>            fail();</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b) internal virtual {</span>
  71 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  72 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [address[]]&quot;);</span>
  73 |     | <span class='neutral'>            emit log_named_array(&quot;  Expected&quot;, b);</span>
  74 |     | <span class='neutral'>            emit log_named_array(&quot;    Actual&quot;, a);</span>
  75 |     | <span class='neutral'>            fail();</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {</span>
  80 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  81 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  82 |     | <span class='neutral'>            assertEq(a, b);</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {</span>
  87 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  88 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  89 |     | <span class='neutral'>            assertEq(a, b);</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {</span>
  94 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  95 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  96 |     | <span class='neutral'>            assertEq(a, b);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // Legacy helper</span>
 101 |     | <span class='neutral'>    function assertEqUint(uint256 a, uint256 b) internal virtual {</span>
 102 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {</span>
 106 |     | <span class='unexecuted'>        uint256 delta = stdMath.delta(a, b);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        if (delta &gt; maxDelta) {</span>
 109 |     | <span class='unexecuted'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 110 |     | <span class='unexecuted'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 111 |     | <span class='unexecuted'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 112 |     | <span class='unexecuted'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 113 |     | <span class='unexecuted'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 114 |     | <span class='unexecuted'>            fail();</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 119 |     | <span class='unexecuted'>        uint256 delta = stdMath.delta(a, b);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        if (delta &gt; maxDelta) {</span>
 122 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 123 |     | <span class='unexecuted'>            assertApproxEqAbs(a, b, maxDelta);</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {</span>
 128 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 131 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 132 |     | <span class='neutral'>            emit log_named_int(&quot;  Expected&quot;, b);</span>
 133 |     | <span class='neutral'>            emit log_named_int(&quot;    Actual&quot;, a);</span>
 134 |     | <span class='neutral'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 135 |     | <span class='neutral'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 136 |     | <span class='neutral'>            fail();</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 141 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 144 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 145 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function assertApproxEqRel(</span>
 150 |     | <span class='neutral'>        uint256 a,</span>
 151 |     | <span class='neutral'>        uint256 b,</span>
 152 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 153 |     | <span class='neutral'>    ) internal virtual {</span>
 154 |     | <span class='unexecuted'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>        if (percentDelta &gt; maxPercentDelta) {</span>
 159 |     | <span class='unexecuted'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 160 |     | <span class='unexecuted'>            emit log_named_uint(&quot;    Expected&quot;, b);</span>
 161 |     | <span class='unexecuted'>            emit log_named_uint(&quot;      Actual&quot;, a);</span>
 162 |     | <span class='unexecuted'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 163 |     | <span class='unexecuted'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 164 |     | <span class='unexecuted'>            fail();</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    function assertApproxEqRel(</span>
 169 |     | <span class='neutral'>        uint256 a,</span>
 170 |     | <span class='neutral'>        uint256 b,</span>
 171 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 172 |     | <span class='neutral'>        string memory err</span>
 173 |     | <span class='neutral'>    ) internal virtual {</span>
 174 |     | <span class='unexecuted'>        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        if (percentDelta &gt; maxPercentDelta) {</span>
 179 |     | <span class='unexecuted'>            emit log_named_string(&quot;Error&quot;, err);</span>
 180 |     | <span class='unexecuted'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {</span>
 185 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 190 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 191 |     | <span class='neutral'>            emit log_named_int(&quot;    Expected&quot;, b);</span>
 192 |     | <span class='neutral'>            emit log_named_int(&quot;      Actual&quot;, a);</span>
 193 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 194 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 195 |     | <span class='neutral'>            fail();</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {</span>
 200 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 205 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 206 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'>}</span>
 210 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdChains.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * StdChains provides information about EVM compatible chains that can be used in scripts/tests.</span>
  10 |     | <span class='neutral'> * For each chain, the chain&#39;s name, chain ID, and a default RPC URL are provided. Chains are</span>
  11 |     | <span class='neutral'> * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of</span>
  12 |     | <span class='neutral'> * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the</span>
  13 |     | <span class='neutral'> * alias used in this contract, which can be found as the first argument to the</span>
  14 |     | <span class='neutral'> * `setChainWithDefaultRpcUrl` call in the `initialize` function.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * There are two main ways to use this contract:</span>
  17 |     | <span class='neutral'> *   1. Set a chain with `setChain(string memory chainAlias, Chain memory chain)`</span>
  18 |     | <span class='neutral'> *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> * The first time either of those are used, chains are initialized with the default set of RPC URLs.</span>
  21 |     | <span class='neutral'> * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in</span>
  22 |     | <span class='neutral'> * `defaultRpcUrls`.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * The `setChain` function is straightforward, and it simply saves off the given chain data.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let&#39;s say</span>
  27 |     | <span class='neutral'> * we want to retrieve `mainnet`&#39;s RPC URL:</span>
  28 |     | <span class='neutral'> *   - If you haven&#39;t set any mainnet chain info with `setChain` and you haven&#39;t specified that</span>
  29 |     | <span class='neutral'> *     chain in `foundry.toml`, the default data and RPC URL will be returned.</span>
  30 |     | <span class='neutral'> *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if</span>
  31 |     | <span class='neutral'> *     a URL is given or if an environment variable is given and that environment variable exists).</span>
  32 |     | <span class='neutral'> *     Otherwise, the default data is returned.</span>
  33 |     | <span class='neutral'> *   - If you specified data with `setChain` it will return that.</span>
  34 |     | <span class='neutral'> *</span>
  35 |     | <span class='neutral'> * Summarizing the above, the prioritization hierarchy is `setChain` -&gt; `foundry.toml` -&gt; defaults.</span>
  36 |     | <span class='neutral'> */</span>
  37 |     | <span class='neutral'>abstract contract StdChains {</span>
  38 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    bool private initialized;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct Chain {</span>
  43 |     | <span class='neutral'>        // The chain name.</span>
  44 |     | <span class='neutral'>        string name;</span>
  45 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  46 |     | <span class='neutral'>        uint256 chainId;</span>
  47 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  48 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  49 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  50 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  51 |     | <span class='neutral'>        string rpcUrl;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    // Maps from the chain&#39;s alias (matching the alias in the `foundry.toml` file) to chain data.</span>
  55 |     | <span class='neutral'>    mapping(string =&gt; Chain) private chains;</span>
  56 |     | <span class='neutral'>    // Maps from the chain&#39;s alias to it&#39;s default RPC URL.</span>
  57 |     | <span class='neutral'>    mapping(string =&gt; string) private defaultRpcUrls;</span>
  58 |     | <span class='neutral'>    // Maps from a chain ID to it&#39;s alias.</span>
  59 |     | <span class='neutral'>    mapping(uint256 =&gt; string) private idToAlias;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    // The RPC URL will be fetched from config or defaultRpcUrls if possible.</span>
  62 |     | <span class='neutral'>    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {</span>
  63 |     | <span class='neutral'>        require(bytes(chainAlias).length != 0, &quot;StdChains getChain(string): Chain alias cannot be the empty string.&quot;);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        initialize();</span>
  66 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  67 |     | <span class='neutral'>        require(</span>
  68 |     | <span class='neutral'>            chain.chainId != 0,</span>
  69 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(string): Chain with alias \&quot;&quot;, chainAlias, &quot;\&quot; not found.&quot;))</span>
  70 |     | <span class='neutral'>        );</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {</span>
  76 |     | <span class='neutral'>        require(chainId != 0, &quot;StdChains getChain(uint256): Chain ID cannot be 0.&quot;);</span>
  77 |     | <span class='neutral'>        initialize();</span>
  78 |     | <span class='neutral'>        string memory chainAlias = idToAlias[chainId];</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        require(</span>
  83 |     | <span class='neutral'>            chain.chainId != 0,</span>
  84 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(uint256): Chain with ID &quot;, vm.toString(chainId), &quot; not found.&quot;))</span>
  85 |     | <span class='neutral'>        );</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
  91 |     | <span class='neutral'>    function setChain(string memory chainAlias, Chain memory chain) internal virtual {</span>
  92 |     | <span class='neutral'>        require(</span>
  93 |     | <span class='neutral'>            bytes(chainAlias).length != 0, &quot;StdChains setChain(string,Chain): Chain alias cannot be the empty string.&quot;</span>
  94 |     | <span class='neutral'>        );</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        require(chain.chainId != 0, &quot;StdChains setChain(string,Chain): Chain ID cannot be 0.&quot;);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        initialize();</span>
  99 |     | <span class='neutral'>        string memory foundAlias = idToAlias[chain.chainId];</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        require(</span>
 102 |     | <span class='neutral'>            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),</span>
 103 |     | <span class='neutral'>            string(</span>
 104 |     | <span class='neutral'>                abi.encodePacked(</span>
 105 |     | <span class='neutral'>                    &quot;StdChains setChain(string,Chain): Chain ID &quot;,</span>
 106 |     | <span class='neutral'>                    vm.toString(chain.chainId),</span>
 107 |     | <span class='neutral'>                    &quot; already used by \&quot;&quot;,</span>
 108 |     | <span class='neutral'>                    foundAlias,</span>
 109 |     | <span class='neutral'>                    &quot;\&quot;.&quot;</span>
 110 |     | <span class='neutral'>                )</span>
 111 |     | <span class='neutral'>            )</span>
 112 |     | <span class='neutral'>        );</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        uint256 oldChainId = chains[chainAlias].chainId;</span>
 115 |     | <span class='neutral'>        delete idToAlias[oldChainId];</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        chains[chainAlias] = chain;</span>
 118 |     | <span class='neutral'>        idToAlias[chain.chainId] = chainAlias;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    // lookup rpcUrl, in descending order of priority:</span>
 122 |     | <span class='neutral'>    // current -&gt; config (foundry.toml) -&gt; default</span>
 123 |     | <span class='neutral'>    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)</span>
 124 |     | <span class='neutral'>        private</span>
 125 |     | <span class='neutral'>        view</span>
 126 |     | <span class='neutral'>        returns (Chain memory)</span>
 127 |     | <span class='neutral'>    {</span>
 128 |     | <span class='neutral'>        if (bytes(chain.rpcUrl).length == 0) {</span>
 129 |     | <span class='neutral'>            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {</span>
 130 |     | <span class='neutral'>                chain.rpcUrl = configRpcUrl;</span>
 131 |     | <span class='neutral'>            } catch (bytes memory err) {</span>
 132 |     | <span class='neutral'>                chain.rpcUrl = defaultRpcUrls[chainAlias];</span>
 133 |     | <span class='neutral'>                // distinguish &#39;not found&#39; from &#39;cannot read&#39;</span>
 134 |     | <span class='neutral'>                bytes memory notFoundError =</span>
 135 |     | <span class='neutral'>                    abi.encodeWithSignature(&quot;CheatCodeError&quot;, string(abi.encodePacked(&quot;invalid rpc url &quot;, chainAlias)));</span>
 136 |     | <span class='neutral'>                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {</span>
 137 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 138 |     | <span class='neutral'>                    assembly {</span>
 139 |     | <span class='neutral'>                        revert(add(32, err), mload(err))</span>
 140 |     | <span class='neutral'>                    }</span>
 141 |     | <span class='neutral'>                }</span>
 142 |     | <span class='neutral'>            }</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        return chain;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function initialize() private {</span>
 148 |     | <span class='neutral'>        if (initialized) return;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        initialized = true;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`</span>
 153 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;anvil&quot;, Chain(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;));</span>
 154 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 155 |     | <span class='neutral'>            &quot;mainnet&quot;, Chain(&quot;Mainnet&quot;, 1, &quot;https://mainnet.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;)</span>
 156 |     | <span class='neutral'>        );</span>
 157 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 158 |     | <span class='neutral'>            &quot;goerli&quot;, Chain(&quot;Goerli&quot;, 5, &quot;https://goerli.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;)</span>
 159 |     | <span class='neutral'>        );</span>
 160 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 161 |     | <span class='neutral'>            &quot;sepolia&quot;, Chain(&quot;Sepolia&quot;, 11155111, &quot;https://sepolia.infura.io/v3/6770454bc6ea42c58aac12978531b93f&quot;)</span>
 162 |     | <span class='neutral'>        );</span>
 163 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism&quot;, Chain(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;));</span>
 164 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism_goerli&quot;, Chain(&quot;Optimism Goerli&quot;, 420, &quot;https://goerli.optimism.io&quot;));</span>
 165 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_one&quot;, Chain(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;));</span>
 166 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 167 |     | <span class='neutral'>            &quot;arbitrum_one_goerli&quot;, Chain(&quot;Arbitrum One Goerli&quot;, 421613, &quot;https://goerli-rollup.arbitrum.io/rpc&quot;)</span>
 168 |     | <span class='neutral'>        );</span>
 169 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_nova&quot;, Chain(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;));</span>
 170 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon&quot;, Chain(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;));</span>
 171 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon_mumbai&quot;, Chain(&quot;Polygon Mumbai&quot;, 80001, &quot;https://rpc-mumbai.maticvigil.com&quot;));</span>
 172 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;avalanche&quot;, Chain(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;));</span>
 173 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 174 |     | <span class='neutral'>            &quot;avalanche_fuji&quot;, Chain(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;)</span>
 175 |     | <span class='neutral'>        );</span>
 176 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;bnb_smart_chain&quot;, Chain(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;));</span>
 177 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;bnb_smart_chain_testnet&quot;, Chain(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://data-seed-prebsc-1-s1.binance.org:8545&quot;));// forgefmt: disable-line</span>
 178 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;gnosis_chain&quot;, Chain(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;));</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    // set chain info, with priority to chainAlias&#39; rpc url in foundry.toml</span>
 182 |     | <span class='neutral'>    function setChainWithDefaultRpcUrl(string memory chainAlias, Chain memory chain) private {</span>
 183 |     | <span class='neutral'>        string memory rpcUrl = chain.rpcUrl;</span>
 184 |     | <span class='neutral'>        defaultRpcUrls[chainAlias] = rpcUrl;</span>
 185 |     | <span class='neutral'>        chain.rpcUrl = &quot;&quot;;</span>
 186 |     | <span class='neutral'>        setChain(chainAlias, chain);</span>
 187 |     | <span class='neutral'>        chain.rpcUrl = rpcUrl; // restore argument</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'>}</span>
 190 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  10 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    bool private gasMeteringOff;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  15 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  16 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    struct RawTx1559 {</span>
  19 |     | <span class='neutral'>        string[] arguments;</span>
  20 |     | <span class='neutral'>        address contractAddress;</span>
  21 |     | <span class='neutral'>        string contractName;</span>
  22 |     | <span class='neutral'>        // json value name = function</span>
  23 |     | <span class='neutral'>        string functionSig;</span>
  24 |     | <span class='neutral'>        bytes32 hash;</span>
  25 |     | <span class='neutral'>        // json value name = tx</span>
  26 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  27 |     | <span class='neutral'>        // json value name = type</span>
  28 |     | <span class='neutral'>        string opcode;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  32 |     | <span class='neutral'>        AccessList[] accessList;</span>
  33 |     | <span class='neutral'>        bytes data;</span>
  34 |     | <span class='neutral'>        address from;</span>
  35 |     | <span class='neutral'>        bytes gas;</span>
  36 |     | <span class='neutral'>        bytes nonce;</span>
  37 |     | <span class='neutral'>        address to;</span>
  38 |     | <span class='neutral'>        bytes txType;</span>
  39 |     | <span class='neutral'>        bytes value;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct Tx1559 {</span>
  43 |     | <span class='neutral'>        string[] arguments;</span>
  44 |     | <span class='neutral'>        address contractAddress;</span>
  45 |     | <span class='neutral'>        string contractName;</span>
  46 |     | <span class='neutral'>        string functionSig;</span>
  47 |     | <span class='neutral'>        bytes32 hash;</span>
  48 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  49 |     | <span class='neutral'>        string opcode;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  53 |     | <span class='neutral'>        AccessList[] accessList;</span>
  54 |     | <span class='neutral'>        bytes data;</span>
  55 |     | <span class='neutral'>        address from;</span>
  56 |     | <span class='neutral'>        uint256 gas;</span>
  57 |     | <span class='neutral'>        uint256 nonce;</span>
  58 |     | <span class='neutral'>        address to;</span>
  59 |     | <span class='neutral'>        uint256 txType;</span>
  60 |     | <span class='neutral'>        uint256 value;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  64 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  65 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    struct TxLegacy {</span>
  68 |     | <span class='neutral'>        string[] arguments;</span>
  69 |     | <span class='neutral'>        address contractAddress;</span>
  70 |     | <span class='neutral'>        string contractName;</span>
  71 |     | <span class='neutral'>        string functionSig;</span>
  72 |     | <span class='neutral'>        string hash;</span>
  73 |     | <span class='neutral'>        string opcode;</span>
  74 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  78 |     | <span class='neutral'>        AccessList[] accessList;</span>
  79 |     | <span class='neutral'>        uint256 chainId;</span>
  80 |     | <span class='neutral'>        bytes data;</span>
  81 |     | <span class='neutral'>        address from;</span>
  82 |     | <span class='neutral'>        uint256 gas;</span>
  83 |     | <span class='neutral'>        uint256 gasPrice;</span>
  84 |     | <span class='neutral'>        bytes32 hash;</span>
  85 |     | <span class='neutral'>        uint256 nonce;</span>
  86 |     | <span class='neutral'>        bytes1 opcode;</span>
  87 |     | <span class='neutral'>        bytes32 r;</span>
  88 |     | <span class='neutral'>        bytes32 s;</span>
  89 |     | <span class='neutral'>        uint256 txType;</span>
  90 |     | <span class='neutral'>        address to;</span>
  91 |     | <span class='neutral'>        uint8 v;</span>
  92 |     | <span class='neutral'>        uint256 value;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    struct AccessList {</span>
  96 |     | <span class='neutral'>        address accessAddress;</span>
  97 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 101 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 102 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    struct RawReceipt {</span>
 105 |     | <span class='neutral'>        bytes32 blockHash;</span>
 106 |     | <span class='neutral'>        bytes blockNumber;</span>
 107 |     | <span class='neutral'>        address contractAddress;</span>
 108 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 109 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 110 |     | <span class='neutral'>        address from;</span>
 111 |     | <span class='neutral'>        bytes gasUsed;</span>
 112 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 113 |     | <span class='neutral'>        bytes logsBloom;</span>
 114 |     | <span class='neutral'>        bytes status;</span>
 115 |     | <span class='neutral'>        address to;</span>
 116 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 117 |     | <span class='neutral'>        bytes transactionIndex;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    struct Receipt {</span>
 121 |     | <span class='neutral'>        bytes32 blockHash;</span>
 122 |     | <span class='neutral'>        uint256 blockNumber;</span>
 123 |     | <span class='neutral'>        address contractAddress;</span>
 124 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 125 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 126 |     | <span class='neutral'>        address from;</span>
 127 |     | <span class='neutral'>        uint256 gasUsed;</span>
 128 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 129 |     | <span class='neutral'>        bytes logsBloom;</span>
 130 |     | <span class='neutral'>        uint256 status;</span>
 131 |     | <span class='neutral'>        address to;</span>
 132 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 133 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 137 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 140 |     | <span class='neutral'>        string[] libraries;</span>
 141 |     | <span class='neutral'>        string path;</span>
 142 |     | <span class='neutral'>        string[] pending;</span>
 143 |     | <span class='neutral'>        Receipt[] receipts;</span>
 144 |     | <span class='neutral'>        uint256 timestamp;</span>
 145 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 146 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 150 |     | <span class='neutral'>        string[] libraries;</span>
 151 |     | <span class='neutral'>        string path;</span>
 152 |     | <span class='neutral'>        string[] pending;</span>
 153 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 154 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 155 |     | <span class='neutral'>        uint256 timestamp;</span>
 156 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 160 |     | <span class='neutral'>        // json value = address</span>
 161 |     | <span class='neutral'>        address logAddress;</span>
 162 |     | <span class='neutral'>        bytes32 blockHash;</span>
 163 |     | <span class='neutral'>        bytes blockNumber;</span>
 164 |     | <span class='neutral'>        bytes data;</span>
 165 |     | <span class='neutral'>        bytes logIndex;</span>
 166 |     | <span class='neutral'>        bool removed;</span>
 167 |     | <span class='neutral'>        bytes32[] topics;</span>
 168 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 169 |     | <span class='neutral'>        bytes transactionIndex;</span>
 170 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    struct ReceiptLog {</span>
 174 |     | <span class='neutral'>        // json value = address</span>
 175 |     | <span class='neutral'>        address logAddress;</span>
 176 |     | <span class='neutral'>        bytes32 blockHash;</span>
 177 |     | <span class='neutral'>        uint256 blockNumber;</span>
 178 |     | <span class='neutral'>        bytes data;</span>
 179 |     | <span class='neutral'>        uint256 logIndex;</span>
 180 |     | <span class='neutral'>        bytes32[] topics;</span>
 181 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 182 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 183 |     | <span class='neutral'>        bool removed;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    struct TxReturn {</span>
 187 |     | <span class='neutral'>        string internalType;</span>
 188 |     | <span class='neutral'>        string value;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr) internal virtual {</span>
 192 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 193 |     | <span class='neutral'>        uint256 chainId;</span>
 194 |     | <span class='neutral'>        assembly {</span>
 195 |     | <span class='neutral'>            chainId := chainid()</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>        assumeNoPrecompiles(addr, chainId);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr, uint256 chainId) internal virtual {</span>
 201 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 202 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        // These should be present on all EVM-compatible chains.</span>
 205 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0x9));</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 208 |     | <span class='neutral'>        if (chainId == 10 || chainId == 420) {</span>
 209 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 210 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 211 |     | <span class='neutral'>        } else if (chainId == 42161 || chainId == 421613) {</span>
 212 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 213 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 214 |     | <span class='neutral'>        } else if (chainId == 43114 || chainId == 43113) {</span>
 215 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 216 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 217 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 218 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 224 |     | <span class='neutral'>        internal</span>
 225 |     | <span class='neutral'>        view</span>
 226 |     | <span class='neutral'>        virtual</span>
 227 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 228 |     | <span class='neutral'>    {</span>
 229 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 230 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 231 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 232 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 233 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 234 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 235 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 236 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 237 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 238 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 239 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 240 |     | <span class='neutral'>        return artifact;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 244 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 245 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 246 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        return txs;</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 252 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 253 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 254 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 255 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 256 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 257 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 258 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 259 |     | <span class='neutral'>        return transaction;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 263 |     | <span class='neutral'>        internal</span>
 264 |     | <span class='neutral'>        pure</span>
 265 |     | <span class='neutral'>        virtual</span>
 266 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 267 |     | <span class='neutral'>    {</span>
 268 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 269 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 270 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 271 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 272 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 273 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 274 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 275 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 276 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 277 |     | <span class='neutral'>        return txDetail;</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 281 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 282 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 283 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 284 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 288 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 289 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 290 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 291 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 292 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 296 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 297 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 298 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 299 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 300 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 304 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 305 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 306 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 307 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 308 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 312 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 313 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 314 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'>        return receipts;</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 320 |     | <span class='neutral'>        Receipt memory receipt;</span>
 321 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 322 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 323 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 324 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 325 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 326 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 327 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 328 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 329 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 330 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 331 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 332 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 333 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 334 |     | <span class='neutral'>        return receipt;</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 338 |     | <span class='neutral'>        internal</span>
 339 |     | <span class='neutral'>        pure</span>
 340 |     | <span class='neutral'>        virtual</span>
 341 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 342 |     | <span class='neutral'>    {</span>
 343 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 344 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 345 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 346 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 347 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 348 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 349 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 350 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 351 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 352 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 353 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>        return logs;</span>
 356 |     | <span class='neutral'>    }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 359 |     | <span class='neutral'>    // the artifacts directory</span>
 360 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 361 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 362 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 363 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 364 |     | <span class='neutral'>        assembly {</span>
 365 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 366 |     | <span class='neutral'>        }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 372 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 373 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 374 |     | <span class='neutral'>        assembly {</span>
 375 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 382 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 383 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 384 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 385 |     | <span class='neutral'>        assembly {</span>
 386 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 393 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 394 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 395 |     | <span class='neutral'>        assembly {</span>
 396 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 400 |     | <span class='neutral'>    }</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 403 |     | <span class='neutral'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 404 |     | <span class='neutral'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 405 |     | <span class='neutral'>        addr = vm.addr(privateKey);</span>
 406 |     | <span class='neutral'>        vm.label(addr, name);</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    // creates a labeled address</span>
 410 |     | <span class='neutral'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 411 |     | <span class='neutral'>        (addr,) = makeAddrAndKey(name);</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 415 |     | <span class='neutral'>        internal</span>
 416 |     | <span class='neutral'>        virtual</span>
 417 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 418 |     | <span class='neutral'>    {</span>
 419 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 420 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 424 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 425 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function isFork() internal virtual returns (bool status) {</span>
 429 |     | <span class='neutral'>        try vm.activeFork() {</span>
 430 |     | <span class='neutral'>            status = true;</span>
 431 |     | <span class='neutral'>        } catch (bytes memory) {}</span>
 432 |     | <span class='neutral'>    }</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>    modifier skipWhenForking() {</span>
 435 |     | <span class='neutral'>        if (!isFork()) {</span>
 436 |     | <span class='neutral'>            _;</span>
 437 |     | <span class='neutral'>        }</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    modifier skipWhenNotForking() {</span>
 441 |     | <span class='neutral'>        if (isFork()) {</span>
 442 |     | <span class='neutral'>            _;</span>
 443 |     | <span class='neutral'>        }</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    modifier noGasMetering() {</span>
 447 |     | <span class='neutral'>        vm.pauseGasMetering();</span>
 448 |     | <span class='neutral'>        // To prevent turning gas monitoring back on with nested functions that use this modifier,</span>
 449 |     | <span class='neutral'>        // we check if gasMetering started in the off position. If it did, we don&#39;t want to turn</span>
 450 |     | <span class='neutral'>        // it back on until we exit the top level function that used the modifier</span>
 451 |     | <span class='neutral'>        //</span>
 452 |     | <span class='neutral'>        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.</span>
 453 |     | <span class='neutral'>        // funcA will have `gasStartedOff` as false, funcB will have it as true,</span>
 454 |     | <span class='neutral'>        // so we only turn metering back on at the end of the funcA</span>
 455 |     | <span class='neutral'>        bool gasStartedOff = gasMeteringOff;</span>
 456 |     | <span class='neutral'>        gasMeteringOff = true;</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>        _;</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>        // if gas metering was on when this modifier was called, turn it back on at the end</span>
 461 |     | <span class='neutral'>        if (!gasStartedOff) {</span>
 462 |     | <span class='neutral'>            gasMeteringOff = false;</span>
 463 |     | <span class='neutral'>            vm.resumeGasMetering();</span>
 464 |     | <span class='neutral'>        }</span>
 465 |     | <span class='neutral'>    }</span>
 466 |     | <span class='neutral'>}</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 469 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 470 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 473 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 476 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 477 |     | <span class='neutral'>        vm.warp(block.timestamp + time);</span>
 478 |     | <span class='neutral'>    }</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 481 |     | <span class='neutral'>        vm.warp(block.timestamp - time);</span>
 482 |     | <span class='neutral'>    }</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 485 |     | <span class='neutral'>    function hoax(address who) internal virtual {</span>
 486 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 487 |     | <span class='neutral'>        vm.prank(who);</span>
 488 |     | <span class='neutral'>    }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>    function hoax(address who, uint256 give) internal virtual {</span>
 491 |     | <span class='neutral'>        vm.deal(who, give);</span>
 492 |     | <span class='neutral'>        vm.prank(who);</span>
 493 |     | <span class='neutral'>    }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>    function hoax(address who, address origin) internal virtual {</span>
 496 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 497 |     | <span class='neutral'>        vm.prank(who, origin);</span>
 498 |     | <span class='neutral'>    }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>    function hoax(address who, address origin, uint256 give) internal virtual {</span>
 501 |     | <span class='neutral'>        vm.deal(who, give);</span>
 502 |     | <span class='neutral'>        vm.prank(who, origin);</span>
 503 |     | <span class='neutral'>    }</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 506 |     | <span class='neutral'>    function startHoax(address who) internal virtual {</span>
 507 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 508 |     | <span class='neutral'>        vm.startPrank(who);</span>
 509 |     | <span class='neutral'>    }</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='neutral'>    function startHoax(address who, uint256 give) internal virtual {</span>
 512 |     | <span class='neutral'>        vm.deal(who, give);</span>
 513 |     | <span class='neutral'>        vm.startPrank(who);</span>
 514 |     | <span class='neutral'>    }</span>
 515 |     | <span class='neutral'></span>
 516 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 517 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 518 |     | <span class='neutral'>    function startHoax(address who, address origin) internal virtual {</span>
 519 |     | <span class='neutral'>        vm.deal(who, 1 &lt;&lt; 128);</span>
 520 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
 521 |     | <span class='neutral'>    }</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>    function startHoax(address who, address origin, uint256 give) internal virtual {</span>
 524 |     | <span class='neutral'>        vm.deal(who, give);</span>
 525 |     | <span class='neutral'>        vm.startPrank(who, origin);</span>
 526 |     | <span class='neutral'>    }</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>    function changePrank(address who) internal virtual {</span>
 529 |     | <span class='neutral'>        vm.stopPrank();</span>
 530 |     | <span class='neutral'>        vm.startPrank(who);</span>
 531 |     | <span class='neutral'>    }</span>
 532 |     | <span class='neutral'></span>
 533 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 534 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 535 |     | <span class='unexecuted'>    function deal(address to, uint256 give) internal virtual {</span>
 536 |     | <span class='unexecuted'>        vm.deal(to, give);</span>
 537 |     | <span class='neutral'>    }</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 540 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 541 |     | <span class='unexecuted'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 542 |     | <span class='unexecuted'>        deal(token, to, give, false);</span>
 543 |     | <span class='neutral'>    }</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='unexecuted'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 546 |     | <span class='neutral'>        // get current balance</span>
 547 |     | <span class='unexecuted'>        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));</span>
 548 |     | <span class='unexecuted'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='neutral'>        // update balance</span>
 551 |     | <span class='unexecuted'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>        // update total supply</span>
 554 |     | <span class='unexecuted'>        if (adjust) {</span>
 555 |     | <span class='unexecuted'>            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));</span>
 556 |     | <span class='unexecuted'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 557 |     | <span class='unexecuted'>            if (give &lt; prevBal) {</span>
 558 |     | <span class='unexecuted'>                totSup -= (prevBal - give);</span>
 559 |     | <span class='neutral'>            } else {</span>
 560 |     | <span class='unexecuted'>                totSup += (give - prevBal);</span>
 561 |     | <span class='neutral'>            }</span>
 562 |     | <span class='unexecuted'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 563 |     | <span class='neutral'>        }</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'>}</span>
 566 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>library stdError {</span>
  6 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;some_peth&quot;);</span>
  13 |     | <span class='neutral'>// json.parseUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;deploymentArtifact&quot;;</span>
  19 |     | <span class='neutral'>// Contract contract = new Contract();</span>
  20 |     | <span class='neutral'>// json.serialize(&quot;contractAddress&quot;, address(contract));</span>
  21 |     | <span class='neutral'>// json = json.serialize(&quot;deploymentTimes&quot;, uint(1));</span>
  22 |     | <span class='neutral'>// // store the stringified JSON to the &#39;json&#39; variable we have been using as a key</span>
  23 |     | <span class='neutral'>// // as we won&#39;t need it any longer</span>
  24 |     | <span class='neutral'>// string memory json2 = &quot;finalArtifact&quot;;</span>
  25 |     | <span class='neutral'>// string memory final = json2.serialize(&quot;depArtifact&quot;, json);</span>
  26 |     | <span class='neutral'>// final.write(&quot;&lt;some_path&gt;&quot;);</span>
  27 |     | <span class='neutral'>// ```</span>
  28 |     | <span class='unexecuted'></span>
  29 |     | <span class='neutral'>library stdJson {</span>
  30 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal pure returns (uint256) {</span>
  37 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (uint256));</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (uint256[]));</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal pure returns (int256) {</span>
  45 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (int256));</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (int256[]));</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes32));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes32[]));</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal pure returns (string memory) {</span>
  61 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (string));</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (string[]));</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal pure returns (address) {</span>
  69 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (address));</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (address[]));</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal pure returns (bool) {</span>
  77 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bool));</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bool[]));</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes));</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return abi.decode(vm.parseJson(json, key), (bytes[]));</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='unexecuted'></span>
  4 |     | <span class='neutral'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='unexecuted'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='unexecuted'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct StdStorage {</span>
   7 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; uint256))) slots;</span>
   8 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; bool))) finds;</span>
   9 |     | <span class='neutral'>    bytes32[] _keys;</span>
  10 |     | <span class='neutral'>    bytes4 _sig;</span>
  11 |     | <span class='neutral'>    uint256 _depth;</span>
  12 |     | <span class='neutral'>    address _target;</span>
  13 |     | <span class='neutral'>    bytes32 _set;</span>
  14 |     | <span class='neutral'>}</span>
  15 |     | <span class='unexecuted'></span>
  16 |     | <span class='neutral'>library stdStorageSafe {</span>
  17 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  18 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  23 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
  27 |     | <span class='neutral'>    // slot complexity:</span>
  28 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
  29 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
  30 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
  31 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
  32 |     | <span class='unexecuted'>    function find(StdStorage storage self) internal returns (uint256) {</span>
  33 |     | <span class='unexecuted'>        address who = self._target;</span>
  34 |     | <span class='unexecuted'>        bytes4 fsig = self._sig;</span>
  35 |     | <span class='unexecuted'>        uint256 field_depth = self._depth;</span>
  36 |     | <span class='unexecuted'>        bytes32[] memory ins = self._keys;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // calldata to test against</span>
  39 |     | <span class='unexecuted'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
  40 |     | <span class='unexecuted'>            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='unexecuted'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
  43 |     | <span class='unexecuted'>        vm.record();</span>
  44 |     | <span class='unexecuted'>        bytes32 fdat;</span>
  45 |     | <span class='neutral'>        {</span>
  46 |     | <span class='unexecuted'>            (, bytes memory rdat) = who.staticcall(cald);</span>
  47 |     | <span class='unexecuted'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
  51 |     | <span class='unexecuted'>        if (reads.length == 1) {</span>
  52 |     | <span class='unexecuted'>            bytes32 curr = vm.load(who, reads[0]);</span>
  53 |     | <span class='unexecuted'>            if (curr == bytes32(0)) {</span>
  54 |     | <span class='unexecuted'>                emit WARNING_UninitedSlot(who, uint256(reads[0]));</span>
  55 |     | <span class='neutral'>            }</span>
  56 |     | <span class='unexecuted'>            if (fdat != curr) {</span>
  57 |     | <span class='unexecuted'>                require(</span>
  58 |     | <span class='neutral'>                    false,</span>
  59 |     | <span class='neutral'>                    &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
  60 |     | <span class='neutral'>                );</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='unexecuted'>            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));</span>
  63 |     | <span class='unexecuted'>            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);</span>
  64 |     | <span class='unexecuted'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  65 |     | <span class='unexecuted'>        } else if (reads.length &gt; 1) {</span>
  66 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; reads.length; i++) {</span>
  67 |     | <span class='unexecuted'>                bytes32 prev = vm.load(who, reads[i]);</span>
  68 |     | <span class='unexecuted'>                if (prev == bytes32(0)) {</span>
  69 |     | <span class='unexecuted'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
  70 |     | <span class='neutral'>                }</span>
  71 |     | <span class='neutral'>                // store</span>
  72 |     | <span class='unexecuted'>                vm.store(who, reads[i], bytes32(hex&quot;1337&quot;));</span>
  73 |     | <span class='unexecuted'>                bool success;</span>
  74 |     | <span class='unexecuted'>                bytes memory rdat;</span>
  75 |     | <span class='neutral'>                {</span>
  76 |     | <span class='unexecuted'>                    (success, rdat) = who.staticcall(cald);</span>
  77 |     | <span class='unexecuted'>                    fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  78 |     | <span class='neutral'>                }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>                if (success &amp;&amp; fdat == bytes32(hex&quot;1337&quot;)) {</span>
  81 |     | <span class='neutral'>                    // we found which of the slots is the actual one</span>
  82 |     | <span class='unexecuted'>                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));</span>
  83 |     | <span class='unexecuted'>                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);</span>
  84 |     | <span class='unexecuted'>                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  85 |     | <span class='unexecuted'>                    vm.store(who, reads[i], prev);</span>
  86 |     | <span class='unexecuted'>                    break;</span>
  87 |     | <span class='neutral'>                }</span>
  88 |     | <span class='unexecuted'>                vm.store(who, reads[i], prev);</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='neutral'>        } else {</span>
  91 |     | <span class='unexecuted'>            require(false, &quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        require(</span>
  95 |     | <span class='unexecuted'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],</span>
  96 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        delete self._target;</span>
 100 |     | <span class='unexecuted'>        delete self._sig;</span>
 101 |     | <span class='unexecuted'>        delete self._keys;</span>
 102 |     | <span class='unexecuted'>        delete self._depth;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 108 |     | <span class='unexecuted'>        self._target = _target;</span>
 109 |     | <span class='neutral'>        return self;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 113 |     | <span class='unexecuted'>        self._sig = _sig;</span>
 114 |     | <span class='neutral'>        return self;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 118 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 119 |     | <span class='neutral'>        return self;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 123 |     | <span class='unexecuted'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 124 |     | <span class='neutral'>        return self;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 128 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 129 |     | <span class='neutral'>        return self;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 133 |     | <span class='neutral'>        self._keys.push(key);</span>
 134 |     | <span class='neutral'>        return self;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 138 |     | <span class='neutral'>        self._depth = _depth;</span>
 139 |     | <span class='neutral'>        return self;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 143 |     | <span class='neutral'>        address t = self._target;</span>
 144 |     | <span class='neutral'>        uint256 s = find(self);</span>
 145 |     | <span class='neutral'>        return abi.encode(vm.load(t, bytes32(s)));</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 149 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 153 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 154 |     | <span class='neutral'>        if (v == 0) return false;</span>
 155 |     | <span class='neutral'>        if (v == 1) return true;</span>
 156 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 160 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 164 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 168 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 172 |     | <span class='unexecuted'>        bytes32 out;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 175 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 176 |     | <span class='unexecuted'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        return out;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 182 |     | <span class='unexecuted'>        bytes memory result = new bytes(b.length * 32);</span>
 183 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 184 |     | <span class='unexecuted'>            bytes32 k = b[i];</span>
 185 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 186 |     | <span class='unexecuted'>            assembly {</span>
 187 |     | <span class='unexecuted'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 188 |     | <span class='neutral'>            }</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        return result;</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='unexecuted'></span>
 195 |     | <span class='neutral'>library stdStorage {</span>
 196 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 199 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 203 |     | <span class='unexecuted'>        return stdStorageSafe.find(self);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 207 |     | <span class='unexecuted'>        return stdStorageSafe.target(self, _target);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 211 |     | <span class='unexecuted'>        return stdStorageSafe.sig(self, _sig);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 215 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='unexecuted'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 219 |     | <span class='unexecuted'>        return stdStorageSafe.with_key(self, who);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 223 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 227 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 231 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 235 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 239 |     | <span class='unexecuted'>        checked_write(self, bytes32(amt));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 243 |     | <span class='neutral'>        bytes32 t;</span>
 244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 245 |     | <span class='neutral'>        assembly {</span>
 246 |     | <span class='neutral'>            t := write</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        checked_write(self, t);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 252 |     | <span class='unexecuted'>        address who = self._target;</span>
 253 |     | <span class='unexecuted'>        bytes4 fsig = self._sig;</span>
 254 |     | <span class='unexecuted'>        uint256 field_depth = self._depth;</span>
 255 |     | <span class='unexecuted'>        bytes32[] memory ins = self._keys;</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
 258 |     | <span class='unexecuted'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
 259 |     | <span class='unexecuted'>            find(self);</span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='unexecuted'>        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>        bytes32 fdat;</span>
 264 |     | <span class='neutral'>        {</span>
 265 |     | <span class='unexecuted'>            (, bytes memory rdat) = who.staticcall(cald);</span>
 266 |     | <span class='unexecuted'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='unexecuted'>        bytes32 curr = vm.load(who, slot);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        if (fdat != curr) {</span>
 271 |     | <span class='unexecuted'>            require(</span>
 272 |     | <span class='neutral'>                false,</span>
 273 |     | <span class='neutral'>                &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
 274 |     | <span class='neutral'>            );</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='unexecuted'>        vm.store(who, slot, set);</span>
 277 |     | <span class='unexecuted'>        delete self._target;</span>
 278 |     | <span class='unexecuted'>        delete self._sig;</span>
 279 |     | <span class='unexecuted'>        delete self._keys;</span>
 280 |     | <span class='unexecuted'>        delete self._depth;</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 284 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 288 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 292 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 296 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 300 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 304 |     | <span class='unexecuted'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 305 |     | <span class='unexecuted'>        bytes32 out;</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='unexecuted'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 308 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 309 |     | <span class='unexecuted'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='unexecuted'>        return out;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 315 |     | <span class='unexecuted'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 316 |     | <span class='unexecuted'>        bytes memory result = new bytes(b.length * 32);</span>
 317 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 318 |     | <span class='unexecuted'>            bytes32 k = b[i];</span>
 319 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 320 |     | <span class='unexecuted'>            assembly {</span>
 321 |     | <span class='unexecuted'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 322 |     | <span class='neutral'>            }</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='unexecuted'>        return result;</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'>}</span>
 328 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/StdUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// TODO Remove import.</span>
   5 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdUtils {</span>
   8 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   9 |     | <span class='unexecuted'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    uint256 private constant INT256_MIN_ABS =</span>
  12 |     | <span class='neutral'>        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  13 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  14 |     | <span class='unexecuted'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  17 |     | <span class='unexecuted'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
  18 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
  19 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
  20 |     | <span class='unexecuted'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>        uint256 size = max - min + 1;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
  25 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
  26 |     | <span class='unexecuted'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
  27 |     | <span class='unexecuted'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
  30 |     | <span class='unexecuted'>        if (x &gt; max) {</span>
  31 |     | <span class='unexecuted'>            uint256 diff = x - max;</span>
  32 |     | <span class='unexecuted'>            uint256 rem = diff % size;</span>
  33 |     | <span class='unexecuted'>            if (rem == 0) return max;</span>
  34 |     | <span class='unexecuted'>            result = min + rem - 1;</span>
  35 |     | <span class='unexecuted'>        } else if (x &lt; min) {</span>
  36 |     | <span class='unexecuted'>            uint256 diff = min - x;</span>
  37 |     | <span class='unexecuted'>            uint256 rem = diff % size;</span>
  38 |     | <span class='unexecuted'>            if (rem == 0) return min;</span>
  39 |     | <span class='unexecuted'>            result = max - rem + 1;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {</span>
  44 |     | <span class='unexecuted'>        result = _bound(x, min, max);</span>
  45 |     | <span class='unexecuted'>        console2_log(&quot;Bound Result&quot;, result);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {</span>
  49 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(int256,int256,int256): Max is less than min.&quot;);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:</span>
  52 |     | <span class='neutral'>        // int256 : -(2**255) ~ (2**255 - 1)</span>
  53 |     | <span class='neutral'>        // uint256:     0     ~ (2**256 - 1)</span>
  54 |     | <span class='neutral'>        // So, add 2**255, INT256_MIN_ABS to the integer values.</span>
  55 |     | <span class='neutral'>        //</span>
  56 |     | <span class='neutral'>        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.</span>
  57 |     | <span class='neutral'>        // So, use `~uint256(x) + 1` instead.</span>
  58 |     | <span class='neutral'>        uint256 _x = x &lt; 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);</span>
  59 |     | <span class='neutral'>        uint256 _min = min &lt; 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);</span>
  60 |     | <span class='neutral'>        uint256 _max = max &lt; 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        uint256 y = _bound(_x, _min, _max);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // To move it back to int256 value, subtract INT256_MIN_ABS at here.</span>
  65 |     | <span class='neutral'>        result = y &lt; INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);</span>
  66 |     | <span class='neutral'>        console2_log(&quot;Bound result&quot;, vm.toString(result));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
  70 |     | <span class='neutral'>    /// @notice adapated from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
  71 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
  72 |     | <span class='neutral'>        // forgefmt: disable-start</span>
  73 |     | <span class='neutral'>        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.</span>
  74 |     | <span class='neutral'>        // A one byte integer uses its own value as its length prefix, there is no additional &quot;0x80 + length&quot; prefix that comes before it.</span>
  75 |     | <span class='neutral'>        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));</span>
  76 |     | <span class='neutral'>        if (nonce &lt;= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.</span>
  79 |     | <span class='neutral'>        if (nonce &lt;= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));</span>
  80 |     | <span class='neutral'>        if (nonce &lt;= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));</span>
  81 |     | <span class='neutral'>        if (nonce &lt;= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));</span>
  82 |     | <span class='neutral'>        // forgefmt: disable-end</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp</span>
  85 |     | <span class='neutral'>        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)</span>
  86 |     | <span class='neutral'>        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)</span>
  87 |     | <span class='neutral'>        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)</span>
  88 |     | <span class='neutral'>        // We assume nobody can have a nonce large enough to require more than 32 bytes.</span>
  89 |     | <span class='neutral'>        return addressFromLast20Bytes(</span>
  90 |     | <span class='neutral'>            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))</span>
  91 |     | <span class='neutral'>        );</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
  95 |     | <span class='neutral'>        internal</span>
  96 |     | <span class='neutral'>        pure</span>
  97 |     | <span class='neutral'>        virtual</span>
  98 |     | <span class='neutral'>        returns (address)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
 104 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 105 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 109 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function console2_log(string memory p0, uint256 p1) private view {</span>
 115 |     | <span class='unexecuted'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
 116 |     | <span class='neutral'>        status;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function console2_log(string memory p0, string memory p1) private view {</span>
 120 |     | <span class='neutral'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
 121 |     | <span class='neutral'>        status;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'>}</span>
 124 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// 💬 ABOUT</span>
  5 |     | <span class='neutral'>// Standard Library&#39;s default Test</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// 🧩 MODULES</span>
  8 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
  9 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 10 |     | <span class='neutral'>import {StdAssertions} from &quot;./StdAssertions.sol&quot;;</span>
 11 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 12 |     | <span class='neutral'>import {StdCheats} from &quot;./StdCheats.sol&quot;;</span>
 13 |     | <span class='neutral'>import {stdError} from &quot;./StdError.sol&quot;;</span>
 14 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 15 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 16 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
 17 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 18 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>// 📦 BOILERPLATE</span>
 21 |     | <span class='neutral'>import {TestBase} from &quot;./Base.sol&quot;;</span>
 22 |     | <span class='neutral'>import {DSTest} from &quot;ds-test/test.sol&quot;;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>// ⭐️ TEST</span>
 25 |     | <span class='neutral'>abstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdUtils, TestBase {</span>
 26 |     | <span class='neutral'>// Note: IS_TEST() must return true.</span>
 27 |     | <span class='neutral'>// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/Vm.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Cheatcodes are marked as view/pure/none using the following rules:</span>
   7 |     | <span class='neutral'>// 0. A call&#39;s observable behaviour includes its return value, logs, reverts and state writes,</span>
   8 |     | <span class='neutral'>// 1. If you can influence a later call&#39;s observable behaviour, you&#39;re neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),</span>
   9 |     | <span class='neutral'>// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you&#39;re `view`,</span>
  10 |     | <span class='neutral'>// 3. Otherwise you&#39;re `pure`.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>interface VmSafe {</span>
  13 |     | <span class='neutral'>    struct Log {</span>
  14 |     | <span class='neutral'>        bytes32[] topics;</span>
  15 |     | <span class='neutral'>        bytes data;</span>
  16 |     | <span class='neutral'>        address emitter;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct Rpc {</span>
  20 |     | <span class='neutral'>        string key;</span>
  21 |     | <span class='neutral'>        string url;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct FsMetadata {</span>
  25 |     | <span class='neutral'>        bool isDir;</span>
  26 |     | <span class='neutral'>        bool isSymlink;</span>
  27 |     | <span class='neutral'>        uint256 length;</span>
  28 |     | <span class='neutral'>        bool readOnly;</span>
  29 |     | <span class='neutral'>        uint256 modified;</span>
  30 |     | <span class='neutral'>        uint256 accessed;</span>
  31 |     | <span class='neutral'>        uint256 created;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
  35 |     | <span class='neutral'>    function load(address target, bytes32 slot) external view returns (bytes32 data);</span>
  36 |     | <span class='neutral'>    // Signs data</span>
  37 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  38 |     | <span class='neutral'>    // Gets the address for a given private key</span>
  39 |     | <span class='neutral'>    function addr(uint256 privateKey) external pure returns (address addr);</span>
  40 |     | <span class='neutral'>    // Gets the nonce of an account</span>
  41 |     | <span class='neutral'>    function getNonce(address account) external view returns (uint64 nonce);</span>
  42 |     | <span class='neutral'>    // Performs a foreign function call via the terminal</span>
  43 |     | <span class='neutral'>    function ffi(string[] calldata commandInput) external returns (bytes memory result);</span>
  44 |     | <span class='neutral'>    // Sets environment variables</span>
  45 |     | <span class='neutral'>    function setEnv(string calldata name, string calldata value) external;</span>
  46 |     | <span class='neutral'>    // Reads environment variables, (name) =&gt; (value)</span>
  47 |     | <span class='neutral'>    function envBool(string calldata name) external view returns (bool value);</span>
  48 |     | <span class='neutral'>    function envUint(string calldata name) external view returns (uint256 value);</span>
  49 |     | <span class='neutral'>    function envInt(string calldata name) external view returns (int256 value);</span>
  50 |     | <span class='neutral'>    function envAddress(string calldata name) external view returns (address value);</span>
  51 |     | <span class='neutral'>    function envBytes32(string calldata name) external view returns (bytes32 value);</span>
  52 |     | <span class='neutral'>    function envString(string calldata name) external view returns (string memory value);</span>
  53 |     | <span class='neutral'>    function envBytes(string calldata name) external view returns (bytes memory value);</span>
  54 |     | <span class='neutral'>    // Reads environment variables as arrays</span>
  55 |     | <span class='neutral'>    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);</span>
  56 |     | <span class='neutral'>    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);</span>
  57 |     | <span class='neutral'>    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);</span>
  58 |     | <span class='neutral'>    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);</span>
  59 |     | <span class='neutral'>    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);</span>
  60 |     | <span class='neutral'>    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);</span>
  61 |     | <span class='neutral'>    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);</span>
  62 |     | <span class='neutral'>    // Read environment variables with default value</span>
  63 |     | <span class='neutral'>    function envOr(string calldata name, bool defaultValue) external returns (bool value);</span>
  64 |     | <span class='neutral'>    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);</span>
  65 |     | <span class='neutral'>    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);</span>
  66 |     | <span class='neutral'>    function envOr(string calldata name, address defaultValue) external returns (address value);</span>
  67 |     | <span class='neutral'>    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);</span>
  68 |     | <span class='neutral'>    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);</span>
  69 |     | <span class='neutral'>    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);</span>
  70 |     | <span class='neutral'>    // Read environment variables as arrays with default value</span>
  71 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)</span>
  72 |     | <span class='neutral'>        external</span>
  73 |     | <span class='neutral'>        returns (bool[] memory value);</span>
  74 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)</span>
  75 |     | <span class='neutral'>        external</span>
  76 |     | <span class='neutral'>        returns (uint256[] memory value);</span>
  77 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)</span>
  78 |     | <span class='neutral'>        external</span>
  79 |     | <span class='neutral'>        returns (int256[] memory value);</span>
  80 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)</span>
  81 |     | <span class='neutral'>        external</span>
  82 |     | <span class='neutral'>        returns (address[] memory value);</span>
  83 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)</span>
  84 |     | <span class='neutral'>        external</span>
  85 |     | <span class='neutral'>        returns (bytes32[] memory value);</span>
  86 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)</span>
  87 |     | <span class='neutral'>        external</span>
  88 |     | <span class='neutral'>        returns (string[] memory value);</span>
  89 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)</span>
  90 |     | <span class='neutral'>        external</span>
  91 |     | <span class='neutral'>        returns (bytes[] memory value);</span>
  92 |     | <span class='neutral'>    // Records all storage reads and writes</span>
  93 |     | <span class='neutral'>    function record() external;</span>
  94 |     | <span class='neutral'>    // Gets all accessed reads and write slot from a recording session, for a given address</span>
  95 |     | <span class='neutral'>    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);</span>
  96 |     | <span class='neutral'>    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  97 |     | <span class='neutral'>    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);</span>
  98 |     | <span class='neutral'>    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  99 |     | <span class='neutral'>    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);</span>
 100 |     | <span class='neutral'>    // Labels an address in call traces</span>
 101 |     | <span class='neutral'>    function label(address account, string calldata newLabel) external;</span>
 102 |     | <span class='neutral'>    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain</span>
 103 |     | <span class='neutral'>    function broadcast() external;</span>
 104 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain</span>
 105 |     | <span class='neutral'>    function broadcast(address signer) external;</span>
 106 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain</span>
 107 |     | <span class='neutral'>    function broadcast(uint256 privateKey) external;</span>
 108 |     | <span class='neutral'>    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain</span>
 109 |     | <span class='neutral'>    function startBroadcast() external;</span>
 110 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain</span>
 111 |     | <span class='neutral'>    function startBroadcast(address signer) external;</span>
 112 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain</span>
 113 |     | <span class='neutral'>    function startBroadcast(uint256 privateKey) external;</span>
 114 |     | <span class='neutral'>    // Stops collecting onchain transactions</span>
 115 |     | <span class='neutral'>    function stopBroadcast() external;</span>
 116 |     | <span class='neutral'>    // Reads the entire content of file to string</span>
 117 |     | <span class='neutral'>    function readFile(string calldata path) external view returns (string memory data);</span>
 118 |     | <span class='neutral'>    // Reads the entire content of file as binary. Path is relative to the project root.</span>
 119 |     | <span class='neutral'>    function readFileBinary(string calldata path) external view returns (bytes memory data);</span>
 120 |     | <span class='neutral'>    // Get the path of the current project root</span>
 121 |     | <span class='neutral'>    function projectRoot() external view returns (string memory path);</span>
 122 |     | <span class='neutral'>    // Get the metadata for a file/directory</span>
 123 |     | <span class='neutral'>    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);</span>
 124 |     | <span class='neutral'>    // Reads next line of file to string</span>
 125 |     | <span class='neutral'>    function readLine(string calldata path) external view returns (string memory line);</span>
 126 |     | <span class='neutral'>    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
 127 |     | <span class='neutral'>    function writeFile(string calldata path, string calldata data) external;</span>
 128 |     | <span class='neutral'>    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
 129 |     | <span class='neutral'>    // Path is relative to the project root.</span>
 130 |     | <span class='neutral'>    function writeFileBinary(string calldata path, bytes calldata data) external;</span>
 131 |     | <span class='neutral'>    // Writes line to file, creating a file if it does not exist.</span>
 132 |     | <span class='neutral'>    function writeLine(string calldata path, string calldata data) external;</span>
 133 |     | <span class='neutral'>    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
 134 |     | <span class='neutral'>    function closeFile(string calldata path) external;</span>
 135 |     | <span class='neutral'>    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
 136 |     | <span class='neutral'>    // - Path points to a directory.</span>
 137 |     | <span class='neutral'>    // - The file doesn&#39;t exist.</span>
 138 |     | <span class='neutral'>    // - The user lacks permissions to remove the file.</span>
 139 |     | <span class='neutral'>    function removeFile(string calldata path) external;</span>
 140 |     | <span class='neutral'>    // Convert values to a string</span>
 141 |     | <span class='neutral'>    function toString(address value) external pure returns (string memory stringifiedValue);</span>
 142 |     | <span class='neutral'>    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);</span>
 143 |     | <span class='neutral'>    function toString(bytes32 value) external pure returns (string memory stringifiedValue);</span>
 144 |     | <span class='neutral'>    function toString(bool value) external pure returns (string memory stringifiedValue);</span>
 145 |     | <span class='neutral'>    function toString(uint256 value) external pure returns (string memory stringifiedValue);</span>
 146 |     | <span class='neutral'>    function toString(int256 value) external pure returns (string memory stringifiedValue);</span>
 147 |     | <span class='neutral'>    // Convert values from a string</span>
 148 |     | <span class='neutral'>    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);</span>
 149 |     | <span class='neutral'>    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);</span>
 150 |     | <span class='neutral'>    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);</span>
 151 |     | <span class='neutral'>    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);</span>
 152 |     | <span class='neutral'>    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);</span>
 153 |     | <span class='neutral'>    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);</span>
 154 |     | <span class='neutral'>    // Record all the transaction logs</span>
 155 |     | <span class='neutral'>    function recordLogs() external;</span>
 156 |     | <span class='neutral'>    // Gets all the recorded logs</span>
 157 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory logs);</span>
 158 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44&#39;/60&#39;/0&#39;/0/{index}</span>
 159 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);</span>
 160 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}</span>
 161 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)</span>
 162 |     | <span class='neutral'>        external</span>
 163 |     | <span class='neutral'>        pure</span>
 164 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 165 |     | <span class='neutral'>    // Adds a private key to the local forge wallet and returns the address</span>
 166 |     | <span class='neutral'>    function rememberKey(uint256 privateKey) external returns (address addr);</span>
 167 |     | <span class='neutral'>    //</span>
 168 |     | <span class='neutral'>    // parseJson</span>
 169 |     | <span class='neutral'>    //</span>
 170 |     | <span class='neutral'>    // ----</span>
 171 |     | <span class='neutral'>    // In case the returned value is a JSON object, it&#39;s encoded as a ABI-encoded tuple. As JSON objects</span>
 172 |     | <span class='neutral'>    // don&#39;t have the notion of ordered, but tuples do, they JSON object is encoded with it&#39;s fields ordered in</span>
 173 |     | <span class='neutral'>    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that</span>
 174 |     | <span class='neutral'>    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded</span>
 175 |     | <span class='neutral'>    // as tuples, with the attributes in the order in which they are defined.</span>
 176 |     | <span class='neutral'>    // For example: json = { &#39;a&#39;: 1, &#39;b&#39;: 0xa4tb......3xs}</span>
 177 |     | <span class='neutral'>    // a: uint256</span>
 178 |     | <span class='neutral'>    // b: address</span>
 179 |     | <span class='neutral'>    // To decode that json, we need to define a struct or a tuple as follows:</span>
 180 |     | <span class='neutral'>    // struct json = { uint256 a; address b; }</span>
 181 |     | <span class='neutral'>    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to</span>
 182 |     | <span class='neutral'>    // decode the tuple in that order, and thus fail.</span>
 183 |     | <span class='neutral'>    // ----</span>
 184 |     | <span class='neutral'>    // Given a string of JSON, return it as ABI-encoded</span>
 185 |     | <span class='neutral'>    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 186 |     | <span class='neutral'>    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file</span>
 189 |     | <span class='neutral'>    // It returns the stringified version of the specific JSON file up to that moment.</span>
 190 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)</span>
 191 |     | <span class='neutral'>        external</span>
 192 |     | <span class='neutral'>        returns (string memory json);</span>
 193 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)</span>
 194 |     | <span class='neutral'>        external</span>
 195 |     | <span class='neutral'>        returns (string memory json);</span>
 196 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)</span>
 197 |     | <span class='neutral'>        external</span>
 198 |     | <span class='neutral'>        returns (string memory json);</span>
 199 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)</span>
 200 |     | <span class='neutral'>        external</span>
 201 |     | <span class='neutral'>        returns (string memory json);</span>
 202 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)</span>
 203 |     | <span class='neutral'>        external</span>
 204 |     | <span class='neutral'>        returns (string memory json);</span>
 205 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)</span>
 206 |     | <span class='neutral'>        external</span>
 207 |     | <span class='neutral'>        returns (string memory json);</span>
 208 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)</span>
 209 |     | <span class='neutral'>        external</span>
 210 |     | <span class='neutral'>        returns (string memory json);</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)</span>
 213 |     | <span class='neutral'>        external</span>
 214 |     | <span class='neutral'>        returns (string memory json);</span>
 215 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)</span>
 216 |     | <span class='neutral'>        external</span>
 217 |     | <span class='neutral'>        returns (string memory json);</span>
 218 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)</span>
 219 |     | <span class='neutral'>        external</span>
 220 |     | <span class='neutral'>        returns (string memory json);</span>
 221 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)</span>
 222 |     | <span class='neutral'>        external</span>
 223 |     | <span class='neutral'>        returns (string memory json);</span>
 224 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)</span>
 225 |     | <span class='neutral'>        external</span>
 226 |     | <span class='neutral'>        returns (string memory json);</span>
 227 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)</span>
 228 |     | <span class='neutral'>        external</span>
 229 |     | <span class='neutral'>        returns (string memory json);</span>
 230 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)</span>
 231 |     | <span class='neutral'>        external</span>
 232 |     | <span class='neutral'>        returns (string memory json);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    //</span>
 235 |     | <span class='neutral'>    // writeJson</span>
 236 |     | <span class='neutral'>    //</span>
 237 |     | <span class='neutral'>    // ----</span>
 238 |     | <span class='neutral'>    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
 239 |     | <span class='neutral'>    // Let&#39;s assume we want to write the following JSON to a file:</span>
 240 |     | <span class='neutral'>    //</span>
 241 |     | <span class='neutral'>    // { &quot;boolean&quot;: true, &quot;number&quot;: 342, &quot;object&quot;: { &quot;title&quot;: &quot;finally json serialization&quot; } }</span>
 242 |     | <span class='neutral'>    //</span>
 243 |     | <span class='neutral'>    // ```</span>
 244 |     | <span class='neutral'>    //  string memory json1 = &quot;some key&quot;;</span>
 245 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;boolean&quot;, true);</span>
 246 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;number&quot;, uint256(342));</span>
 247 |     | <span class='neutral'>    //  json2 = &quot;some other key&quot;;</span>
 248 |     | <span class='neutral'>    //  string memory output = vm.serializeString(json2, &quot;title&quot;, &quot;finally json serialization&quot;);</span>
 249 |     | <span class='neutral'>    //  string memory finalJson = vm.serialize(json1, &quot;object&quot;, output);</span>
 250 |     | <span class='neutral'>    //  vm.writeJson(finalJson, &quot;./output/example.json&quot;);</span>
 251 |     | <span class='neutral'>    // ```</span>
 252 |     | <span class='neutral'>    // The critical insight is that every invocation of serialization will return the stringified version of the JSON</span>
 253 |     | <span class='neutral'>    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version</span>
 254 |     | <span class='neutral'>    // to serialize them as values to another JSON object.</span>
 255 |     | <span class='neutral'>    //</span>
 256 |     | <span class='neutral'>    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)</span>
 257 |     | <span class='neutral'>    // will find the object in-memory that is keyed by &quot;some key&quot;.</span>
 258 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path) external;</span>
 259 |     | <span class='neutral'>    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key&gt;</span>
 260 |     | <span class='neutral'>    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing</span>
 261 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;</span>
 262 |     | <span class='neutral'>    // Returns the RPC url for the given alias</span>
 263 |     | <span class='neutral'>    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);</span>
 264 |     | <span class='neutral'>    // Returns all rpc urls and their aliases `[alias, url][]`</span>
 265 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory urls);</span>
 266 |     | <span class='neutral'>    // Returns all rpc urls and their aliases as structs.</span>
 267 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory urls);</span>
 268 |     | <span class='neutral'>    // If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 269 |     | <span class='neutral'>    function assume(bool condition) external pure;</span>
 270 |     | <span class='neutral'>    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.</span>
 271 |     | <span class='neutral'>    function pauseGasMetering() external;</span>
 272 |     | <span class='neutral'>    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.</span>
 273 |     | <span class='neutral'>    function resumeGasMetering() external;</span>
 274 |     | <span class='neutral'>}</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 277 |     | <span class='neutral'>    // Sets block.timestamp</span>
 278 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
 279 |     | <span class='neutral'>    // Sets block.height</span>
 280 |     | <span class='neutral'>    function roll(uint256 newHeight) external;</span>
 281 |     | <span class='neutral'>    // Sets block.basefee</span>
 282 |     | <span class='neutral'>    function fee(uint256 newBasefee) external;</span>
 283 |     | <span class='neutral'>    // Sets block.difficulty</span>
 284 |     | <span class='neutral'>    function difficulty(uint256 newDifficulty) external;</span>
 285 |     | <span class='neutral'>    // Sets block.chainid</span>
 286 |     | <span class='neutral'>    function chainId(uint256 newChainId) external;</span>
 287 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot.</span>
 288 |     | <span class='neutral'>    function store(address target, bytes32 slot, bytes32 value) external;</span>
 289 |     | <span class='neutral'>    // Sets the nonce of an account; must be higher than the current nonce of the account</span>
 290 |     | <span class='neutral'>    function setNonce(address account, uint64 newNonce) external;</span>
 291 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address</span>
 292 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
 293 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called</span>
 294 |     | <span class='neutral'>    function startPrank(address msgSender) external;</span>
 295 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address, and the tx.origin to be the second input</span>
 296 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin) external;</span>
 297 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input</span>
 298 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin) external;</span>
 299 |     | <span class='neutral'>    // Resets subsequent calls&#39; msg.sender to be `address(this)`</span>
 300 |     | <span class='neutral'>    function stopPrank() external;</span>
 301 |     | <span class='neutral'>    // Sets an address&#39; balance</span>
 302 |     | <span class='neutral'>    function deal(address account, uint256 newBalance) external;</span>
 303 |     | <span class='neutral'>    // Sets an address&#39; code</span>
 304 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 305 |     | <span class='neutral'>    // Expects an error on next call</span>
 306 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData) external;</span>
 307 |     | <span class='neutral'>    function expectRevert(bytes4 revertData) external;</span>
 308 |     | <span class='neutral'>    function expectRevert() external;</span>
 309 |     | <span class='neutral'>    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).</span>
 310 |     | <span class='neutral'>    // Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 311 |     | <span class='neutral'>    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)</span>
 312 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;</span>
 313 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)</span>
 314 |     | <span class='neutral'>        external;</span>
 315 |     | <span class='neutral'>    // Mocks a call to an address, returning specified data.</span>
 316 |     | <span class='neutral'>    // Calldata can either be strict or a partial match, e.g. if you only</span>
 317 |     | <span class='neutral'>    // pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 318 |     | <span class='neutral'>    // function will be mocked.</span>
 319 |     | <span class='neutral'>    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;</span>
 320 |     | <span class='neutral'>    // Mocks a call to an address with a specific msg.value, returning specified data.</span>
 321 |     | <span class='neutral'>    // Calldata match takes precedence over msg.value in case of ambiguity.</span>
 322 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;</span>
 323 |     | <span class='neutral'>    // Clears all mocked calls</span>
 324 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 325 |     | <span class='neutral'>    // Expects a call to an address with the specified calldata.</span>
 326 |     | <span class='neutral'>    // Calldata can either be a strict or a partial match</span>
 327 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data) external;</span>
 328 |     | <span class='neutral'>    // Expects a call to an address with the specified msg.value and calldata</span>
 329 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;</span>
 330 |     | <span class='neutral'>    // Sets block.coinbase</span>
 331 |     | <span class='neutral'>    function coinbase(address newCoinbase) external;</span>
 332 |     | <span class='neutral'>    // Snapshot the current state of the evm.</span>
 333 |     | <span class='neutral'>    // Returns the id of the snapshot that was created.</span>
 334 |     | <span class='neutral'>    // To revert a snapshot use `revertTo`</span>
 335 |     | <span class='neutral'>    function snapshot() external returns (uint256 snapshotId);</span>
 336 |     | <span class='neutral'>    // Revert the state of the EVM to a previous snapshot</span>
 337 |     | <span class='neutral'>    // Takes the snapshot id to revert to.</span>
 338 |     | <span class='neutral'>    // This deletes the snapshot and all snapshots taken after the given snapshot id.</span>
 339 |     | <span class='neutral'>    function revertTo(uint256 snapshotId) external returns (bool success);</span>
 340 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and block and returns the identifier of the fork</span>
 341 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 342 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork</span>
 343 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 344 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,</span>
 345 |     | <span class='neutral'>    // and returns the identifier of the fork</span>
 346 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 347 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork</span>
 348 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 349 |     | <span class='neutral'>    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before</span>
 350 |     | <span class='neutral'>    // the transaction, returns the identifier of the fork</span>
 351 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 352 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 353 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 354 |     | <span class='neutral'>    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 355 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 356 |     | <span class='neutral'>    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.</span>
 357 |     | <span class='neutral'>    function activeFork() external view returns (uint256 forkId);</span>
 358 |     | <span class='neutral'>    // Updates the currently active fork to given block number</span>
 359 |     | <span class='neutral'>    // This is similar to `roll` but for the currently active fork</span>
 360 |     | <span class='neutral'>    function rollFork(uint256 blockNumber) external;</span>
 361 |     | <span class='neutral'>    // Updates the currently active fork to given transaction</span>
 362 |     | <span class='neutral'>    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block</span>
 363 |     | <span class='neutral'>    function rollFork(bytes32 txHash) external;</span>
 364 |     | <span class='neutral'>    // Updates the given fork to given block number</span>
 365 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 366 |     | <span class='neutral'>    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block</span>
 367 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 txHash) external;</span>
 368 |     | <span class='neutral'>    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 369 |     | <span class='neutral'>    // Meaning, changes made to the state of this account will be kept when switching forks</span>
 370 |     | <span class='neutral'>    function makePersistent(address account) external;</span>
 371 |     | <span class='neutral'>    function makePersistent(address account0, address account1) external;</span>
 372 |     | <span class='neutral'>    function makePersistent(address account0, address account1, address account2) external;</span>
 373 |     | <span class='neutral'>    function makePersistent(address[] calldata accounts) external;</span>
 374 |     | <span class='neutral'>    // Revokes persistent status from the address, previously added via `makePersistent`</span>
 375 |     | <span class='neutral'>    function revokePersistent(address account) external;</span>
 376 |     | <span class='neutral'>    function revokePersistent(address[] calldata accounts) external;</span>
 377 |     | <span class='neutral'>    // Returns true if the account is marked as persistent</span>
 378 |     | <span class='neutral'>    function isPersistent(address account) external view returns (bool persistent);</span>
 379 |     | <span class='neutral'>    // In forking mode, explicitly grant the given address cheatcode access</span>
 380 |     | <span class='neutral'>    function allowCheatcodes(address account) external;</span>
 381 |     | <span class='neutral'>    // Fetches the given transaction from the active fork and executes it on the current state</span>
 382 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 383 |     | <span class='neutral'>    // Fetches the given transaction from the given fork and executes it on the current state</span>
 384 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 385 |     | <span class='neutral'>}</span>
 386 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='unexecuted'></span>
    4 |     | <span class='neutral'>library console {</span>
    5 |     | <span class='unexecuted'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='unexecuted'>    function _sendLogPayload(bytes memory payload) private view {</span>
    8 |     | <span class='unexecuted'>        uint256 payloadLength = payload.length;</span>
    9 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='unexecuted'>        assembly {</span>
   12 |     | <span class='unexecuted'>            let payloadStart := add(payload, 32)</span>
   13 |     | <span class='unexecuted'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   14 |     | <span class='neutral'>        }</span>
   15 |     | <span class='neutral'>    }</span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='neutral'>    function log() internal view {</span>
   18 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   19 |     | <span class='neutral'>    }</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    function logInt(int p0) internal view {</span>
   22 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function logUint(uint p0) internal view {</span>
   26 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   34 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function log(uint p0) internal view {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(uint p0, uint p1) internal view {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal view {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(uint p0, bool p1) internal view {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(uint p0, address p1) internal view {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='unexecuted'>    function log(string memory p0, uint p1) internal view {</span>
  206 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(bool p0, uint p1) internal view {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(address p0, uint p1) internal view {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2) internal view {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal view {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal view {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal view {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal view {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal view {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal view {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal view {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal view {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal view {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal view {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal view {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal view {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal view {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal view {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal view {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2) internal view {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal view {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal view {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal view {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal view {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal view {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal view {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal view {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal view {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal view {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal view {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal view {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal view {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal view {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal view {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal view {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal view {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal view {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal view {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal view {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal view {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal view {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal view {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal view {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal view {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal view {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal view {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal view {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal view {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal view {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal view {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal view {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal view {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal view {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal view {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal view {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal view {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal view {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal view {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal view {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal view {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal view {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal view {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal view {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal view {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal view {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal view {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal view {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal view {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal view {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal view {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal view {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal view {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal view {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal view {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal view {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal view {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal view {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal view {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal view {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal view {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal view {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal view {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal view {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal view {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal view {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal view {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal view {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal view {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal view {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal view {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal view {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal view {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal view {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal view {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal view {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal view {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal view {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal view {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal view {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal view {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal view {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal view {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal view {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal view {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal view {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal view {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal view {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal view {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal view {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal view {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal view {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal view {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal view {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal view {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal view {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal view {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal view {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal view {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal view {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal view {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal view {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal view {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal view {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal view {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal view {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal view {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal view {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal view {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal view {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal view {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal view {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal view {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal view {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal view {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal view {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal view {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal view {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal view {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal view {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal view {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal view {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal view {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal view {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal view {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal view {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal view {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal view {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal view {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal view {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal view {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal view {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal view {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal view {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal view {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal view {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal view {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal view {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal view {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal view {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal view {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal view {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal view {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal view {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal view {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal view {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal view {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal view {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal view {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal view {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal view {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal view {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal view {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal view {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal view {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal view {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal view {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal view {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal view {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal view {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal view {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal view {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal view {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal view {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal view {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal view {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal view {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal view {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal view {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal view {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal view {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/forge-std/src/console2.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should</span>
    5 |     | <span class='neutral'>/// use `int256` and `uint256`. This modified version fixes that. This version is recommended</span>
    6 |     | <span class='neutral'>/// over `console.sol` if you don&#39;t need compatibility with Hardhat as the logs will show up in</span>
    7 |     | <span class='neutral'>/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.</span>
    8 |     | <span class='unexecuted'>/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178</span>
    9 |     | <span class='neutral'>library console2 {</span>
   10 |     | <span class='unexecuted'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
   11 |     | <span class='neutral'></span>
   12 |     | <span class='unexecuted'>    function _sendLogPayload(bytes memory payload) private view {</span>
   13 |     | <span class='unexecuted'>        uint256 payloadLength = payload.length;</span>
   14 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   15 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   16 |     | <span class='unexecuted'>        assembly {</span>
   17 |     | <span class='unexecuted'>            let payloadStart := add(payload, 32)</span>
   18 |     | <span class='unexecuted'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   19 |     | <span class='neutral'>        }</span>
   20 |     | <span class='neutral'>    }</span>
   21 |     | <span class='neutral'></span>
   22 |     | <span class='neutral'>    function log() internal view {</span>
   23 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   24 |     | <span class='neutral'>    }</span>
   25 |     | <span class='neutral'></span>
   26 |     | <span class='neutral'>    function logInt(int256 p0) internal view {</span>
   27 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   28 |     | <span class='neutral'>    }</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    function logUint(uint256 p0) internal view {</span>
   31 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   32 |     | <span class='neutral'>    }</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   35 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   36 |     | <span class='neutral'>    }</span>
   37 |     | <span class='neutral'></span>
   38 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   39 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   40 |     | <span class='neutral'>    }</span>
   41 |     | <span class='neutral'></span>
   42 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   43 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   44 |     | <span class='neutral'>    }</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   47 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   48 |     | <span class='neutral'>    }</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   51 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   52 |     | <span class='neutral'>    }</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   55 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   56 |     | <span class='neutral'>    }</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   59 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   60 |     | <span class='neutral'>    }</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   63 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   64 |     | <span class='neutral'>    }</span>
   65 |     | <span class='neutral'></span>
   66 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   67 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   68 |     | <span class='neutral'>    }</span>
   69 |     | <span class='neutral'></span>
   70 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   71 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   75 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   76 |     | <span class='neutral'>    }</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   79 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   80 |     | <span class='neutral'>    }</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   83 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   84 |     | <span class='neutral'>    }</span>
   85 |     | <span class='neutral'></span>
   86 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   87 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   88 |     | <span class='neutral'>    }</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   91 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   92 |     | <span class='neutral'>    }</span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   95 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   99 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  100 |     | <span class='neutral'>    }</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
  103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  104 |     | <span class='neutral'>    }</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  108 |     | <span class='neutral'>    }</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  112 |     | <span class='neutral'>    }</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  116 |     | <span class='neutral'>    }</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  120 |     | <span class='neutral'>    }</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  124 |     | <span class='neutral'>    }</span>
  125 |     | <span class='neutral'></span>
  126 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  128 |     | <span class='neutral'>    }</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  132 |     | <span class='neutral'>    }</span>
  133 |     | <span class='neutral'></span>
  134 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  140 |     | <span class='neutral'>    }</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  144 |     | <span class='neutral'>    }</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  148 |     | <span class='neutral'>    }</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  160 |     | <span class='neutral'>    }</span>
  161 |     | <span class='neutral'></span>
  162 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  164 |     | <span class='neutral'>    }</span>
  165 |     | <span class='neutral'></span>
  166 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  172 |     | <span class='neutral'>    }</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  176 |     | <span class='neutral'>    }</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>    function log(uint256 p0) internal view {</span>
  179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  180 |     | <span class='neutral'>    }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='neutral'>    function log(int256 p0) internal view {</span>
  183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
  184 |     | <span class='neutral'>    }</span>
  185 |     | <span class='neutral'></span>
  186 |     | <span class='unexecuted'>    function log(string memory p0) internal view {</span>
  187 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  188 |     | <span class='neutral'>    }</span>
  189 |     | <span class='neutral'></span>
  190 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  192 |     | <span class='neutral'>    }</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  196 |     | <span class='neutral'>    }</span>
  197 |     | <span class='neutral'></span>
  198 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal view {</span>
  199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  200 |     | <span class='neutral'>    }</span>
  201 |     | <span class='neutral'></span>
  202 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal view {</span>
  203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  204 |     | <span class='neutral'>    }</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal view {</span>
  207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  208 |     | <span class='neutral'>    }</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal view {</span>
  211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  212 |     | <span class='neutral'>    }</span>
  213 |     | <span class='neutral'></span>
  214 |     | <span class='neutral'>    function log(string memory p0, uint256 p1) internal view {</span>
  215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  216 |     | <span class='neutral'>    }</span>
  217 |     | <span class='neutral'></span>
  218 |     | <span class='neutral'>    function log(string memory p0, int256 p1) internal view {</span>
  219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,int256)&quot;, p0, p1));</span>
  220 |     | <span class='neutral'>    }</span>
  221 |     | <span class='neutral'></span>
  222 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  228 |     | <span class='neutral'>    }</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='unexecuted'>    function log(string memory p0, address p1) internal view {</span>
  231 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  232 |     | <span class='neutral'>    }</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal view {</span>
  235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  236 |     | <span class='neutral'>    }</span>
  237 |     | <span class='neutral'></span>
  238 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  240 |     | <span class='neutral'>    }</span>
  241 |     | <span class='neutral'></span>
  242 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  244 |     | <span class='neutral'>    }</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  248 |     | <span class='neutral'>    }</span>
  249 |     | <span class='neutral'></span>
  250 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal view {</span>
  251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  252 |     | <span class='neutral'>    }</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  256 |     | <span class='neutral'>    }</span>
  257 |     | <span class='neutral'></span>
  258 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  260 |     | <span class='neutral'>    }</span>
  261 |     | <span class='neutral'></span>
  262 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  264 |     | <span class='neutral'>    }</span>
  265 |     | <span class='neutral'></span>
  266 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal view {</span>
  267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  268 |     | <span class='neutral'>    }</span>
  269 |     | <span class='neutral'></span>
  270 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal view {</span>
  271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  272 |     | <span class='neutral'>    }</span>
  273 |     | <span class='neutral'></span>
  274 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal view {</span>
  275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  276 |     | <span class='neutral'>    }</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal view {</span>
  279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  280 |     | <span class='neutral'>    }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal view {</span>
  283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  284 |     | <span class='neutral'>    }</span>
  285 |     | <span class='neutral'></span>
  286 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal view {</span>
  287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  288 |     | <span class='neutral'>    }</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal view {</span>
  291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  292 |     | <span class='neutral'>    }</span>
  293 |     | <span class='neutral'></span>
  294 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal view {</span>
  295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'></span>
  298 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal view {</span>
  299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  300 |     | <span class='neutral'>    }</span>
  301 |     | <span class='neutral'></span>
  302 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal view {</span>
  303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  304 |     | <span class='neutral'>    }</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal view {</span>
  307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  308 |     | <span class='neutral'>    }</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal view {</span>
  311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  312 |     | <span class='neutral'>    }</span>
  313 |     | <span class='neutral'></span>
  314 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal view {</span>
  315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  316 |     | <span class='neutral'>    }</span>
  317 |     | <span class='neutral'></span>
  318 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal view {</span>
  319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  320 |     | <span class='neutral'>    }</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal view {</span>
  323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  324 |     | <span class='neutral'>    }</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal view {</span>
  327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  328 |     | <span class='neutral'>    }</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal view {</span>
  331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  332 |     | <span class='neutral'>    }</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal view {</span>
  335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  336 |     | <span class='neutral'>    }</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal view {</span>
  339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  340 |     | <span class='neutral'>    }</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal view {</span>
  343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  344 |     | <span class='neutral'>    }</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal view {</span>
  347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  348 |     | <span class='neutral'>    }</span>
  349 |     | <span class='neutral'></span>
  350 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  352 |     | <span class='neutral'>    }</span>
  353 |     | <span class='neutral'></span>
  354 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  356 |     | <span class='neutral'>    }</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  360 |     | <span class='neutral'>    }</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal view {</span>
  363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  364 |     | <span class='neutral'>    }</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  368 |     | <span class='neutral'>    }</span>
  369 |     | <span class='neutral'></span>
  370 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  372 |     | <span class='neutral'>    }</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  376 |     | <span class='neutral'>    }</span>
  377 |     | <span class='neutral'></span>
  378 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal view {</span>
  379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  380 |     | <span class='neutral'>    }</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  388 |     | <span class='neutral'>    }</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  392 |     | <span class='neutral'>    }</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal view {</span>
  395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  396 |     | <span class='neutral'>    }</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal view {</span>
  399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  400 |     | <span class='neutral'>    }</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal view {</span>
  403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  404 |     | <span class='neutral'>    }</span>
  405 |     | <span class='neutral'></span>
  406 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal view {</span>
  407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  408 |     | <span class='neutral'>    }</span>
  409 |     | <span class='neutral'></span>
  410 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal view {</span>
  411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  416 |     | <span class='neutral'>    }</span>
  417 |     | <span class='neutral'></span>
  418 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  420 |     | <span class='neutral'>    }</span>
  421 |     | <span class='neutral'></span>
  422 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  424 |     | <span class='neutral'>    }</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal view {</span>
  427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  428 |     | <span class='neutral'>    }</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  432 |     | <span class='neutral'>    }</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  436 |     | <span class='neutral'>    }</span>
  437 |     | <span class='neutral'></span>
  438 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  440 |     | <span class='neutral'>    }</span>
  441 |     | <span class='neutral'></span>
  442 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal view {</span>
  443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  444 |     | <span class='neutral'>    }</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  448 |     | <span class='neutral'>    }</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  452 |     | <span class='neutral'>    }</span>
  453 |     | <span class='neutral'></span>
  454 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  456 |     | <span class='neutral'>    }</span>
  457 |     | <span class='neutral'></span>
  458 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal view {</span>
  459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal view {</span>
  463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  464 |     | <span class='neutral'>    }</span>
  465 |     | <span class='neutral'></span>
  466 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal view {</span>
  467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  468 |     | <span class='neutral'>    }</span>
  469 |     | <span class='neutral'></span>
  470 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal view {</span>
  471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  472 |     | <span class='neutral'>    }</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal view {</span>
  475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  476 |     | <span class='neutral'>    }</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  480 |     | <span class='neutral'>    }</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  484 |     | <span class='neutral'>    }</span>
  485 |     | <span class='neutral'></span>
  486 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  488 |     | <span class='neutral'>    }</span>
  489 |     | <span class='neutral'></span>
  490 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal view {</span>
  491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  492 |     | <span class='neutral'>    }</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  496 |     | <span class='neutral'>    }</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  500 |     | <span class='neutral'>    }</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  504 |     | <span class='neutral'>    }</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal view {</span>
  507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  508 |     | <span class='neutral'>    }</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  512 |     | <span class='neutral'>    }</span>
  513 |     | <span class='neutral'></span>
  514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  516 |     | <span class='neutral'>    }</span>
  517 |     | <span class='neutral'></span>
  518 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  520 |     | <span class='neutral'>    }</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  524 |     | <span class='neutral'>    }</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  528 |     | <span class='neutral'>    }</span>
  529 |     | <span class='neutral'></span>
  530 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  532 |     | <span class='neutral'>    }</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  536 |     | <span class='neutral'>    }</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  540 |     | <span class='neutral'>    }</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  544 |     | <span class='neutral'>    }</span>
  545 |     | <span class='neutral'></span>
  546 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  547 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {</span>
  551 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  552 |     | <span class='neutral'>    }</span>
  553 |     | <span class='neutral'></span>
  554 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  555 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  556 |     | <span class='neutral'>    }</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  559 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  560 |     | <span class='neutral'>    }</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {</span>
  563 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  564 |     | <span class='neutral'>    }</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {</span>
  567 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  568 |     | <span class='neutral'>    }</span>
  569 |     | <span class='neutral'></span>
  570 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  571 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  572 |     | <span class='neutral'>    }</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {</span>
  575 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  576 |     | <span class='neutral'>    }</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {</span>
  579 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {</span>
  583 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  584 |     | <span class='neutral'>    }</span>
  585 |     | <span class='neutral'></span>
  586 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  587 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  588 |     | <span class='neutral'>    }</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  591 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  592 |     | <span class='neutral'>    }</span>
  593 |     | <span class='neutral'></span>
  594 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  595 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  596 |     | <span class='neutral'>    }</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {</span>
  599 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  600 |     | <span class='neutral'>    }</span>
  601 |     | <span class='neutral'></span>
  602 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  603 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  604 |     | <span class='neutral'>    }</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  607 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  608 |     | <span class='neutral'>    }</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {</span>
  611 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  612 |     | <span class='neutral'>    }</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {</span>
  615 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  616 |     | <span class='neutral'>    }</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  619 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  620 |     | <span class='neutral'>    }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {</span>
  623 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  624 |     | <span class='neutral'>    }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {</span>
  627 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {</span>
  631 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  632 |     | <span class='neutral'>    }</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {</span>
  635 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  636 |     | <span class='neutral'>    }</span>
  637 |     | <span class='neutral'></span>
  638 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {</span>
  639 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  640 |     | <span class='neutral'>    }</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {</span>
  643 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  644 |     | <span class='neutral'>    }</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal view {</span>
  647 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  648 |     | <span class='neutral'>    }</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  651 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  652 |     | <span class='neutral'>    }</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  655 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  656 |     | <span class='neutral'>    }</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {</span>
  659 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  660 |     | <span class='neutral'>    }</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {</span>
  663 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  664 |     | <span class='neutral'>    }</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  667 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  668 |     | <span class='neutral'>    }</span>
  669 |     | <span class='neutral'></span>
  670 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {</span>
  671 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  672 |     | <span class='neutral'>    }</span>
  673 |     | <span class='neutral'></span>
  674 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {</span>
  675 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  676 |     | <span class='neutral'>    }</span>
  677 |     | <span class='neutral'></span>
  678 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {</span>
  679 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  680 |     | <span class='neutral'>    }</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {</span>
  683 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  684 |     | <span class='neutral'>    }</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {</span>
  687 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  688 |     | <span class='neutral'>    }</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {</span>
  691 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  692 |     | <span class='neutral'>    }</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal view {</span>
  695 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  696 |     | <span class='neutral'>    }</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {</span>
  699 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  700 |     | <span class='neutral'>    }</span>
  701 |     | <span class='neutral'></span>
  702 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {</span>
  703 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  704 |     | <span class='neutral'>    }</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal view {</span>
  707 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  708 |     | <span class='neutral'>    }</span>
  709 |     | <span class='neutral'></span>
  710 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal view {</span>
  711 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  712 |     | <span class='neutral'>    }</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  715 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  716 |     | <span class='neutral'>    }</span>
  717 |     | <span class='neutral'></span>
  718 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {</span>
  719 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  720 |     | <span class='neutral'>    }</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {</span>
  723 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {</span>
  727 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  728 |     | <span class='neutral'>    }</span>
  729 |     | <span class='neutral'></span>
  730 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {</span>
  731 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  732 |     | <span class='neutral'>    }</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {</span>
  735 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  736 |     | <span class='neutral'>    }</span>
  737 |     | <span class='neutral'></span>
  738 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {</span>
  739 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  740 |     | <span class='neutral'>    }</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal view {</span>
  743 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  744 |     | <span class='neutral'>    }</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {</span>
  747 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  748 |     | <span class='neutral'>    }</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {</span>
  751 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  752 |     | <span class='neutral'>    }</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal view {</span>
  755 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  756 |     | <span class='neutral'>    }</span>
  757 |     | <span class='neutral'></span>
  758 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal view {</span>
  759 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  760 |     | <span class='neutral'>    }</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {</span>
  763 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  764 |     | <span class='neutral'>    }</span>
  765 |     | <span class='neutral'></span>
  766 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal view {</span>
  767 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  768 |     | <span class='neutral'>    }</span>
  769 |     | <span class='neutral'></span>
  770 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal view {</span>
  771 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  772 |     | <span class='neutral'>    }</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal view {</span>
  775 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  776 |     | <span class='neutral'>    }</span>
  777 |     | <span class='neutral'></span>
  778 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  779 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  780 |     | <span class='neutral'>    }</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  783 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  784 |     | <span class='neutral'>    }</span>
  785 |     | <span class='neutral'></span>
  786 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  787 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  788 |     | <span class='neutral'>    }</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  791 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  792 |     | <span class='neutral'>    }</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  795 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  799 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  800 |     | <span class='neutral'>    }</span>
  801 |     | <span class='neutral'></span>
  802 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  803 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  804 |     | <span class='neutral'>    }</span>
  805 |     | <span class='neutral'></span>
  806 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {</span>
  807 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  808 |     | <span class='neutral'>    }</span>
  809 |     | <span class='neutral'></span>
  810 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  811 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  812 |     | <span class='neutral'>    }</span>
  813 |     | <span class='neutral'></span>
  814 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  815 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  816 |     | <span class='neutral'>    }</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {</span>
  819 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  820 |     | <span class='neutral'>    }</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {</span>
  823 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  824 |     | <span class='neutral'>    }</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  827 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  828 |     | <span class='neutral'>    }</span>
  829 |     | <span class='neutral'></span>
  830 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {</span>
  831 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  832 |     | <span class='neutral'>    }</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {</span>
  835 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  836 |     | <span class='neutral'>    }</span>
  837 |     | <span class='neutral'></span>
  838 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal view {</span>
  839 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  840 |     | <span class='neutral'>    }</span>
  841 |     | <span class='neutral'></span>
  842 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  843 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  844 |     | <span class='neutral'>    }</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  847 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  848 |     | <span class='neutral'>    }</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  851 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  852 |     | <span class='neutral'>    }</span>
  853 |     | <span class='neutral'></span>
  854 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {</span>
  855 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  856 |     | <span class='neutral'>    }</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  859 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'></span>
  862 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  863 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  864 |     | <span class='neutral'>    }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  867 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  868 |     | <span class='neutral'>    }</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  871 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  872 |     | <span class='neutral'>    }</span>
  873 |     | <span class='neutral'></span>
  874 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  875 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  876 |     | <span class='neutral'>    }</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  879 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  880 |     | <span class='neutral'>    }</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  883 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  887 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  888 |     | <span class='neutral'>    }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {</span>
  891 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  892 |     | <span class='neutral'>    }</span>
  893 |     | <span class='neutral'></span>
  894 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  895 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  896 |     | <span class='neutral'>    }</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  899 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  900 |     | <span class='neutral'>    }</span>
  901 |     | <span class='neutral'></span>
  902 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  903 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  904 |     | <span class='neutral'>    }</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  907 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  908 |     | <span class='neutral'>    }</span>
  909 |     | <span class='neutral'></span>
  910 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  911 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  912 |     | <span class='neutral'>    }</span>
  913 |     | <span class='neutral'></span>
  914 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {</span>
  915 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  916 |     | <span class='neutral'>    }</span>
  917 |     | <span class='neutral'></span>
  918 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {</span>
  919 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  920 |     | <span class='neutral'>    }</span>
  921 |     | <span class='neutral'></span>
  922 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  923 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  924 |     | <span class='neutral'>    }</span>
  925 |     | <span class='neutral'></span>
  926 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  927 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  928 |     | <span class='neutral'>    }</span>
  929 |     | <span class='neutral'></span>
  930 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  931 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  932 |     | <span class='neutral'>    }</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  935 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  936 |     | <span class='neutral'>    }</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {</span>
  939 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  940 |     | <span class='neutral'>    }</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  943 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  944 |     | <span class='neutral'>    }</span>
  945 |     | <span class='neutral'></span>
  946 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  947 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  948 |     | <span class='neutral'>    }</span>
  949 |     | <span class='neutral'></span>
  950 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  951 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  952 |     | <span class='neutral'>    }</span>
  953 |     | <span class='neutral'></span>
  954 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {</span>
  955 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  956 |     | <span class='neutral'>    }</span>
  957 |     | <span class='neutral'></span>
  958 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  959 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  960 |     | <span class='neutral'>    }</span>
  961 |     | <span class='neutral'></span>
  962 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  963 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  964 |     | <span class='neutral'>    }</span>
  965 |     | <span class='neutral'></span>
  966 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  967 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  968 |     | <span class='neutral'>    }</span>
  969 |     | <span class='neutral'></span>
  970 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  971 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  972 |     | <span class='neutral'>    }</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {</span>
  975 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  976 |     | <span class='neutral'>    }</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {</span>
  979 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal view {</span>
  983 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  984 |     | <span class='neutral'>    }</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {</span>
  987 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  988 |     | <span class='neutral'>    }</span>
  989 |     | <span class='neutral'></span>
  990 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  991 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  992 |     | <span class='neutral'>    }</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  995 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  996 |     | <span class='neutral'>    }</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  999 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1000 |     | <span class='neutral'>    }</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {</span>
 1003 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1004 |     | <span class='neutral'>    }</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
 1007 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1008 |     | <span class='neutral'>    }</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
 1011 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1015 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1016 |     | <span class='neutral'>    }</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal view {</span>
 1019 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1020 |     | <span class='neutral'>    }</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1023 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1024 |     | <span class='neutral'>    }</span>
 1025 |     | <span class='neutral'></span>
 1026 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1027 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1028 |     | <span class='neutral'>    }</span>
 1029 |     | <span class='neutral'></span>
 1030 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1031 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1032 |     | <span class='neutral'>    }</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1035 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1036 |     | <span class='neutral'>    }</span>
 1037 |     | <span class='neutral'></span>
 1038 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1039 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1040 |     | <span class='neutral'>    }</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1043 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1044 |     | <span class='neutral'>    }</span>
 1045 |     | <span class='neutral'></span>
 1046 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1047 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1048 |     | <span class='neutral'>    }</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1051 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1052 |     | <span class='neutral'>    }</span>
 1053 |     | <span class='neutral'></span>
 1054 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1055 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1056 |     | <span class='neutral'>    }</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1059 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1060 |     | <span class='neutral'>    }</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1063 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1064 |     | <span class='neutral'>    }</span>
 1065 |     | <span class='neutral'></span>
 1066 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1067 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1068 |     | <span class='neutral'>    }</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1071 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1072 |     | <span class='neutral'>    }</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1075 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1076 |     | <span class='neutral'>    }</span>
 1077 |     | <span class='neutral'></span>
 1078 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal view {</span>
 1079 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1080 |     | <span class='neutral'>    }</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1083 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1084 |     | <span class='neutral'>    }</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1087 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1088 |     | <span class='neutral'>    }</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal view {</span>
 1091 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1092 |     | <span class='neutral'>    }</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal view {</span>
 1095 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1096 |     | <span class='neutral'>    }</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1099 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1100 |     | <span class='neutral'>    }</span>
 1101 |     | <span class='neutral'></span>
 1102 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1104 |     | <span class='neutral'>    }</span>
 1105 |     | <span class='neutral'></span>
 1106 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1108 |     | <span class='neutral'>    }</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1112 |     | <span class='neutral'>    }</span>
 1113 |     | <span class='neutral'></span>
 1114 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1116 |     | <span class='neutral'>    }</span>
 1117 |     | <span class='neutral'></span>
 1118 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1120 |     | <span class='neutral'>    }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1124 |     | <span class='neutral'>    }</span>
 1125 |     | <span class='neutral'></span>
 1126 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1128 |     | <span class='neutral'>    }</span>
 1129 |     | <span class='neutral'></span>
 1130 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1132 |     | <span class='neutral'>    }</span>
 1133 |     | <span class='neutral'></span>
 1134 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1136 |     | <span class='neutral'>    }</span>
 1137 |     | <span class='neutral'></span>
 1138 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1140 |     | <span class='neutral'>    }</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1144 |     | <span class='neutral'>    }</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1148 |     | <span class='neutral'>    }</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1152 |     | <span class='neutral'>    }</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1156 |     | <span class='neutral'>    }</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1160 |     | <span class='neutral'>    }</span>
 1161 |     | <span class='neutral'></span>
 1162 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1164 |     | <span class='neutral'>    }</span>
 1165 |     | <span class='neutral'></span>
 1166 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1168 |     | <span class='neutral'>    }</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1172 |     | <span class='neutral'>    }</span>
 1173 |     | <span class='neutral'></span>
 1174 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal view {</span>
 1175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1176 |     | <span class='neutral'>    }</span>
 1177 |     | <span class='neutral'></span>
 1178 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1180 |     | <span class='neutral'>    }</span>
 1181 |     | <span class='neutral'></span>
 1182 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1184 |     | <span class='neutral'>    }</span>
 1185 |     | <span class='neutral'></span>
 1186 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1188 |     | <span class='neutral'>    }</span>
 1189 |     | <span class='neutral'></span>
 1190 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1192 |     | <span class='neutral'>    }</span>
 1193 |     | <span class='neutral'></span>
 1194 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1196 |     | <span class='neutral'>    }</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1200 |     | <span class='neutral'>    }</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1204 |     | <span class='neutral'>    }</span>
 1205 |     | <span class='neutral'></span>
 1206 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1208 |     | <span class='neutral'>    }</span>
 1209 |     | <span class='neutral'></span>
 1210 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal view {</span>
 1211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1212 |     | <span class='neutral'>    }</span>
 1213 |     | <span class='neutral'></span>
 1214 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1216 |     | <span class='neutral'>    }</span>
 1217 |     | <span class='neutral'></span>
 1218 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1220 |     | <span class='neutral'>    }</span>
 1221 |     | <span class='neutral'></span>
 1222 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1224 |     | <span class='neutral'>    }</span>
 1225 |     | <span class='neutral'></span>
 1226 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1228 |     | <span class='neutral'>    }</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1232 |     | <span class='neutral'>    }</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal view {</span>
 1235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1236 |     | <span class='neutral'>    }</span>
 1237 |     | <span class='neutral'></span>
 1238 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal view {</span>
 1239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1240 |     | <span class='neutral'>    }</span>
 1241 |     | <span class='neutral'></span>
 1242 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1244 |     | <span class='neutral'>    }</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1248 |     | <span class='neutral'>    }</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1252 |     | <span class='neutral'>    }</span>
 1253 |     | <span class='neutral'></span>
 1254 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1256 |     | <span class='neutral'>    }</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal view {</span>
 1259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1260 |     | <span class='neutral'>    }</span>
 1261 |     | <span class='neutral'></span>
 1262 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1264 |     | <span class='neutral'>    }</span>
 1265 |     | <span class='neutral'></span>
 1266 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1268 |     | <span class='neutral'>    }</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1272 |     | <span class='neutral'>    }</span>
 1273 |     | <span class='neutral'></span>
 1274 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal view {</span>
 1275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1276 |     | <span class='neutral'>    }</span>
 1277 |     | <span class='neutral'></span>
 1278 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1280 |     | <span class='neutral'>    }</span>
 1281 |     | <span class='neutral'></span>
 1282 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1284 |     | <span class='neutral'>    }</span>
 1285 |     | <span class='neutral'></span>
 1286 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1288 |     | <span class='neutral'>    }</span>
 1289 |     | <span class='neutral'></span>
 1290 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1292 |     | <span class='neutral'>    }</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1296 |     | <span class='neutral'>    }</span>
 1297 |     | <span class='neutral'></span>
 1298 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1300 |     | <span class='neutral'>    }</span>
 1301 |     | <span class='neutral'></span>
 1302 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1304 |     | <span class='neutral'>    }</span>
 1305 |     | <span class='neutral'></span>
 1306 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1308 |     | <span class='neutral'>    }</span>
 1309 |     | <span class='neutral'></span>
 1310 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1312 |     | <span class='neutral'>    }</span>
 1313 |     | <span class='neutral'></span>
 1314 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1316 |     | <span class='neutral'>    }</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1320 |     | <span class='neutral'>    }</span>
 1321 |     | <span class='neutral'></span>
 1322 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1324 |     | <span class='neutral'>    }</span>
 1325 |     | <span class='neutral'></span>
 1326 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1328 |     | <span class='neutral'>    }</span>
 1329 |     | <span class='neutral'></span>
 1330 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1332 |     | <span class='neutral'>    }</span>
 1333 |     | <span class='neutral'></span>
 1334 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal view {</span>
 1335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1336 |     | <span class='neutral'>    }</span>
 1337 |     | <span class='neutral'></span>
 1338 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1340 |     | <span class='neutral'>    }</span>
 1341 |     | <span class='neutral'></span>
 1342 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1344 |     | <span class='neutral'>    }</span>
 1345 |     | <span class='neutral'></span>
 1346 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal view {</span>
 1347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1348 |     | <span class='neutral'>    }</span>
 1349 |     | <span class='neutral'></span>
 1350 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal view {</span>
 1351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1352 |     | <span class='neutral'>    }</span>
 1353 |     | <span class='neutral'></span>
 1354 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1356 |     | <span class='neutral'>    }</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1360 |     | <span class='neutral'>    }</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1364 |     | <span class='neutral'>    }</span>
 1365 |     | <span class='neutral'></span>
 1366 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1368 |     | <span class='neutral'>    }</span>
 1369 |     | <span class='neutral'></span>
 1370 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1372 |     | <span class='neutral'>    }</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1376 |     | <span class='neutral'>    }</span>
 1377 |     | <span class='neutral'></span>
 1378 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1380 |     | <span class='neutral'>    }</span>
 1381 |     | <span class='neutral'></span>
 1382 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1384 |     | <span class='neutral'>    }</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1388 |     | <span class='neutral'>    }</span>
 1389 |     | <span class='neutral'></span>
 1390 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1392 |     | <span class='neutral'>    }</span>
 1393 |     | <span class='neutral'></span>
 1394 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1396 |     | <span class='neutral'>    }</span>
 1397 |     | <span class='neutral'></span>
 1398 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1400 |     | <span class='neutral'>    }</span>
 1401 |     | <span class='neutral'></span>
 1402 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1404 |     | <span class='neutral'>    }</span>
 1405 |     | <span class='neutral'></span>
 1406 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1408 |     | <span class='neutral'>    }</span>
 1409 |     | <span class='neutral'></span>
 1410 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1412 |     | <span class='neutral'>    }</span>
 1413 |     | <span class='neutral'></span>
 1414 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1416 |     | <span class='neutral'>    }</span>
 1417 |     | <span class='neutral'></span>
 1418 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1420 |     | <span class='neutral'>    }</span>
 1421 |     | <span class='neutral'></span>
 1422 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1424 |     | <span class='neutral'>    }</span>
 1425 |     | <span class='neutral'></span>
 1426 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1428 |     | <span class='neutral'>    }</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal view {</span>
 1431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1432 |     | <span class='neutral'>    }</span>
 1433 |     | <span class='neutral'></span>
 1434 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1436 |     | <span class='neutral'>    }</span>
 1437 |     | <span class='neutral'></span>
 1438 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1440 |     | <span class='neutral'>    }</span>
 1441 |     | <span class='neutral'></span>
 1442 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1444 |     | <span class='neutral'>    }</span>
 1445 |     | <span class='neutral'></span>
 1446 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1448 |     | <span class='neutral'>    }</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1452 |     | <span class='neutral'>    }</span>
 1453 |     | <span class='neutral'></span>
 1454 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1456 |     | <span class='neutral'>    }</span>
 1457 |     | <span class='neutral'></span>
 1458 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1460 |     | <span class='neutral'>    }</span>
 1461 |     | <span class='neutral'></span>
 1462 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1464 |     | <span class='neutral'>    }</span>
 1465 |     | <span class='neutral'></span>
 1466 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal view {</span>
 1467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1468 |     | <span class='neutral'>    }</span>
 1469 |     | <span class='neutral'></span>
 1470 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1472 |     | <span class='neutral'>    }</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1476 |     | <span class='neutral'>    }</span>
 1477 |     | <span class='neutral'></span>
 1478 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1480 |     | <span class='neutral'>    }</span>
 1481 |     | <span class='neutral'></span>
 1482 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1484 |     | <span class='neutral'>    }</span>
 1485 |     | <span class='neutral'></span>
 1486 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1488 |     | <span class='neutral'>    }</span>
 1489 |     | <span class='neutral'></span>
 1490 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal view {</span>
 1491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1492 |     | <span class='neutral'>    }</span>
 1493 |     | <span class='neutral'></span>
 1494 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal view {</span>
 1495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1496 |     | <span class='neutral'>    }</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1500 |     | <span class='neutral'>    }</span>
 1501 |     | <span class='neutral'></span>
 1502 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1504 |     | <span class='neutral'>    }</span>
 1505 |     | <span class='neutral'></span>
 1506 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1508 |     | <span class='neutral'>    }</span>
 1509 |     | <span class='neutral'></span>
 1510 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1512 |     | <span class='neutral'>    }</span>
 1513 |     | <span class='neutral'></span>
 1514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal view {</span>
 1515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1516 |     | <span class='neutral'>    }</span>
 1517 |     | <span class='neutral'></span>
 1518 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1520 |     | <span class='neutral'>    }</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1524 |     | <span class='neutral'>    }</span>
 1525 |     | <span class='neutral'></span>
 1526 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1528 |     | <span class='neutral'>    }</span>
 1529 |     | <span class='neutral'></span>
 1530 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal view {</span>
 1531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1532 |     | <span class='neutral'>    }</span>
 1533 |     | <span class='neutral'></span>
 1534 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1536 |     | <span class='neutral'>    }</span>
 1537 |     | <span class='neutral'></span>
 1538 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1540 |     | <span class='neutral'>    }</span>
 1541 |     | <span class='neutral'></span>
 1542 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1544 |     | <span class='neutral'>    }</span>
 1545 |     | <span class='neutral'></span>
 1546 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/access/AccessControl.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IAccessControl.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../utils/Strings.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../utils/introspection/ERC165.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Contract module that allows children to implement role-based access</span>
  13 |     | <span class='neutral'> * control mechanisms. This is a lightweight version that doesn&#39;t allow enumerating role</span>
  14 |     | <span class='neutral'> * members except through off-chain means by accessing the contract event logs. Some</span>
  15 |     | <span class='neutral'> * applications may benefit from on-chain enumerability, for those cases see</span>
  16 |     | <span class='neutral'> * {AccessControlEnumerable}.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * Roles are referred to by their `bytes32` identifier. These should be exposed</span>
  19 |     | <span class='neutral'> * in the external API and be unique. The best way to achieve this is by</span>
  20 |     | <span class='neutral'> * using `public constant` hash digests:</span>
  21 |     | <span class='neutral'> *</span>
  22 |     | <span class='neutral'> * ```</span>
  23 |     | <span class='neutral'> * bytes32 public constant MY_ROLE = keccak256(&quot;MY_ROLE&quot;);</span>
  24 |     | <span class='neutral'> * ```</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * Roles can be used to represent a set of permissions. To restrict access to a</span>
  27 |     | <span class='neutral'> * function call, use {hasRole}:</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * ```</span>
  30 |     | <span class='neutral'> * function foo() public {</span>
  31 |     | <span class='neutral'> *     require(hasRole(MY_ROLE, msg.sender));</span>
  32 |     | <span class='neutral'> *     ...</span>
  33 |     | <span class='neutral'> * }</span>
  34 |     | <span class='neutral'> * ```</span>
  35 |     | <span class='neutral'> *</span>
  36 |     | <span class='neutral'> * Roles can be granted and revoked dynamically via the {grantRole} and</span>
  37 |     | <span class='neutral'> * {revokeRole} functions. Each role has an associated admin role, and only</span>
  38 |     | <span class='neutral'> * accounts that have a role&#39;s admin role can call {grantRole} and {revokeRole}.</span>
  39 |     | <span class='neutral'> *</span>
  40 |     | <span class='neutral'> * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means</span>
  41 |     | <span class='neutral'> * that only accounts with this role will be able to grant or revoke other</span>
  42 |     | <span class='neutral'> * roles. More complex role relationships can be created by using</span>
  43 |     | <span class='neutral'> * {_setRoleAdmin}.</span>
  44 |     | <span class='neutral'> *</span>
  45 |     | <span class='neutral'> * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to</span>
  46 |     | <span class='neutral'> * grant and revoke this role. Extra precautions should be taken to secure</span>
  47 |     | <span class='neutral'> * accounts that have been granted it.</span>
  48 |     | <span class='neutral'> */</span>
  49 |     | <span class='neutral'>abstract contract AccessControl is Context, IAccessControl, ERC165 {</span>
  50 |     | <span class='neutral'>    struct RoleData {</span>
  51 |     | <span class='neutral'>        mapping(address =&gt; bool) members;</span>
  52 |     | <span class='neutral'>        bytes32 adminRole;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    mapping(bytes32 =&gt; RoleData) private _roles;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Modifier that checks that an account has a specific role. Reverts</span>
  61 |     | <span class='neutral'>     * with a standardized message including the required role.</span>
  62 |     | <span class='neutral'>     *</span>
  63 |     | <span class='neutral'>     * The format of the revert reason is given by the following regular expression:</span>
  64 |     | <span class='neutral'>     *</span>
  65 |     | <span class='neutral'>     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * _Available since v4.1._</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    modifier onlyRole(bytes32 role) {</span>
  70 |     | <span class='unexecuted'>        _checkRole(role);</span>
  71 |     | <span class='neutral'>        _;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  76 |     | <span class='neutral'>     */</span>
  77 | *r  | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
  78 | *r  | <span class='executed'>        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='unexecuted'>    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {</span>
  85 |     | <span class='unexecuted'>        return _roles[role].members[account];</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    /**</span>
  89 |     | <span class='neutral'>     * @dev Revert with a standard message if `_msgSender()` is missing `role`.</span>
  90 |     | <span class='neutral'>     * Overriding this function changes the behavior of the {onlyRole} modifier.</span>
  91 |     | <span class='neutral'>     *</span>
  92 |     | <span class='neutral'>     * Format of the revert message is described in {_checkRole}.</span>
  93 |     | <span class='neutral'>     *</span>
  94 |     | <span class='neutral'>     * _Available since v4.6._</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='unexecuted'>    function _checkRole(bytes32 role) internal view virtual {</span>
  97 |     | <span class='unexecuted'>        _checkRole(role, _msgSender());</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Revert with a standard message if `account` is missing `role`.</span>
 102 |     | <span class='neutral'>     *</span>
 103 |     | <span class='neutral'>     * The format of the revert reason is given by the following regular expression:</span>
 104 |     | <span class='neutral'>     *</span>
 105 |     | <span class='neutral'>     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='unexecuted'>    function _checkRole(bytes32 role, address account) internal view virtual {</span>
 108 |     | <span class='unexecuted'>        if (!hasRole(role, account)) {</span>
 109 |     | <span class='unexecuted'>            revert(</span>
 110 |     | <span class='neutral'>                string(</span>
 111 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
 112 |     | <span class='neutral'>                        &quot;AccessControl: account &quot;,</span>
 113 |     | <span class='unexecuted'>                        Strings.toHexString(account),</span>
 114 |     | <span class='neutral'>                        &quot; is missing role &quot;,</span>
 115 |     | <span class='unexecuted'>                        Strings.toHexString(uint256(role), 32)</span>
 116 |     | <span class='neutral'>                    )</span>
 117 |     | <span class='neutral'>                )</span>
 118 |     | <span class='neutral'>            );</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
 124 |     | <span class='neutral'>     * {revokeRole}.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * To change a role&#39;s admin, use {_setRoleAdmin}.</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='unexecuted'>    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {</span>
 129 |     | <span class='unexecuted'>        return _roles[role].adminRole;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /**</span>
 133 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
 134 |     | <span class='neutral'>     *</span>
 135 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
 136 |     | <span class='neutral'>     * event.</span>
 137 |     | <span class='neutral'>     *</span>
 138 |     | <span class='neutral'>     * Requirements:</span>
 139 |     | <span class='neutral'>     *</span>
 140 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 141 |     | <span class='neutral'>     *</span>
 142 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 143 |     | <span class='neutral'>     */</span>
 144 |     | <span class='unexecuted'>    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {</span>
 145 |     | <span class='unexecuted'>        _grantRole(role, account);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * Requirements:</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 156 |     | <span class='neutral'>     *</span>
 157 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 158 |     | <span class='neutral'>     */</span>
 159 |     | <span class='unexecuted'>    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {</span>
 160 |     | <span class='unexecuted'>        _revokeRole(role, account);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
 165 |     | <span class='neutral'>     *</span>
 166 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
 167 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
 168 |     | <span class='neutral'>     * if they are compromised (such as when a trusted device is misplaced).</span>
 169 |     | <span class='neutral'>     *</span>
 170 |     | <span class='neutral'>     * If the calling account had been revoked `role`, emits a {RoleRevoked}</span>
 171 |     | <span class='neutral'>     * event.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - the caller must be `account`.</span>
 176 |     | <span class='neutral'>     *</span>
 177 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 178 |     | <span class='neutral'>     */</span>
 179 | *r  | <span class='executed'>    function renounceRole(bytes32 role, address account) public virtual override {</span>
 180 | r   | <span class='reverted'>        require(account == _msgSender(), &quot;AccessControl: can only renounce roles for self&quot;);</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>        _revokeRole(role, account);</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /**</span>
 186 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
 187 |     | <span class='neutral'>     *</span>
 188 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
 189 |     | <span class='neutral'>     * event. Note that unlike {grantRole}, this function doesn&#39;t perform any</span>
 190 |     | <span class='neutral'>     * checks on the calling account.</span>
 191 |     | <span class='neutral'>     *</span>
 192 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 193 |     | <span class='neutral'>     *</span>
 194 |     | <span class='neutral'>     * [WARNING]</span>
 195 |     | <span class='neutral'>     * ====</span>
 196 |     | <span class='neutral'>     * This function should only be called from the constructor when setting</span>
 197 |     | <span class='neutral'>     * up the initial roles for the system.</span>
 198 |     | <span class='neutral'>     *</span>
 199 |     | <span class='neutral'>     * Using this function in any other way is effectively circumventing the admin</span>
 200 |     | <span class='neutral'>     * system imposed by {AccessControl}.</span>
 201 |     | <span class='neutral'>     * ====</span>
 202 |     | <span class='neutral'>     *</span>
 203 |     | <span class='neutral'>     * NOTE: This function is deprecated in favor of {_grantRole}.</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function _setupRole(bytes32 role, address account) internal virtual {</span>
 206 |     | <span class='neutral'>        _grantRole(role, account);</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /**</span>
 210 |     | <span class='neutral'>     * @dev Sets `adminRole` as ``role``&#39;s admin role.</span>
 211 |     | <span class='neutral'>     *</span>
 212 |     | <span class='neutral'>     * Emits a {RoleAdminChanged} event.</span>
 213 |     | <span class='neutral'>     */</span>
 214 |     | <span class='neutral'>    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {</span>
 215 |     | <span class='neutral'>        bytes32 previousAdminRole = getRoleAdmin(role);</span>
 216 |     | <span class='neutral'>        _roles[role].adminRole = adminRole;</span>
 217 |     | <span class='neutral'>        emit RoleAdminChanged(role, previousAdminRole, adminRole);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /**</span>
 221 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
 222 |     | <span class='neutral'>     *</span>
 223 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 224 |     | <span class='neutral'>     *</span>
 225 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 226 |     | <span class='neutral'>     */</span>
 227 |     | <span class='unexecuted'>    function _grantRole(bytes32 role, address account) internal virtual {</span>
 228 |     | <span class='unexecuted'>        if (!hasRole(role, account)) {</span>
 229 |     | <span class='unexecuted'>            _roles[role].members[account] = true;</span>
 230 |     | <span class='unexecuted'>            emit RoleGranted(role, account, _msgSender());</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    /**</span>
 235 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
 236 |     | <span class='neutral'>     *</span>
 237 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 238 |     | <span class='neutral'>     *</span>
 239 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='unexecuted'>    function _revokeRole(bytes32 role, address account) internal virtual {</span>
 242 |     | <span class='unexecuted'>        if (hasRole(role, account)) {</span>
 243 |     | <span class='unexecuted'>            _roles[role].members[account] = false;</span>
 244 |     | <span class='unexecuted'>            emit RoleRevoked(role, account, _msgSender());</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'>}</span>
 248 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev External interface of AccessControl declared to support ERC165 detection.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IAccessControl {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `newAdminRole` is set as ``role``&#39;s admin role, replacing `previousAdminRole`</span>
 12 |     | <span class='neutral'>     *</span>
 13 |     | <span class='neutral'>     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite</span>
 14 |     | <span class='neutral'>     * {RoleAdminChanged} not being emitted signaling this.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * _Available since v3.1._</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /**</span>
 21 |     | <span class='neutral'>     * @dev Emitted when `account` is granted `role`.</span>
 22 |     | <span class='neutral'>     *</span>
 23 |     | <span class='neutral'>     * `sender` is the account that originated the contract call, an admin role</span>
 24 |     | <span class='neutral'>     * bearer except when using {AccessControl-_setupRole}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /**</span>
 29 |     | <span class='neutral'>     * @dev Emitted when `account` is revoked `role`.</span>
 30 |     | <span class='neutral'>     *</span>
 31 |     | <span class='neutral'>     * `sender` is the account that originated the contract call:</span>
 32 |     | <span class='neutral'>     *   - if using `revokeRole`, it is the admin role bearer</span>
 33 |     | <span class='neutral'>     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    /**</span>
 38 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    function hasRole(bytes32 role, address account) external view returns (bool);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /**</span>
 43 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
 44 |     | <span class='neutral'>     * {revokeRole}.</span>
 45 |     | <span class='neutral'>     *</span>
 46 |     | <span class='neutral'>     * To change a role&#39;s admin, use {AccessControl-_setRoleAdmin}.</span>
 47 |     | <span class='neutral'>     */</span>
 48 |     | <span class='neutral'>    function getRoleAdmin(bytes32 role) external view returns (bytes32);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /**</span>
 51 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
 52 |     | <span class='neutral'>     *</span>
 53 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
 54 |     | <span class='neutral'>     * event.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * Requirements:</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function grantRole(bytes32 role, address account) external;</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    /**</span>
 63 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
 64 |     | <span class='neutral'>     *</span>
 65 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
 66 |     | <span class='neutral'>     *</span>
 67 |     | <span class='neutral'>     * Requirements:</span>
 68 |     | <span class='neutral'>     *</span>
 69 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 70 |     | <span class='neutral'>     */</span>
 71 |     | <span class='neutral'>    function revokeRole(bytes32 role, address account) external;</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /**</span>
 74 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
 75 |     | <span class='neutral'>     *</span>
 76 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
 77 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
 78 |     | <span class='neutral'>     * if they are compromised (such as when a trusted device is misplaced).</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * If the calling account had been granted `role`, emits a {RoleRevoked}</span>
 81 |     | <span class='neutral'>     * event.</span>
 82 |     | <span class='neutral'>     *</span>
 83 |     | <span class='neutral'>     * Requirements:</span>
 84 |     | <span class='neutral'>     *</span>
 85 |     | <span class='neutral'>     * - the caller must be `account`.</span>
 86 |     | <span class='neutral'>     */</span>
 87 |     | <span class='neutral'>    function renounceRole(bytes32 role, address account) external;</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(</span>
 78 |     | <span class='neutral'>        address from,</span>
 79 |     | <span class='neutral'>        address to,</span>
 80 |     | <span class='neutral'>        uint256 amount</span>
 81 |     | <span class='neutral'>    ) external returns (bool);</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='unexecuted'>    function _msgSender() internal view virtual returns (address) {</span>
 18 |     | <span class='unexecuted'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/utils/Strings.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev String operations.</span>
 10 |     | <span class='unexecuted'> */</span>
 11 |     | <span class='neutral'>library Strings {</span>
 12 |     | <span class='neutral'>    bytes16 private constant _SYMBOLS = &quot;0123456789abcdef&quot;;</span>
 13 |     | <span class='unexecuted'>    uint8 private constant _ADDRESS_LENGTH = 20;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'>    function toString(uint256 value) internal pure returns (string memory) {</span>
 19 |     | <span class='neutral'>        unchecked {</span>
 20 |     | <span class='neutral'>            uint256 length = Math.log10(value) + 1;</span>
 21 |     | <span class='neutral'>            string memory buffer = new string(length);</span>
 22 |     | <span class='neutral'>            uint256 ptr;</span>
 23 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 24 |     | <span class='neutral'>            assembly {</span>
 25 |     | <span class='neutral'>                ptr := add(buffer, add(32, length))</span>
 26 |     | <span class='neutral'>            }</span>
 27 |     | <span class='neutral'>            while (true) {</span>
 28 |     | <span class='neutral'>                ptr--;</span>
 29 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 30 |     | <span class='neutral'>                assembly {</span>
 31 |     | <span class='neutral'>                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))</span>
 32 |     | <span class='neutral'>                }</span>
 33 |     | <span class='neutral'>                value /= 10;</span>
 34 |     | <span class='neutral'>                if (value == 0) break;</span>
 35 |     | <span class='neutral'>            }</span>
 36 |     | <span class='neutral'>            return buffer;</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
 44 |     | <span class='neutral'>        unchecked {</span>
 45 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
 46 |     | <span class='neutral'>        }</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='unexecuted'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
 53 |     | <span class='unexecuted'>        bytes memory buffer = new bytes(2 * length + 2);</span>
 54 |     | <span class='unexecuted'>        buffer[0] = &quot;0&quot;;</span>
 55 |     | <span class='unexecuted'>        buffer[1] = &quot;x&quot;;</span>
 56 |     | <span class='unexecuted'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
 57 |     | <span class='unexecuted'>            buffer[i] = _SYMBOLS[value &amp; 0xf];</span>
 58 |     | <span class='unexecuted'>            value &gt;&gt;= 4;</span>
 59 |     | <span class='neutral'>        }</span>
 60 |     | <span class='unexecuted'>        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span>
 61 |     | <span class='neutral'>        return string(buffer);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    /**</span>
 65 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='unexecuted'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 68 |     | <span class='unexecuted'>        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'>}</span>
 71 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 27 |     | <span class='unexecuted'>        return interfaceId == type(IERC165).interfaceId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/openzeppelin-contracts/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
   8 |     | <span class='unexecuted'> */</span>
   9 |     | <span class='neutral'>library Math {</span>
  10 |     | <span class='neutral'>    enum Rounding {</span>
  11 |     | <span class='neutral'>        Down, // Toward negative infinity</span>
  12 |     | <span class='neutral'>        Up, // Toward infinity</span>
  13 |     | <span class='neutral'>        Zero // Toward zero</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @dev Returns the largest of two numbers.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  27 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
  32 |     | <span class='neutral'>     * zero.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  35 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
  36 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * This differs from standard division with `/` in that it rounds up instead</span>
  43 |     | <span class='neutral'>     * of rounding down.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  46 |     | <span class='neutral'>        // (a + b - 1) / b can overflow on addition, so we distribute.</span>
  47 |     | <span class='neutral'>        return a == 0 ? 0 : (a - 1) / b + 1;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  52 |     | <span class='neutral'>     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)</span>
  53 |     | <span class='neutral'>     * with further edits by Uniswap Labs also under MIT license.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function mulDiv(</span>
  56 |     | <span class='neutral'>        uint256 x,</span>
  57 |     | <span class='neutral'>        uint256 y,</span>
  58 |     | <span class='neutral'>        uint256 denominator</span>
  59 |     | <span class='neutral'>    ) internal pure returns (uint256 result) {</span>
  60 |     | <span class='neutral'>        unchecked {</span>
  61 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use</span>
  62 |     | <span class='neutral'>            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
  63 |     | <span class='neutral'>            // variables such that product = prod1 * 2^256 + prod0.</span>
  64 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product</span>
  65 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
  66 |     | <span class='neutral'>            assembly {</span>
  67 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
  68 |     | <span class='neutral'>                prod0 := mul(x, y)</span>
  69 |     | <span class='neutral'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  73 |     | <span class='neutral'>            if (prod1 == 0) {</span>
  74 |     | <span class='neutral'>                return prod0 / denominator;</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>            // Make sure the result is less than 2^256. Also prevents denominator == 0.</span>
  78 |     | <span class='neutral'>            require(denominator &gt; prod1);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  81 |     | <span class='neutral'>            // 512 by 256 division.</span>
  82 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0].</span>
  85 |     | <span class='neutral'>            uint256 remainder;</span>
  86 |     | <span class='neutral'>            assembly {</span>
  87 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
  88 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
  91 |     | <span class='neutral'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  92 |     | <span class='neutral'>                prod0 := sub(prod0, remainder)</span>
  93 |     | <span class='neutral'>            }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always &gt;= 1.</span>
  96 |     | <span class='neutral'>            // See https://cs.stackexchange.com/q/138556/92363.</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>            // Does not overflow because the denominator cannot be zero at this stage in the function.</span>
  99 |     | <span class='neutral'>            uint256 twos = denominator &amp; (~denominator + 1);</span>
 100 |     | <span class='neutral'>            assembly {</span>
 101 |     | <span class='neutral'>                // Divide denominator by twos.</span>
 102 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>                // Divide [prod1 prod0] by twos.</span>
 105 |     | <span class='neutral'>                prod0 := div(prod0, twos)</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.</span>
 108 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 109 |     | <span class='neutral'>            }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0.</span>
 112 |     | <span class='neutral'>            prod0 |= prod1 * twos;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such</span>
 115 |     | <span class='neutral'>            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for</span>
 116 |     | <span class='neutral'>            // four bits. That is, denominator * inv = 1 mod 2^4.</span>
 117 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also works</span>
 120 |     | <span class='neutral'>            // in modular arithmetic, doubling the correct bits in each step.</span>
 121 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^8</span>
 122 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^16</span>
 123 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^32</span>
 124 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^64</span>
 125 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^128</span>
 126 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^256</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 129 |     | <span class='neutral'>            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is</span>
 130 |     | <span class='neutral'>            // less than 2^256, this is the final result. We don&#39;t need to compute the high bits of the result and prod1</span>
 131 |     | <span class='neutral'>            // is no longer required.</span>
 132 |     | <span class='neutral'>            result = prod0 * inverse;</span>
 133 |     | <span class='neutral'>            return result;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /**</span>
 138 |     | <span class='neutral'>     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    function mulDiv(</span>
 141 |     | <span class='neutral'>        uint256 x,</span>
 142 |     | <span class='neutral'>        uint256 y,</span>
 143 |     | <span class='neutral'>        uint256 denominator,</span>
 144 |     | <span class='neutral'>        Rounding rounding</span>
 145 |     | <span class='neutral'>    ) internal pure returns (uint256) {</span>
 146 |     | <span class='neutral'>        uint256 result = mulDiv(x, y, denominator);</span>
 147 |     | <span class='neutral'>        if (rounding == Rounding.Up &amp;&amp; mulmod(x, y, denominator) &gt; 0) {</span>
 148 |     | <span class='neutral'>            result += 1;</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>        return result;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /**</span>
 154 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.</span>
 155 |     | <span class='neutral'>     *</span>
 156 |     | <span class='neutral'>     * Inspired by Henry S. Warren, Jr.&#39;s &quot;Hacker&#39;s Delight&quot; (Chapter 11).</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 159 |     | <span class='neutral'>        if (a == 0) {</span>
 160 |     | <span class='neutral'>            return 0;</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.</span>
 164 |     | <span class='neutral'>        //</span>
 165 |     | <span class='neutral'>        // We know that the &quot;msb&quot; (most significant bit) of our target number `a` is a power of 2 such that we have</span>
 166 |     | <span class='neutral'>        // `msb(a) &lt;= a &lt; 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.</span>
 167 |     | <span class='neutral'>        //</span>
 168 |     | <span class='neutral'>        // This can be rewritten `2**log2(a) &lt;= a &lt; 2**(log2(a) + 1)`</span>
 169 |     | <span class='neutral'>        // → `sqrt(2**k) &lt;= sqrt(a) &lt; sqrt(2**(k+1))`</span>
 170 |     | <span class='neutral'>        // → `2**(k/2) &lt;= sqrt(a) &lt; 2**((k+1)/2) &lt;= 2**(k/2 + 1)`</span>
 171 |     | <span class='neutral'>        //</span>
 172 |     | <span class='neutral'>        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.</span>
 173 |     | <span class='neutral'>        uint256 result = 1 &lt;&lt; (log2(a) &gt;&gt; 1);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,</span>
 176 |     | <span class='neutral'>        // since it is the square root of a uint256. Newton&#39;s method converges quadratically (precision doubles at</span>
 177 |     | <span class='neutral'>        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision</span>
 178 |     | <span class='neutral'>        // into the expected uint128 result.</span>
 179 |     | <span class='neutral'>        unchecked {</span>
 180 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 181 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 182 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 183 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 184 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 185 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 186 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 187 |     | <span class='neutral'>            return min(result, a / result);</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /**</span>
 192 |     | <span class='neutral'>     * @notice Calculates sqrt(a), following the selected rounding direction.</span>
 193 |     | <span class='neutral'>     */</span>
 194 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 195 |     | <span class='neutral'>        unchecked {</span>
 196 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 197 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; result * result &lt; a ? 1 : 0);</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    /**</span>
 202 |     | <span class='neutral'>     * @dev Return the log in base 2, rounded down, of a positive value.</span>
 203 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function log2(uint256 value) internal pure returns (uint256) {</span>
 206 |     | <span class='neutral'>        uint256 result = 0;</span>
 207 |     | <span class='neutral'>        unchecked {</span>
 208 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 209 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 210 |     | <span class='neutral'>                result += 128;</span>
 211 |     | <span class='neutral'>            }</span>
 212 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 213 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 214 |     | <span class='neutral'>                result += 64;</span>
 215 |     | <span class='neutral'>            }</span>
 216 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 217 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 218 |     | <span class='neutral'>                result += 32;</span>
 219 |     | <span class='neutral'>            }</span>
 220 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 221 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 222 |     | <span class='neutral'>                result += 16;</span>
 223 |     | <span class='neutral'>            }</span>
 224 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 225 |     | <span class='neutral'>                value &gt;&gt;= 8;</span>
 226 |     | <span class='neutral'>                result += 8;</span>
 227 |     | <span class='neutral'>            }</span>
 228 |     | <span class='neutral'>            if (value &gt;&gt; 4 &gt; 0) {</span>
 229 |     | <span class='neutral'>                value &gt;&gt;= 4;</span>
 230 |     | <span class='neutral'>                result += 4;</span>
 231 |     | <span class='neutral'>            }</span>
 232 |     | <span class='neutral'>            if (value &gt;&gt; 2 &gt; 0) {</span>
 233 |     | <span class='neutral'>                value &gt;&gt;= 2;</span>
 234 |     | <span class='neutral'>                result += 2;</span>
 235 |     | <span class='neutral'>            }</span>
 236 |     | <span class='neutral'>            if (value &gt;&gt; 1 &gt; 0) {</span>
 237 |     | <span class='neutral'>                result += 1;</span>
 238 |     | <span class='neutral'>            }</span>
 239 |     | <span class='neutral'>        }</span>
 240 |     | <span class='neutral'>        return result;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    /**</span>
 244 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 245 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 246 |     | <span class='neutral'>     */</span>
 247 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 248 |     | <span class='neutral'>        unchecked {</span>
 249 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 250 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; result &lt; value ? 1 : 0);</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /**</span>
 255 |     | <span class='neutral'>     * @dev Return the log in base 10, rounded down, of a positive value.</span>
 256 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 257 |     | <span class='neutral'>     */</span>
 258 |     | <span class='neutral'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 259 |     | <span class='neutral'>        uint256 result = 0;</span>
 260 |     | <span class='neutral'>        unchecked {</span>
 261 |     | <span class='neutral'>            if (value &gt;= 10**64) {</span>
 262 |     | <span class='neutral'>                value /= 10**64;</span>
 263 |     | <span class='neutral'>                result += 64;</span>
 264 |     | <span class='neutral'>            }</span>
 265 |     | <span class='neutral'>            if (value &gt;= 10**32) {</span>
 266 |     | <span class='neutral'>                value /= 10**32;</span>
 267 |     | <span class='neutral'>                result += 32;</span>
 268 |     | <span class='neutral'>            }</span>
 269 |     | <span class='neutral'>            if (value &gt;= 10**16) {</span>
 270 |     | <span class='neutral'>                value /= 10**16;</span>
 271 |     | <span class='neutral'>                result += 16;</span>
 272 |     | <span class='neutral'>            }</span>
 273 |     | <span class='neutral'>            if (value &gt;= 10**8) {</span>
 274 |     | <span class='neutral'>                value /= 10**8;</span>
 275 |     | <span class='neutral'>                result += 8;</span>
 276 |     | <span class='neutral'>            }</span>
 277 |     | <span class='neutral'>            if (value &gt;= 10**4) {</span>
 278 |     | <span class='neutral'>                value /= 10**4;</span>
 279 |     | <span class='neutral'>                result += 4;</span>
 280 |     | <span class='neutral'>            }</span>
 281 |     | <span class='neutral'>            if (value &gt;= 10**2) {</span>
 282 |     | <span class='neutral'>                value /= 10**2;</span>
 283 |     | <span class='neutral'>                result += 2;</span>
 284 |     | <span class='neutral'>            }</span>
 285 |     | <span class='neutral'>            if (value &gt;= 10**1) {</span>
 286 |     | <span class='neutral'>                result += 1;</span>
 287 |     | <span class='neutral'>            }</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'>        return result;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    /**</span>
 293 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 294 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 295 |     | <span class='neutral'>     */</span>
 296 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 297 |     | <span class='neutral'>        unchecked {</span>
 298 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 299 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 10**result &lt; value ? 1 : 0);</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    /**</span>
 304 |     | <span class='neutral'>     * @dev Return the log in base 256, rounded down, of a positive value.</span>
 305 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 308 |     | <span class='neutral'>     */</span>
 309 |     | <span class='neutral'>    function log256(uint256 value) internal pure returns (uint256) {</span>
 310 |     | <span class='neutral'>        uint256 result = 0;</span>
 311 |     | <span class='neutral'>        unchecked {</span>
 312 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 313 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 314 |     | <span class='neutral'>                result += 16;</span>
 315 |     | <span class='neutral'>            }</span>
 316 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 317 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 318 |     | <span class='neutral'>                result += 8;</span>
 319 |     | <span class='neutral'>            }</span>
 320 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 321 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 322 |     | <span class='neutral'>                result += 4;</span>
 323 |     | <span class='neutral'>            }</span>
 324 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 325 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 326 |     | <span class='neutral'>                result += 2;</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 329 |     | <span class='neutral'>                result += 1;</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>        return result;</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    /**</span>
 336 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 337 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 338 |     | <span class='neutral'>     */</span>
 339 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 340 |     | <span class='neutral'>        unchecked {</span>
 341 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 342 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; (result * 8) &lt; value ? 1 : 0);</span>
 343 |     | <span class='neutral'>        }</span>
 344 |     | <span class='neutral'>    }</span>
 345 |     | <span class='neutral'>}</span>
 346 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/ERC4626PropertyTests.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import {TestERC20Token} from &quot;./util/TestERC20Token.sol&quot;;</span>
  4 |     | <span class='neutral'>import {CryticERC4626RedeemUsingApproval} from &quot;./properties/RedeemUsingApprovalProps.sol&quot;;</span>
  5 |     | <span class='neutral'>import {CryticERC4626SenderIndependent} from &quot;./properties/SenderIndependentProps.sol&quot;;</span>
  6 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;./util/ERC4626PropertyTestBase.sol&quot;;</span>
  7 |     | <span class='neutral'>import {CryticERC4626MustNotRevert} from &quot;./properties/MustNotRevertProps.sol&quot;;</span>
  8 |     | <span class='neutral'>import {CryticERC4626FunctionalAccounting} from &quot;./properties/FunctionalAccountingProps.sol&quot;;</span>
  9 |     | <span class='neutral'>import {CryticERC4626Rounding} from &quot;./properties/RoundingProps.sol&quot;;</span>
 10 |     | <span class='neutral'>import {CryticERC4626VaultProxy} from &quot;./properties/VaultProxy.sol&quot;;</span>
 11 |     | <span class='neutral'>import {CryticERC4626SecurityProps} from &quot;./properties/SecurityProps.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>/// @notice Aggregator contract for various 4626 property tests. Inherit from this &amp; echidna will test all properties at the same time.</span>
 14 |     | <span class='neutral'>contract CryticERC4626PropertyTests is </span>
 15 |     | <span class='neutral'>    CryticERC4626RedeemUsingApproval, </span>
 16 |     | <span class='neutral'>    CryticERC4626MustNotRevert, </span>
 17 |     | <span class='neutral'>    CryticERC4626SenderIndependent,</span>
 18 |     | <span class='neutral'>    CryticERC4626FunctionalAccounting,</span>
 19 |     | <span class='neutral'>    CryticERC4626Rounding, </span>
 20 |     | <span class='neutral'>    CryticERC4626SecurityProps{</span>
 21 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/properties/FunctionalAccountingProps.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;../util/ERC4626PropertyTestBase.sol&quot;;</span>
   4 |     | <span class='unexecuted'></span>
   5 |     | <span class='neutral'>contract CryticERC4626FunctionalAccounting is CryticERC4626PropertyBase {</span>
   6 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
   7 |     | <span class='neutral'>    ///  - deposit() must deduct assets from the owner</span>
   8 |     | <span class='neutral'>    ///  - deposit() must credit shares to the receiver</span>
   9 |     | <span class='neutral'>    ///  - deposit() must mint greater than or equal to the number of shares predicted by previewDeposit()</span>
  10 | *r  | <span class='executed'>    function verify_depositProperties(uint256 receiverId, uint256 tokens) public {</span>
  11 | *r  | <span class='executed'>        address sender = address(this);</span>
  12 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
  13 | *r  | <span class='executed'>        tokens = requireValidDepositAmount(sender, receiver, tokens);</span>
  14 |     | <span class='neutral'></span>
  15 | *   | <span class='executed'>        (uint256 senderAssetsBeforeDeposit,) = measureAddressHoldings(sender, &quot;sender&quot;, &quot;before deposit&quot;);</span>
  16 | *   | <span class='executed'>        (, uint256 receiverSharesBeforeDeposit) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;before deposit&quot;);</span>
  17 |     | <span class='neutral'></span>
  18 | *   | <span class='executed'>        uint256 sharesExpected = vault.previewDeposit(tokens);</span>
  19 | *   | <span class='executed'>        uint256 sharesMinted = vault.deposit(tokens, receiver);</span>
  20 | *   | <span class='executed'>        assertGte(sharesMinted, sharesExpected, &quot;deposit() must always mint greater than or equal to the shares predicted by previewDeposit()&quot;);</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>        (uint256 senderAssetsAfterDeposit,) = measureAddressHoldings(sender, &quot;sender&quot;, &quot;after deposit&quot;);</span>
  23 | *   | <span class='executed'>        (, uint256 receiverSharesAfterDeposit) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;after deposit&quot;);</span>
  24 |     | <span class='neutral'>        </span>
  25 | *   | <span class='executed'>        uint256 senderAssetsDelta = senderAssetsBeforeDeposit - senderAssetsAfterDeposit;</span>
  26 | *   | <span class='executed'>        assertEq(senderAssetsDelta, tokens, &quot;deposit() must consume exactly the number of tokens requested&quot;);</span>
  27 |     | <span class='neutral'></span>
  28 | *   | <span class='executed'>        uint256 receiverSharesDelta = receiverSharesAfterDeposit - receiverSharesBeforeDeposit;</span>
  29 | *   | <span class='executed'>        assertEq(receiverSharesDelta, sharesMinted, &quot;deposit() must credit the correct number of shares to the receiver&quot;);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
  33 |     | <span class='neutral'>    ///  - mint() must deduct assets from the owner</span>
  34 |     | <span class='neutral'>    ///  - mint() must credit shares to the receiver</span>
  35 |     | <span class='neutral'>    ///  - mint() must consume less than or equal to the number of assets predicted by previewMint()</span>
  36 | *r  | <span class='executed'>    function verify_mintProperties(uint256 receiverId, uint256 shares) public {</span>
  37 | *r  | <span class='executed'>        address sender = address(this);</span>
  38 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
  39 | *r  | <span class='executed'>        uint256 tokensExpected = vault.previewMint(shares);</span>
  40 | *r  | <span class='executed'>        shares = requireValidMintAmount(sender, receiver, shares);</span>
  41 |     | <span class='neutral'></span>
  42 | *   | <span class='executed'>        (uint256 senderAssetsBeforeMint,) = measureAddressHoldings(sender, &quot;sender&quot;, &quot;before mint&quot;);</span>
  43 | *   | <span class='executed'>        (, uint256 receiverSharesBeforeMint) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;before mint&quot;);</span>
  44 |     | <span class='neutral'></span>
  45 | *   | <span class='executed'>        uint256 tokensConsumed = vault.mint(shares, receiver);</span>
  46 | *   | <span class='executed'>        assertLte(tokensConsumed, tokensExpected, &quot;mint() must always consume less than or equal to the tokens predicted by previewMint()&quot;);</span>
  47 |     | <span class='neutral'></span>
  48 | *   | <span class='executed'>        (uint256 senderAssetsAfterMint,) = measureAddressHoldings(sender, &quot;sender&quot;, &quot;after mint&quot;);</span>
  49 | *   | <span class='executed'>        (, uint256 receiverSharesAfterMint) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;after mint&quot;);</span>
  50 |     | <span class='neutral'></span>
  51 | *   | <span class='executed'>        uint256 senderAssetsDelta = senderAssetsBeforeMint - senderAssetsAfterMint;</span>
  52 | *   | <span class='executed'>        assertEq(senderAssetsDelta, tokensConsumed, &quot;mint() must consume exactly the number of tokens requested&quot;);</span>
  53 |     | <span class='neutral'></span>
  54 | *   | <span class='executed'>        uint256 receiverSharesDelta = receiverSharesAfterMint - receiverSharesBeforeMint;</span>
  55 | *   | <span class='executed'>        assertEq(receiverSharesDelta, shares, &quot;mint() must credit the correct number of shares to the receiver&quot;);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
  59 |     | <span class='neutral'>    ///  - redeem() must deduct shares from the owner</span>
  60 |     | <span class='neutral'>    ///  - redeem() must credit assets to the receiver</span>
  61 |     | <span class='neutral'>    ///  - redeem() must credit greater than or equal to the number of assets predicted by previewRedeem()</span>
  62 | *r  | <span class='executed'>    function verify_redeemProperties(uint256 receiverId, uint256 shares) public {</span>
  63 |     | <span class='neutral'>        // we can only redeem on behalf of address(this) until we get cheatcodes</span>
  64 | *r  | <span class='executed'>        address owner = address(this);</span>
  65 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
  66 | *r  | <span class='executed'>        shares = requireValidRedeemAmount(owner, shares);</span>
  67 |     | <span class='neutral'></span>
  68 | *   | <span class='executed'>        (, uint256 ownerSharesBefore) = measureAddressHoldings(owner, &quot;owner&quot;, &quot;before redeem&quot;);</span>
  69 | *   | <span class='executed'>        (uint256 receiverAssetsBefore,) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;before redeem&quot;);</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>        uint256 tokensExpected = vault.previewRedeem(shares);</span>
  72 | *   | <span class='executed'>        uint256 tokensWithdrawn = vault.redeem(shares, receiver, owner);</span>
  73 | *   | <span class='executed'>        assertGte(tokensWithdrawn, tokensExpected, &quot;redeem() must withdraw greater than or equal to the number of assets predicted by previewRedeem()&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>        (, uint256 ownerSharesAfter) = measureAddressHoldings(owner, &quot;owner&quot;, &quot;after redeem&quot;);</span>
  76 | *   | <span class='executed'>        (uint256 receiverAssetsAfter,) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;after redeem&quot;);</span>
  77 |     | <span class='neutral'></span>
  78 | *   | <span class='executed'>        uint256 receiverAssetsDelta = receiverAssetsAfter - receiverAssetsBefore;</span>
  79 | *   | <span class='executed'>        assertEq(receiverAssetsDelta, tokensWithdrawn, &quot;redeem() must credit the correct number of assets to the receiver&quot;);</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>        uint256 ownerSharesDelta = ownerSharesBefore - ownerSharesAfter;</span>
  82 | *   | <span class='executed'>        assertEq(ownerSharesDelta, shares, &quot;redeem() must deduct the correct number of shares from the owner&quot;);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
  86 |     | <span class='neutral'>    ///  - withdraw() must deduct shares from the owner</span>
  87 |     | <span class='neutral'>    ///  - withdraw() must credit assets to the receiver</span>
  88 |     | <span class='neutral'>    ///  - withdraw() must deduct less than or equal to the number of shares predicted by previewWithdraw()</span>
  89 | *r  | <span class='executed'>    function verify_withdrawProperties(uint256 receiverId, uint256 tokens) public {</span>
  90 |     | <span class='neutral'>        // we can only withdraw on behalf of address(this) until we get cheatcodes</span>
  91 | r   | <span class='reverted'>        address owner = address(this);</span>
  92 | r   | <span class='reverted'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
  93 | r   | <span class='reverted'>        tokens = requireValidWithdrawAmount(owner, tokens);</span>
  94 | r   | <span class='reverted'>        uint256 sharesExpected = vault.previewWithdraw(tokens);</span>
  95 |     | <span class='neutral'></span>
  96 | r   | <span class='reverted'>        (, uint256 ownerSharesBefore) = measureAddressHoldings(owner, &quot;owner&quot;, &quot;before withdraw&quot;);</span>
  97 | r   | <span class='reverted'>        (uint256 receiverAssetsBefore,) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;before withdraw&quot;);</span>
  98 |     | <span class='neutral'></span>
  99 | r   | <span class='reverted'>        uint256 sharesRedeemed = vault.withdraw(tokens, receiver, owner);</span>
 100 |     | <span class='unexecuted'>        assertLte(sharesRedeemed, sharesExpected, &quot;withdraw() must redeem less than or equal to the number of shares predicted by previewWithdraw()&quot;);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        (, uint256 ownerSharesAfter) = measureAddressHoldings(owner, &quot;owner&quot;, &quot;after withdraw&quot;);</span>
 103 |     | <span class='unexecuted'>        (uint256 receiverAssetsAfter,) = measureAddressHoldings(receiver, &quot;receiver&quot;, &quot;after withdraw&quot;);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>        uint256 receiverAssetsDelta = receiverAssetsAfter - receiverAssetsBefore;</span>
 106 |     | <span class='unexecuted'>        assertEq(receiverAssetsDelta, tokens, &quot;withdraw() must credit the correct number of assets to the receiver&quot;);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        uint256 ownerSharesDelta = ownerSharesBefore - ownerSharesAfter;</span>
 109 | *   | <span class='executed'>        assertEq(ownerSharesDelta, sharesRedeemed, &quot;withdraw() must deduct the correct number of shares from the owner&quot;);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'>}</span>
 112 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/properties/MustNotRevertProps.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;../util/ERC4626PropertyTestBase.sol&quot;;</span>
   4 |     | <span class='unexecuted'>import {CryticERC4626VaultProxy} from &quot;./VaultProxy.sol&quot;;</span>
   5 |     | <span class='neutral'>contract CryticERC4626MustNotRevert is CryticERC4626PropertyBase, CryticERC4626VaultProxy {</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
   8 |     | <span class='neutral'>    /// - vault.asset() must not revert</span>
   9 | *   | <span class='executed'>    function verify_assetMustNotRevert() public {</span>
  10 | *   | <span class='executed'>        try vault.asset() {</span>
  11 |     | <span class='neutral'>            return;</span>
  12 |     | <span class='neutral'>        } catch {</span>
  13 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.asset() must not revert&quot;);</span>
  14 |     | <span class='neutral'>        }</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
  18 |     | <span class='neutral'>    /// - vault.totalAssets() must not revert</span>
  19 | *r  | <span class='executed'>    function verify_totalAssetsMustNotRevert() public {</span>
  20 | *r  | <span class='executed'>        try vault.totalAssets() {</span>
  21 |     | <span class='neutral'>            return;</span>
  22 |     | <span class='neutral'>        } catch {</span>
  23 | *   | <span class='executed'>            assertWithMsg(false, &quot;vault.totalAssets() must not revert&quot;);</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
  28 |     | <span class='neutral'>    /// - vault.convertToAssets() must not revert for reasonable values</span>
  29 | *r  | <span class='executed'>    function verify_convertToAssetsMustNotRevert(uint256 shares) public {</span>
  30 |     | <span class='neutral'>        // arbitrarily define &quot;reasonable values&quot; to be 10**(token.decimals+20)</span>
  31 | *r  | <span class='executed'>        uint256 reasonably_largest_value = 10**(vault.decimals()+20);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>        // prevent scenarios where there is enough totalSupply to trigger overflows</span>
  34 | *r  | <span class='executed'>        require(vault.totalSupply() &lt;= reasonably_largest_value);</span>
  35 | *   | <span class='executed'>        shares = clampLte(shares, reasonably_largest_value);</span>
  36 |     | <span class='neutral'> </span>
  37 |     | <span class='neutral'>        // exclude the possibility of idiosyncratic reverts. Might have to add more in future.</span>
  38 | *   | <span class='executed'>        shares = clampLte(shares, vault.totalSupply());</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>        emit LogUint256(&quot;totalSupply&quot;, vault.totalSupply());</span>
  41 | *   | <span class='executed'>        emit LogUint256(&quot;totalAssets&quot;, vault.totalAssets());</span>
  42 |     | <span class='neutral'>        </span>
  43 |     | <span class='neutral'></span>
  44 | *   | <span class='executed'>        try vault.convertToAssets(shares) {</span>
  45 |     | <span class='neutral'>            return;</span>
  46 |     | <span class='neutral'>        } catch {</span>
  47 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.convertToAssets() must not revert&quot;);</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Validates the following properties:</span>
  52 |     | <span class='neutral'>    /// - vault.convertToShares() must not revert for reasonable values</span>
  53 | *r  | <span class='executed'>    function verify_convertToSharesMustNotRevert(uint256 tokens) public {</span>
  54 |     | <span class='neutral'>        // arbitrarily define &quot;reasonable values&quot; to be 10**(token.decimals+20)</span>
  55 | *r  | <span class='executed'>        uint256 reasonably_largest_value = 10**(asset.decimals()+20);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // prevent scenarios where there is enough totalSupply to trigger overflows</span>
  58 | *r  | <span class='executed'>        require(asset.totalSupply() &lt;= reasonably_largest_value);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        // exclude the possibility of idiosyncratic reverts. Might have to add more in future.</span>
  61 | *r  | <span class='executed'>        tokens = clampLte(tokens, asset.totalSupply());</span>
  62 |     | <span class='neutral'></span>
  63 | *r  | <span class='executed'>        try vault.convertToShares(tokens) {</span>
  64 | *r  | <span class='executed'>            return;</span>
  65 |     | <span class='neutral'>        } catch {</span>
  66 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.convertToShares() must not revert&quot;);</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 | *   | <span class='executed'>    function verify_maxDepositMustNotRevert(address owner) public {</span>
  71 | *   | <span class='executed'>        try vault.maxDeposit(owner) {</span>
  72 |     | <span class='neutral'>            return;</span>
  73 |     | <span class='neutral'>        } catch {</span>
  74 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.maxDeposit() must not revert&quot;);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 | *   | <span class='executed'>    function verify_maxMintMustNotRevert(address owner) public {</span>
  79 | *   | <span class='executed'>        try vault.maxMint(owner) {</span>
  80 |     | <span class='neutral'>            return;</span>
  81 |     | <span class='neutral'>        } catch {</span>
  82 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.maxMint() must not revert&quot;);</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 | *r  | <span class='executed'>    function verify_maxRedeemMustNotRevert(address owner) public {</span>
  87 |     | <span class='neutral'>        // if the following reverts from overflow, bail out.</span>
  88 |     | <span class='neutral'>        // additional criterion might be required in the future</span>
  89 | *r  | <span class='executed'>        vault.convertToAssets(vault.balanceOf(owner));</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>        try vault.maxRedeem(owner) {</span>
  92 |     | <span class='neutral'>            return;</span>
  93 |     | <span class='neutral'>        } catch {</span>
  94 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.maxRedeem() must not revert&quot;);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 | *r  | <span class='executed'>    function verify_maxWithdrawMustNotRevert(address owner) public {</span>
  99 |     | <span class='neutral'>        // if the following reverts from overflow, bail out.</span>
 100 |     | <span class='neutral'>        // additional criterion might be required in the future</span>
 101 | *r  | <span class='executed'>        vault.convertToAssets(vault.balanceOf(owner));</span>
 102 |     | <span class='neutral'>        </span>
 103 | *   | <span class='executed'>        try vault.maxWithdraw(owner) {</span>
 104 |     | <span class='neutral'>            return;</span>
 105 |     | <span class='neutral'>        } catch {</span>
 106 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.maxWithdraw() must not revert&quot;);</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'>}</span>
 110 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/properties/RedeemUsingApprovalProps.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;../util/ERC4626PropertyTestBase.sol&quot;;</span>
  3 |     | <span class='neutral'>import {CryticERC4626VaultProxy} from &quot;./VaultProxy.sol&quot;;</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>contract CryticERC4626RedeemUsingApproval is CryticERC4626PropertyBase, CryticERC4626VaultProxy {</span>
  6 |     | <span class='neutral'>    </span>
  7 |     | <span class='neutral'>    /// @notice verifies `redeem()` must allow proxies to redeem shares on behalf of the owner using share token approvals</span>
  8 |     | <span class='neutral'>    ///         verifies third party `redeem()` calls must update the msg.sender&#39;s allowance </span>
  9 | *r  | <span class='executed'>    function verify_redeemViaApprovalProxy(uint256 receiverId, uint256 shares) public returns (uint256 tokensWithdrawn){</span>
 10 | *r  | <span class='executed'>        address owner = address(this);</span>
 11 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 12 | *r  | <span class='executed'>        shares = requireValidRedeemAmount(owner, shares);  </span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>        vault.approve(address(redemptionProxy), shares);</span>
 15 | *   | <span class='executed'>        measureAddressHoldings(address(this), &quot;vault&quot;, &quot;before redeemption&quot;);</span>
 16 |     | <span class='neutral'></span>
 17 | *   | <span class='executed'>        try redemptionProxy.redeemOnBehalf(shares, receiver, owner) returns (uint256 _tokensWithdrawn){</span>
 18 | *   | <span class='executed'>            tokensWithdrawn = _tokensWithdrawn;</span>
 19 |     | <span class='neutral'>        } catch {</span>
 20 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;vault.redeem() reverted during redeem via approval&quot;);</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>        // verify allowance is updated</span>
 24 | *   | <span class='executed'>        uint256 newAllowance = vault.allowance(owner,address(redemptionProxy));</span>
 25 | *   | <span class='executed'>        assertEq(newAllowance, 0, &quot;The vault failed to update the redemption proxy&#39;s share allowance&quot;);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /// @notice verifies `withdraw()` must allow proxies to withdraw shares on behalf of the owner using share token approvals</span>
 29 |     | <span class='neutral'>    ///         verifies third party `withdraw()` calls must update the msg.sender&#39;s allowance </span>
 30 | r   | <span class='reverted'>    function verify_withdrawViaApprovalProxy(uint256 receiverId, uint256 tokens) public returns (uint256 sharesBurned){</span>
 31 | r   | <span class='reverted'>        address owner = address(this);</span>
 32 | r   | <span class='reverted'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 33 | r   | <span class='reverted'>        tokens = requireValidWithdrawAmount(owner, tokens);</span>
 34 |     | <span class='neutral'></span>
 35 | r   | <span class='reverted'>        uint256 expectedSharesConsumed = vault.previewWithdraw(tokens);</span>
 36 | r   | <span class='reverted'>        vault.approve(address(redemptionProxy), expectedSharesConsumed);</span>
 37 | r   | <span class='reverted'>        measureAddressHoldings(address(this), &quot;vault&quot;, &quot;before withdraw&quot;);</span>
 38 |     | <span class='neutral'></span>
 39 | r   | <span class='reverted'>        try redemptionProxy.withdrawOnBehalf(tokens, receiver, owner) returns (uint256 _sharesBurned) {</span>
 40 |     | <span class='unexecuted'>            sharesBurned = _sharesBurned;</span>
 41 |     | <span class='neutral'>        } catch {</span>
 42 | r   | <span class='reverted'>            assertWithMsg(false, &quot;vault.withdraw() reverted during withdraw via approval&quot;);</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>        emit LogUint256(&quot;withdraw consumed this many shares:&quot;, sharesBurned);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>        // verify allowance is updated</span>
 48 |     | <span class='unexecuted'>        uint256 newAllowance = vault.allowance(owner, address(redemptionProxy));</span>
 49 |     | <span class='unexecuted'>        uint256 expectedAllowance = expectedSharesConsumed - sharesBurned;</span>
 50 |     | <span class='unexecuted'>        emit LogUint256(&quot;Expecting allowance to now be:&quot;, expectedAllowance);</span>
 51 |     | <span class='unexecuted'>        assertEq(expectedAllowance, newAllowance, &quot;The vault failed to update the redemption proxy&#39;s share allowance&quot;);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @notice verifies third parties must not be able to `withdraw()` tokens on an owner&#39;s behalf without a token approval </span>
 55 | *r  | <span class='executed'>    function verify_withdrawRequiresTokenApproval(uint256 receiverId, uint256 tokens, uint256 sharesApproved) public {</span>
 56 | *r  | <span class='executed'>        address owner = address(this);</span>
 57 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 58 | *r  | <span class='executed'>        tokens = requireValidWithdrawAmount(owner, tokens);</span>
 59 | *r  | <span class='executed'>        uint256 expectedSharesConsumed = vault.previewWithdraw(tokens);</span>
 60 | *r  | <span class='executed'>        emit LogUint256(&quot;Will attempt to proxy withdraw this many shares:&quot;, expectedSharesConsumed);</span>
 61 |     | <span class='neutral'></span>
 62 | *r  | <span class='executed'>        require(sharesApproved &lt; expectedSharesConsumed);</span>
 63 | *   | <span class='executed'>        emit LogUint256(&quot;Approving spend of this many shares:&quot;, sharesApproved);</span>
 64 | *   | <span class='executed'>        vault.approve(address(redemptionProxy), sharesApproved);</span>
 65 |     | <span class='neutral'></span>
 66 | *r  | <span class='executed'>        try redemptionProxy.withdrawOnBehalf(tokens, receiver, owner) returns (uint256 _sharesBurned) {</span>
 67 | *   | <span class='executed'>            assertLte(_sharesBurned, sharesApproved, &quot;Redemption proxy must not be able to withdraw more shares than it was approved&quot;);</span>
 68 |     | <span class='neutral'>        } catch {  }</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'>    </span>
 71 |     | <span class='neutral'>    /// @notice verifies third parties must not be able to `redeem()` shares on an owner&#39;s behalf without a token approval </span>
 72 | *r  | <span class='executed'>    function verify_redeemRequiresTokenApproval(uint256 receiverId, uint256 shares, uint256 sharesApproved) public {</span>
 73 | *r  | <span class='executed'>        address owner = address(this);</span>
 74 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 75 | *r  | <span class='executed'>        shares = requireValidRedeemAmount(owner, shares);</span>
 76 | *r  | <span class='executed'>        emit LogUint256(&quot;Will attempt to proxy redeem this many shares:&quot;, shares);</span>
 77 |     | <span class='neutral'></span>
 78 | *r  | <span class='executed'>        require(sharesApproved &lt; shares);</span>
 79 | *   | <span class='executed'>        emit LogUint256(&quot;Approving spend of this many shares:&quot;, sharesApproved);</span>
 80 | *   | <span class='executed'>        vault.approve(address(redemptionProxy), sharesApproved);</span>
 81 |     | <span class='neutral'></span>
 82 | *   | <span class='executed'>        try redemptionProxy.redeemOnBehalf(shares, receiver, owner) returns (uint256 _sharesBurned) {</span>
 83 |     | <span class='unexecuted'>            assertLte(_sharesBurned, sharesApproved, &quot;Redemption proxy must not be able to redeem more shares than it was approved&quot;);</span>
 84 |     | <span class='neutral'>        } catch {  }</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'>}</span>
 87 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/properties/RoundingProps.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;../util/ERC4626PropertyTestBase.sol&quot;;</span>
   3 |     | <span class='neutral'>import {CryticERC4626VaultProxy} from &quot;./VaultProxy.sol&quot;;</span>
   4 |     | <span class='unexecuted'></span>
   5 |     | <span class='neutral'>contract CryticERC4626Rounding is CryticERC4626PropertyBase, CryticERC4626VaultProxy {</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    /// @notice verifies shares may never be minted for free using previewDeposit()</span>
   8 | r   | <span class='reverted'>    function verify_previewDepositRoundingDirection() public {</span>
   9 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  10 |     | <span class='unexecuted'>        uint256 sharesMinted = vault.previewDeposit(0);</span>
  11 |     | <span class='unexecuted'>        assertEq(sharesMinted, 0, &quot;previewDeposit() must not mint shares at no cost&quot;);</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice verifies shares may never be minted for free using previewMint()</span>
  15 | r   | <span class='reverted'>    function verify_previewMintRoundingDirection(uint256 shares) public {</span>
  16 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  17 |     | <span class='unexecuted'>        require(shares &gt; 0);</span>
  18 |     | <span class='unexecuted'>        uint256 tokensConsumed = vault.previewMint(shares);</span>
  19 |     | <span class='unexecuted'>        assertGt(tokensConsumed, 0, &quot;previewMint() must never mint shares at no cost&quot;);</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /// @notice verifies shares may never be minted for free using convertToShares()</span>
  23 | r   | <span class='reverted'>    function verify_convertToSharesRoundingDirection() public {</span>
  24 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  25 |     | <span class='neutral'>        // note: the correctness of this property can&#39;t be tested using solmate as a reference impl. 0/n=0. best case scenario, some other property gets set off.</span>
  26 |     | <span class='unexecuted'>        uint256 tokensWithdrawn = vault.convertToShares(0);</span>
  27 |     | <span class='unexecuted'>        assertEq(tokensWithdrawn, 0, &quot;convertToShares() must not allow shares to be minted at no cost&quot;);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /// @notice verifies tokens may never be withdrawn for free using previewRedeem()</span>
  31 | r   | <span class='reverted'>    function verify_previewRedeemRoundingDirection() public {</span>
  32 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  33 |     | <span class='unexecuted'>        uint256 tokensWithdrawn = vault.previewRedeem(0);</span>
  34 |     | <span class='unexecuted'>        assertEq(tokensWithdrawn, 0, &quot;previewRedeem() must not allow assets to be withdrawn at no cost&quot;);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /// @notice verifies tokens may never be withdrawn for free using previewWithdraw()</span>
  38 | *r  | <span class='executed'>    function verify_previewWithdrawRoundingDirection(uint256 tokens) public {</span>
  39 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  40 |     | <span class='unexecuted'>        require(tokens &gt; 0);</span>
  41 |     | <span class='unexecuted'>        uint256 sharesRedeemed = vault.previewWithdraw(tokens);</span>
  42 | *   | <span class='executed'>        assertGt(sharesRedeemed, 0, &quot;previewWithdraw() must not allow assets to be withdrawn at no cost&quot;);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice verifies tokens may never be withdrawn for free using convertToAssets()</span>
  46 | r   | <span class='reverted'>    function verify_convertToAssetsRoundingDirection() public {</span>
  47 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  48 |     | <span class='neutral'>        // note: the correctness of this property can&#39;t be tested using solmate as a reference impl. 0/n=0. best case scenario, some other property gets set off.</span>
  49 |     | <span class='unexecuted'>        uint256 tokensWithdrawn = vault.convertToAssets(0);</span>
  50 |     | <span class='unexecuted'>        assertEq(tokensWithdrawn, 0, &quot;convertToAssets() must not allow assets to be withdrawn at no cost&quot;);</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /// @notice Indirectly verifies the rounding direction of convertToShares/convertToAssets is correct by attempting to</span>
  54 |     | <span class='neutral'>    ///         create an arbitrage by depositing, then withdrawing</span>
  55 | r   | <span class='reverted'>    function verify_convertRoundTrip(uint256 amount) public {</span>
  56 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  57 |     | <span class='unexecuted'>        uint256 sharesMinted = vault.convertToShares(amount);</span>
  58 |     | <span class='unexecuted'>        uint256 tokensWithdrawn = vault.convertToAssets(sharesMinted);</span>
  59 |     | <span class='unexecuted'>        assertGte(amount, tokensWithdrawn, &quot;A profit was extractable from a convertTo round trip (deposit, then withdraw)&quot;);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /// @notice Indirectly verifies the rounding direction of convertToShares/convertToAssets is correct by attempting to</span>
  63 |     | <span class='neutral'>    ///         create an arbitrage by withdrawing, then depositing</span>
  64 | r   | <span class='reverted'>    function verify_convertRoundTrip2(uint256 amount) public {</span>
  65 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  66 |     | <span class='unexecuted'>        uint256 tokensWithdrawn = vault.convertToAssets(amount);</span>
  67 |     | <span class='unexecuted'>        uint256 sharesMinted = vault.convertToShares(tokensWithdrawn);</span>
  68 |     | <span class='unexecuted'>        assertGte(amount, sharesMinted, &quot;A profit was extractable from a convertTo round trip (withdraw, then deposit)&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /// @notice verifies Shares may never be minted for free using deposit()</span>
  72 | r   | <span class='reverted'>    function verify_depositRoundingDirection() public {</span>
  73 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  74 |     | <span class='unexecuted'>        uint256 shares = vault.deposit(0, address(this));</span>
  75 |     | <span class='unexecuted'>        assertEq(shares, 0, &quot;Shares must not be minted for free&quot;);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice verifies Shares may never be minted for free using mint()</span>
  79 | r   | <span class='reverted'>    function verify_mintRoundingDirection(uint256 shares) public {</span>
  80 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  81 |     | <span class='unexecuted'>        require(shares &gt; 0);</span>
  82 |     | <span class='unexecuted'>        uint256 tokensDeposited = vault.mint(shares, address(this));</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        assertGt(tokensDeposited, 0, &quot;Shares must not be minted for free&quot;);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /// @notice verifies tokens may never be withdrawn for free using withdraw()</span>
  88 | r   | <span class='reverted'>    function verify_withdrawRoundingDirection(uint256 tokens) public {</span>
  89 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  90 |     | <span class='unexecuted'>        require(tokens &gt; 0);</span>
  91 |     | <span class='unexecuted'>        uint256 sharesRedeemed = vault.withdraw(tokens, address(this), address(this));</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        assertGt(sharesRedeemed, 0, &quot;Token must not be withdrawn for free&quot;);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /// @notice verifies tokens may never be withdrawn for free using redeem()</span>
  97 | r   | <span class='reverted'>    function verify_redeemRoundingDirection() public {</span>
  98 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  99 |     | <span class='unexecuted'>        uint256 tokensWithdrawn = vault.redeem(0, address(this), address(this));</span>
 100 |     | <span class='unexecuted'>        assertEq(tokensWithdrawn, 0, &quot;Tokens must not be withdrawn for free&quot;);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'>}</span>
 103 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/properties/SecurityProps.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;../util/ERC4626PropertyTestBase.sol&quot;;</span>
  3 |     | <span class='unexecuted'></span>
  4 |     | <span class='neutral'>contract CryticERC4626SecurityProps is CryticERC4626PropertyBase {</span>
  5 |     | <span class='neutral'>    /// @notice verify `decimals()` should be larger than or equal to `asset.decimals()` </span>
  6 | *   | <span class='executed'>    function verify_assetDecimalsLessThanVault() public {</span>
  7 | *   | <span class='executed'>        assertGte(vault.decimals(), asset.decimals(), &quot;The vault&#39;s share token should have greater than or equal to the number of decimals as the vault&#39;s asset token.&quot;);</span>
  8 |     | <span class='neutral'>    }</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @notice verify Accounting system must not be vulnerable to share price inflation attacks </span>
 11 | *r  | <span class='executed'>    function verify_sharePriceInflationAttack(uint256 inflateAmount, uint256 delta) public {</span>
 12 |     | <span class='neutral'>        // this has to be changed if there&#39;s deposit/withdraw fees</span>
 13 | *r  | <span class='executed'>        uint256 lossThreshold = 0.999 ether;</span>
 14 |     | <span class='neutral'>        // vault is fresh</span>
 15 | *r  | <span class='executed'>        require(vault.totalAssets() == 0);</span>
 16 | *r  | <span class='executed'>        require(vault.totalSupply() == 0);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>        // these minimums are to prevent 1-wei rounding errors from triggering the property</span>
 19 | *r  | <span class='executed'>        require(inflateAmount &gt; 10000);</span>
 20 | *r  | <span class='executed'>        uint256 victimDeposit = inflateAmount + delta;</span>
 21 | *r  | <span class='executed'>        address attacker = address(this);</span>
 22 |     | <span class='neutral'>        // fund account</span>
 23 | *r  | <span class='executed'>        prepareAddressForDeposit(attacker, inflateAmount);</span>
 24 |     | <span class='neutral'></span>
 25 | *r  | <span class='executed'>        uint256 shares = vault.deposit(1, attacker);</span>
 26 |     | <span class='neutral'>        // attack only works when pps=1:1 + new vault</span>
 27 | *r  | <span class='executed'>        require(shares == 1);</span>
 28 | *r  | <span class='executed'>        require(vault.totalAssets() == 1);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>        // inflate pps</span>
 31 | *r  | <span class='executed'>        asset.transfer(address(vault), inflateAmount-1);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>        // fund victim</span>
 34 | *r  | <span class='executed'>        alice.fund(victimDeposit);</span>
 35 | *r  | <span class='executed'>        alice.approveFunds();</span>
 36 |     | <span class='neutral'></span>
 37 | *r  | <span class='executed'>        emit LogUint256(&quot;Amount of alice&#39;s deposit:&quot;, victimDeposit);</span>
 38 | *r  | <span class='executed'>        uint256 aliceShares = alice.depositFunds(victimDeposit);</span>
 39 | *r  | <span class='executed'>        emit LogUint256(&quot;Alice Shares:&quot;, aliceShares);</span>
 40 | *r  | <span class='executed'>        uint256 aliceWithdrawnFunds = alice.redeemShares(aliceShares);</span>
 41 | *r  | <span class='executed'>        emit LogUint256(&quot;Amount of tokens alice withdrew:&quot;, aliceWithdrawnFunds);</span>
 42 |     | <span class='neutral'></span>
 43 | *r  | <span class='executed'>        uint256 victimLoss = victimDeposit - aliceWithdrawnFunds;</span>
 44 | *r  | <span class='executed'>        emit LogUint256(&quot;Alice Loss:&quot;, victimLoss);</span>
 45 |     | <span class='neutral'></span>
 46 | *r  | <span class='executed'>        uint256 minRedeemedAmountNorm = (victimDeposit * lossThreshold) / 1 ether;</span>
 47 |     | <span class='neutral'></span>
 48 | *r  | <span class='executed'>        emit LogUint256(&quot;lossThreshold&quot;, lossThreshold);</span>
 49 | *r  | <span class='executed'>        emit LogUint256(&quot;minRedeemedAmountNorm&quot;, minRedeemedAmountNorm);</span>
 50 | *r  | <span class='executed'>        assertGt(aliceWithdrawnFunds, minRedeemedAmountNorm, &quot;Share inflation attack possible, victim lost an amount over lossThreshold%&quot;);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/properties/SenderIndependentProps.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;../util/ERC4626PropertyTestBase.sol&quot;;</span>
  3 |     | <span class='unexecuted'></span>
  4 |     | <span class='neutral'>contract CryticERC4626SenderIndependent is CryticERC4626PropertyBase {</span>
  5 |     | <span class='neutral'>    // todo: these properties may have issues in vaults that have super weird redemption curves. </span>
  6 |     | <span class='neutral'>    // If that happens, use a proxy contract to compare results instead of msg.sender&#39;s state</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    /// @notice verify `maxDeposit()` assumes the receiver/sender has infinite assets</span>
  9 | *r  | <span class='executed'>    function verify_maxDepositIgnoresSenderAssets(uint256 tokens) public {</span>
 10 | *r  | <span class='executed'>        address receiver = address(this);</span>
 11 | *r  | <span class='executed'>        uint256 maxDepositBefore = vault.maxDeposit(receiver);</span>
 12 | *r  | <span class='executed'>        asset.mint(receiver, tokens);</span>
 13 | *   | <span class='executed'>        uint256 maxDepositAfter = vault.maxDeposit(receiver);</span>
 14 | *   | <span class='executed'>        assertEq(maxDepositBefore, maxDepositAfter, &quot;maxDeposit must assume the agent has infinite assets&quot;);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @notice verify `maxMint()` assumes the receiver/sender has infinite assets</span>
 18 | *r  | <span class='executed'>    function verify_maxMintIgnoresSenderAssets(uint256 tokens) public {</span>
 19 | *r  | <span class='executed'>        address receiver = address(this);</span>
 20 | *r  | <span class='executed'>        uint256 maxMintBefore = vault.maxMint(receiver);</span>
 21 | *r  | <span class='executed'>        asset.mint(receiver, tokens);</span>
 22 | *   | <span class='executed'>        uint256 maxMintAfter = vault.maxMint(receiver);</span>
 23 | *   | <span class='executed'>        assertEq(maxMintBefore, maxMintAfter, &quot;maxMint must assume the agent has infinite assets&quot;);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /// @notice verify `previewMint()` does not account for msg.sender asset balance</span>
 27 | *r  | <span class='executed'>    function verify_previewMintIgnoresSender(uint256 tokens, uint256 shares) public {</span>
 28 | *r  | <span class='executed'>        address receiver = address(this);</span>
 29 | *r  | <span class='executed'>        uint256 assetsExpectedBefore = vault.previewMint(shares);</span>
 30 | *r  | <span class='executed'>        prepareAddressForDeposit(receiver, tokens);</span>
 31 |     | <span class='neutral'></span>
 32 | *   | <span class='executed'>        uint256 assetsExpectedAfter = vault.previewMint(shares);</span>
 33 | *   | <span class='executed'>        assertEq(assetsExpectedBefore, assetsExpectedAfter, &quot;previewMint must not be dependent on msg.sender&quot;);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice verify `previewDeposit()` does not account for msg.sender asset balance</span>
 37 | *r  | <span class='executed'>    function verify_previewDepositIgnoresSender(uint256 tokens) public {</span>
 38 | *r  | <span class='executed'>        address receiver = address(this);</span>
 39 | *r  | <span class='executed'>        uint256 sharesExpectedBefore = vault.previewDeposit(tokens);</span>
 40 | *r  | <span class='executed'>        prepareAddressForDeposit(receiver, tokens);</span>
 41 |     | <span class='neutral'></span>
 42 | *   | <span class='executed'>        uint256 sharesExpectedAfter = vault.previewDeposit(tokens);</span>
 43 | *   | <span class='executed'>        assertEq(sharesExpectedBefore, sharesExpectedAfter, &quot;previewDeposit must not be dependent on msg.sender&quot;);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /// @notice verify `previewWithdraw()` does not account for msg.sender asset balance</span>
 47 | *r  | <span class='executed'>    function verify_previewWithdrawIgnoresSender(uint256 tokens) public {</span>
 48 | *r  | <span class='executed'>        address receiver = address(this);</span>
 49 | *r  | <span class='executed'>        uint256 sharesExpectedBefore = vault.previewWithdraw(tokens);</span>
 50 | *r  | <span class='executed'>        prepareAddressForDeposit(receiver, tokens);</span>
 51 |     | <span class='neutral'></span>
 52 | *r  | <span class='executed'>        vault.deposit(tokens, receiver);</span>
 53 |     | <span class='neutral'></span>
 54 | *r  | <span class='executed'>        uint256 sharesExpectedAfter = vault.previewWithdraw(tokens);</span>
 55 | *r  | <span class='executed'>        assertEq(sharesExpectedBefore, sharesExpectedAfter, &quot;previewWithdraw must not be dependent on msg.sender&quot;);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>        // keep this property relatively stateless</span>
 58 | *r  | <span class='executed'>        vault.redeem(vault.balanceOf(receiver), receiver, receiver);</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'>    </span>
 61 |     | <span class='neutral'>    /// @notice verify `previewRedeem()` does not account for msg.sender asset balance</span>
 62 | *r  | <span class='executed'>    function verify_previewRedeemIgnoresSender(uint256 shares) public {</span>
 63 | *r  | <span class='executed'>        address receiver = address(this);</span>
 64 | *r  | <span class='executed'>        uint256 tokensExpectedBefore = vault.previewRedeem(shares);</span>
 65 |     | <span class='neutral'></span>
 66 | *r  | <span class='executed'>        uint256 assetsToDeposit = vault.previewMint(shares);</span>
 67 | *r  | <span class='executed'>        prepareAddressForDeposit(receiver, assetsToDeposit);</span>
 68 |     | <span class='neutral'>        </span>
 69 | *r  | <span class='executed'>        vault.deposit(assetsToDeposit, receiver);</span>
 70 |     | <span class='neutral'></span>
 71 | *r  | <span class='executed'>        uint256 tokensExpectedAfter = vault.previewRedeem(shares);</span>
 72 | *r  | <span class='executed'>        assertEq(tokensExpectedBefore, tokensExpectedAfter, &quot;previewRedeem must not be dependent on msg.sender&quot;);</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>        // keep this property relatively stateless</span>
 75 | *r  | <span class='executed'>        vault.redeem(vault.balanceOf(receiver), receiver, receiver);</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/properties/VaultProxy.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'>import {CryticERC4626PropertyBase} from &quot;../util/ERC4626PropertyTestBase.sol&quot;;</span>
  3 |     | <span class='neutral'>import {CryticIERC4626Internal} from &quot;../util/IERC4626Internal.sol&quot;;</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>contract CryticERC4626VaultProxy is CryticERC4626PropertyBase {</span>
  6 | r   | <span class='reverted'>    function recognizeProfitProxy(uint256 profit) public {</span>
  7 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
  8 |     | <span class='unexecuted'>        require(vault.totalSupply() &gt; 0);</span>
  9 |     | <span class='unexecuted'>        CryticIERC4626Internal(address(vault)).recognizeProfit(profit);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 | r   | <span class='reverted'>    function recognizeLossProxy(uint256 loss) public {</span>
 13 | r   | <span class='reverted'>        require(supportsInternalTestingIface);</span>
 14 |     | <span class='unexecuted'>        require(vault.totalSupply() &gt; 0);</span>
 15 |     | <span class='unexecuted'>        CryticIERC4626Internal(address(vault)).recognizeLoss(loss);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @dev intended to be used when property violations are being shrunk</span>
 19 | *r  | <span class='executed'>    function depositForSelfSimple(uint256 assets) public {</span>
 20 | *r  | <span class='executed'>        asset.mint(address(this), assets);</span>
 21 | *r  | <span class='executed'>        asset.approve(address(vault), assets);</span>
 22 | *r  | <span class='executed'>        vault.deposit(assets, address(this));</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 | *r  | <span class='executed'>    function redeemForSelfSimple(uint256 shares) public {</span>
 26 | *r  | <span class='executed'>        shares = clampLte(shares, vault.balanceOf(address(this)));</span>
 27 | *r  | <span class='executed'>        vault.redeem(shares, address(this), address(this));</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    // consider removing/refactoring the following since they&#39;re so unlikely to be useful during testing</span>
 31 | *r  | <span class='executed'>    function deposit(uint256 assets, uint256 receiverId) public {</span>
 32 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 33 | *r  | <span class='executed'>        vault.deposit(assets, receiver);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 | r   | <span class='reverted'>    function withdraw(uint256 assets, uint256 ownerId, uint256 receiverId) public {</span>
 37 | r   | <span class='reverted'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 38 | r   | <span class='reverted'>        address owner = restrictAddressToThirdParties(ownerId);</span>
 39 | r   | <span class='reverted'>        vault.withdraw(assets, receiver, owner);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 | *r  | <span class='executed'>    function mint(uint256 shares, uint256 receiverId) public {</span>
 43 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 44 | *r  | <span class='executed'>        vault.mint(shares, receiver);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 | *r  | <span class='executed'>    function redeem(uint256 shares, uint256 ownerId, uint256 receiverId) public {</span>
 48 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 49 | *r  | <span class='executed'>        address owner = restrictAddressToThirdParties(ownerId);</span>
 50 | *r  | <span class='executed'>        vault.redeem(shares, receiver, owner);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 | *r  | <span class='executed'>    function mintAsset(uint256 assets, uint256 receiverId) public {</span>
 54 | *r  | <span class='executed'>        address receiver = restrictAddressToThirdParties(receiverId);</span>
 55 | *r  | <span class='executed'>        asset.mint(receiver, assets);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/util/Actor.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import {IERC4626} from &quot;../../util/IERC4626.sol&quot;;</span>
  4 |     | <span class='neutral'>import {TestERC20Token} from &quot;../util/TestERC20Token.sol&quot;;</span>
  5 |     | <span class='neutral'>import {PropertiesAsserts} from &quot;../../util/PropertiesHelper.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @notice This contract has two purposes:</span>
  8 |     | <span class='neutral'>///  1. Act as a proxy for performing vault deposits/withdraws (since we don&#39;t have vm.prank)</span>
  9 |     | <span class='neutral'>///  2. Keep track of how much the account has deposited/withdrawn &amp; raise an error if the account can withdraw/redeem more than it deposited/minted.</span>
 10 |     | <span class='neutral'>/// @dev It&#39;s important that other property tests never send tokens/shares to the Actor contract address, or else the accounting will break. This restriction is enforced in restrictAddressToThirdParties()</span>
 11 | *r  | <span class='executed'>///      If support is added for &quot;harvesting&quot; a vault during property tests, the accounting logic here needs to be updated to reflect cases where an actor can withdraw more than they deposited.</span>
 12 |     | <span class='neutral'>contract Actor is PropertiesAsserts {</span>
 13 |     | <span class='neutral'>    TestERC20Token token;</span>
 14 |     | <span class='neutral'>    IERC4626 vault;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    uint256 tokensDeposited; //tracks how many aggregate tokens this actor has deposited on its own behalf</span>
 17 |     | <span class='neutral'>    uint256 sharesMinted; //tracks how many aggregate shares this actor has minted on its own behalf</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    constructor(IERC4626 _vault) {</span>
 20 |     | <span class='unexecuted'>        vault = _vault;</span>
 21 |     | <span class='unexecuted'>        token = TestERC20Token(address(_vault.asset()));</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 | *r  | <span class='executed'>    function accountForOpenedPosition(uint256 _tokensDeposited, uint256 _sharesMinted) internal {</span>
 25 | *r  | <span class='executed'>        tokensDeposited += _tokensDeposited;</span>
 26 | *r  | <span class='executed'>        sharesMinted += _sharesMinted;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 | *r  | <span class='executed'>    function accountForClosedPosition(uint256 _tokensReceived, uint256 _sharesBurned) internal {</span>
 30 | *r  | <span class='executed'>        assertLte(_sharesBurned, sharesMinted,  &quot;Actor has burned more shares than they ever minted. Implies a rounding or accounting error&quot;);</span>
 31 | *r  | <span class='executed'>        assertLte(_tokensReceived, tokensDeposited,  &quot;Actor has withdrawn more tokens than they ever deposited. Implies a rounding or accounting error&quot;);</span>
 32 | *r  | <span class='executed'>        tokensDeposited -= _tokensReceived;</span>
 33 | *r  | <span class='executed'>        sharesMinted -= _sharesBurned;</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 | *r  | <span class='executed'>    function fund(uint256 amount) public {</span>
 37 | *r  | <span class='executed'>        token.mint(address(this), amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 | *r  | <span class='executed'>    function approveFunds() public {</span>
 41 | *r  | <span class='executed'>        token.approve(address(vault), type(uint256).max);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 | *r  | <span class='executed'>    function depositFunds(uint256 assets) public returns (uint256 _sharesMinted) {</span>
 45 | *r  | <span class='executed'>        _sharesMinted = vault.deposit(assets, address(this));</span>
 46 | *r  | <span class='executed'>        accountForOpenedPosition(assets, _sharesMinted);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function mintShares(uint256 shares) public returns (uint256 _tokensDeposited) {</span>
 50 |     | <span class='unexecuted'>        _tokensDeposited = vault.mint(shares, address(this));</span>
 51 |     | <span class='unexecuted'>        accountForOpenedPosition(_tokensDeposited, shares);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 | *r  | <span class='executed'>    function withdrawTokens(uint256 assets) public returns (uint256 _sharesBurned) {</span>
 55 |     | <span class='unexecuted'>        _sharesBurned = vault.withdraw(assets, address(this), address(this));</span>
 56 | *r  | <span class='executed'>        accountForClosedPosition(assets, _sharesBurned);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 | *r  | <span class='executed'>    function redeemShares(uint256 shares) public returns (uint256 _tokensWithdrawn) {</span>
 60 | *r  | <span class='executed'>        _tokensWithdrawn = vault.redeem(shares, address(this), address(this));</span>
 61 | *r  | <span class='executed'>        accountForClosedPosition(_tokensWithdrawn, shares);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 | *r  | <span class='executed'>    function depositFundsOnBehalf(uint256 assets, address receiver) public returns (uint256 _sharesMinted) {</span>
 65 | *r  | <span class='executed'>        _sharesMinted = vault.deposit(assets, receiver);</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>    function mintSharesOnBehalf(uint256 shares, address receiver) public returns (uint256 _tokensDeposited) {</span>
 69 |     | <span class='unexecuted'>        _tokensDeposited = vault.mint(shares, receiver);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='unexecuted'>    function withdrawTokensOnBehalf(uint256 assets, address receiver) public returns (uint256 _sharesBurned) {</span>
 73 |     | <span class='unexecuted'>        _sharesBurned = vault.withdraw(assets, receiver, address(this));</span>
 74 |     | <span class='unexecuted'>        accountForClosedPosition(assets, _sharesBurned);</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 | *r  | <span class='executed'>    function redeemSharesOnBehalf(uint256 shares, address receiver) public returns (uint256 _tokensWithdrawn) {</span>
 78 |     | <span class='unexecuted'>        _tokensWithdrawn = vault.redeem(shares, receiver, address(this));</span>
 79 | *r  | <span class='executed'>        accountForClosedPosition(_tokensWithdrawn, shares);</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'>}</span>
 82 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/util/ERC4626PropertyTestBase.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import {IERC20} from &quot;../../util/IERC20.sol&quot;;</span>
   4 |     | <span class='neutral'>import {IERC4626} from &quot;../../util/IERC4626.sol&quot;;</span>
   5 |     | <span class='neutral'>import {TestERC20Token} from &quot;./TestERC20Token.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Actor} from &quot;../util/Actor.sol&quot;;</span>
   7 |     | <span class='neutral'>import {PropertiesAsserts} from &quot;../../util/PropertiesHelper.sol&quot;;</span>
   8 |     | <span class='neutral'>import {RedemptionProxy} from &quot;./RedemptionProxy.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>/// @notice This contract is used as a base contract for all 4626 property tests.</span>
  11 |     | <span class='neutral'>contract CryticERC4626PropertyBase is PropertiesAsserts {</span>
  12 |     | <span class='neutral'>    TestERC20Token asset;</span>
  13 |     | <span class='neutral'>    IERC4626 vault;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    Actor alice;</span>
  16 |     | <span class='neutral'>    Actor bob; //remove?</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    RedemptionProxy redemptionProxy;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    // feature flags</span>
  21 |     | <span class='neutral'>    bool supportsInternalTestingIface;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function initialize(address _vault, address _asset, bool _supportsInternalTestingIface) internal {</span>
  24 |     | <span class='unexecuted'>        vault = IERC4626(_vault);</span>
  25 |     | <span class='unexecuted'>        asset = TestERC20Token(_asset);</span>
  26 |     | <span class='unexecuted'>        alice = new Actor(vault);</span>
  27 |     | <span class='unexecuted'>        bob = new Actor(vault);</span>
  28 |     | <span class='unexecuted'>        redemptionProxy = new RedemptionProxy(vault);</span>
  29 |     | <span class='unexecuted'>        supportsInternalTestingIface = _supportsInternalTestingIface;</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice Funds the `owner` address with `tokens` &amp; forces a token approval for the vault to spend owner&#39;s tokens.</span>
  33 | *r  | <span class='executed'>    function prepareAddressForDeposit(address owner, uint256 tokens) internal {</span>
  34 | *r  | <span class='executed'>        asset.mint(owner, tokens);</span>
  35 | *r  | <span class='executed'>        asset.forceApproval(owner, address(vault), tokens);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice Measures the `target`&#39;s assets and shares, and emits events to assist in debugging property failures.</span>
  39 |     | <span class='neutral'>    /// @param target A address to target</span>
  40 |     | <span class='neutral'>    /// @param name A name for the target address (alice, bob, vault, etc.)</span>
  41 |     | <span class='neutral'>    /// @param annotation An additional piece of metadata for debugging ie: &quot;before deposit&quot;, &quot;after mint&quot;, etc.</span>
  42 | *r  | <span class='executed'>    function measureAddressHoldings(address target, string memory name, string memory annotation) internal</span>
  43 | *r  | <span class='executed'>        returns (uint256 assetBalance, uint256 shareBalance) {</span>
  44 |     | <span class='neutral'></span>
  45 | *r  | <span class='executed'>        assetBalance = asset.balanceOf(target);</span>
  46 | *r  | <span class='executed'>        shareBalance = vault.balanceOf(target);</span>
  47 |     | <span class='neutral'>        </span>
  48 | *r  | <span class='executed'>        string memory assetMsg = string(abi.encodePacked(&quot;asset.balanceOf(&quot;, name, &quot;) (&quot;, annotation, &quot;)&quot;));</span>
  49 | *r  | <span class='executed'>        emit LogUint256(assetMsg, assetBalance);</span>
  50 | *r  | <span class='executed'>        string memory shareMsg = string(abi.encodePacked(&quot;vault.balanceOf(&quot;, name, &quot;) (&quot;, annotation, &quot;)&quot;));</span>
  51 | *r  | <span class='executed'>        emit LogUint256(shareMsg, shareBalance);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Prevents `party` from resolving to addresses which have special accounting rules.</span>
  55 | *r  | <span class='executed'>    function restrictAddressToThirdParties(uint256 partyIndex) internal view returns (address) {</span>
  56 |     | <span class='neutral'>        // set up 3 static third parties</span>
  57 | *r  | <span class='executed'>        partyIndex = partyIndex % 3;</span>
  58 | *r  | <span class='executed'>        if(partyIndex == 0){</span>
  59 | *r  | <span class='executed'>            return address(this);</span>
  60 |     | <span class='neutral'>        }</span>
  61 | *r  | <span class='executed'>        if(partyIndex == 1){</span>
  62 | *r  | <span class='executed'>            return 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa;</span>
  63 |     | <span class='neutral'>        }</span>
  64 | *r  | <span class='executed'>        return 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @notice Performs all the checks required to ensure a successful vault deposit. This includes funding the owner account and clamping token amounts as needed.</span>
  69 |     | <span class='neutral'>    ///         It is assumed that successful calls to requireValidDepositAmount imply that vault.deposit() will not revert. This implied property might not hold for certain</span>
  70 |     | <span class='neutral'>    ///         vault implementations, and should be modified if exceptions are discovered.</span>
  71 | *r  | <span class='executed'>    function requireValidDepositAmount(address owner, address receiver, uint256 tokens) internal returns (uint256) {</span>
  72 | *r  | <span class='executed'>        tokens = clampLte(tokens, vault.maxDeposit(receiver));</span>
  73 | *r  | <span class='executed'>        tokens = clampGt(tokens, 0);</span>
  74 | *r  | <span class='executed'>        prepareAddressForDeposit(owner, tokens);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // The following logic is intended to revert when an unreasonably large deposit is being made.</span>
  78 | *r  | <span class='executed'>        uint256 sharesMinted = vault.convertToShares(tokens);</span>
  79 | *r  | <span class='executed'>        uint256 currentShares = vault.balanceOf(receiver);</span>
  80 | *r  | <span class='executed'>        vault.convertToAssets(sharesMinted + currentShares);</span>
  81 |     | <span class='neutral'>        //uint256 sharesRedeemed = vault.previewWithdraw(tokensWithdrawn);</span>
  82 | *r  | <span class='executed'>        emit LogUint256(&quot;Tokens to use in deposit:&quot;, tokens);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // configure with setting?</span>
  85 | *r  | <span class='executed'>        require(vault.previewDeposit(tokens) &gt; 0);</span>
  86 | *   | <span class='executed'>        return tokens;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @notice Performs all the checks required to ensure a successful vault mint. This includes funding the owner account and clamping token amounts as needed.</span>
  90 |     | <span class='neutral'>    ///         It is assumed that successful calls to requireValidDepositAmount imply that vault.mint() will not revert. This implied property might not hold for certain</span>
  91 |     | <span class='neutral'>    ///         vault implementations, and should be modified if exceptions are discovered.</span>
  92 | *r  | <span class='executed'>    function requireValidMintAmount(address owner, address receiver, uint256 shares) internal returns (uint256) {</span>
  93 | *r  | <span class='executed'>        shares = clampLte(shares, vault.maxMint(receiver));</span>
  94 | *r  | <span class='executed'>        uint256 tokensDeposited = vault.previewMint(shares);</span>
  95 | *r  | <span class='executed'>        prepareAddressForDeposit(owner, tokensDeposited);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // The following logic is intended to revert when an unreasonably large mint is being made.</span>
  98 | *r  | <span class='executed'>        uint256 currentShares = vault.balanceOf(receiver);</span>
  99 | *r  | <span class='executed'>        vault.previewRedeem(currentShares + shares );</span>
 100 | *   | <span class='executed'>        emit LogUint256(&quot;Shares to use in mint:&quot;, shares);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        // configure with setting?</span>
 103 |     | <span class='neutral'>        // require(vault.previewMint(shares) &gt; 0);</span>
 104 | *   | <span class='executed'>        return shares;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /// @notice Performs all the checks required to ensure a successful vault redeem. This includes funding the owner account and clamping token amounts as needed.</span>
 108 |     | <span class='neutral'>    ///         It is assumed that successful calls to requireValidDepositAmount imply that vault.redeem() will not revert. This implied property might not hold for certain</span>
 109 |     | <span class='neutral'>    ///         vault implementations, and should be modified if exceptions are discovered.</span>
 110 | *r  | <span class='executed'>    function requireValidRedeemAmount(address owner, uint256 shares) internal returns (uint256) {</span>
 111 |     | <span class='neutral'>        // should this be a configured setting?</span>
 112 | *r  | <span class='executed'>        require(shares &gt; 0);</span>
 113 |     | <span class='neutral'></span>
 114 | *r  | <span class='executed'>        uint256 maxRedeem = vault.maxRedeem(owner);</span>
 115 | *r  | <span class='executed'>        require(maxRedeem &gt; 0);</span>
 116 | *r  | <span class='executed'>        uint256 ownerShares = vault.balanceOf(owner);</span>
 117 | *r  | <span class='executed'>        require(ownerShares &gt; 0);</span>
 118 |     | <span class='neutral'></span>
 119 | *r  | <span class='executed'>        shares = clampLte(shares, maxRedeem);</span>
 120 | *r  | <span class='executed'>        shares = clampLte(shares, ownerShares);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        // The following logic is intended to revert when an unreasonably large redemption is being made.</span>
 123 | *r  | <span class='executed'>        uint256 tokensWithdrawn = vault.convertToAssets(shares);</span>
 124 | *r  | <span class='executed'>        vault.previewRedeem(shares);</span>
 125 |     | <span class='neutral'>        // should this be a configured setting?</span>
 126 | *r  | <span class='executed'>        require(tokensWithdrawn &gt; 0);</span>
 127 | *r  | <span class='executed'>        emit LogUint256(&quot;Shares to use in redemption:&quot;, shares);</span>
 128 | *r  | <span class='executed'>        return shares;</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @notice Performs all the checks required to ensure a successful vault withdraw. This includes funding the owner account and clamping token amounts as needed.</span>
 132 |     | <span class='neutral'>    ///         It is assumed that successful calls to requireValidDepositAmount imply that vault.withdraw() will not revert. This implied property might not hold for certain</span>
 133 |     | <span class='neutral'>    ///         vault implementations, and should be modified if exceptions are discovered.</span>
 134 | *r  | <span class='executed'>    function requireValidWithdrawAmount(address owner, uint256 tokens) internal returns (uint256) {</span>
 135 | *r  | <span class='executed'>        uint256 maxWithdraw = vault.maxWithdraw(owner);</span>
 136 | *r  | <span class='executed'>        require(maxWithdraw &gt; 0);</span>
 137 |     | <span class='neutral'>        </span>
 138 | *r  | <span class='executed'>        uint256 ownerBalance = vault.balanceOf(owner);</span>
 139 | *r  | <span class='executed'>        require(ownerBalance &gt; 0);</span>
 140 |     | <span class='neutral'></span>
 141 | *r  | <span class='executed'>        uint256 sharesToRedeem = vault.previewWithdraw(tokens);</span>
 142 | *r  | <span class='executed'>        sharesToRedeem = clampLte(sharesToRedeem, vault.balanceOf(owner));</span>
 143 | *r  | <span class='executed'>        require(sharesToRedeem &lt;= ownerBalance);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        // not easy to clamp these without making this code a lot more complex.</span>
 146 | *r  | <span class='executed'>        uint256 clampedTokens = vault.previewRedeem(sharesToRedeem);</span>
 147 | *r  | <span class='executed'>        require(clampedTokens &lt;= maxWithdraw);</span>
 148 |     | <span class='neutral'>        // should this be a configured setting?</span>
 149 | *r  | <span class='executed'>        require(sharesToRedeem &gt; 0);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>        // we don&#39;t need to check for unreasonably large withdraws because previewWithdraw would have reverted.</span>
 152 | *r  | <span class='executed'>        emit LogUint256(&quot;Tokens to use in withdraw:&quot;, clampedTokens);</span>
 153 | *r  | <span class='executed'>        return clampedTokens;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'>}</span>
 156 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/util/IERC4626Internal.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>/// @notice Developers may optionally implement these interfaces on their Vault contract to increase coverage/enable rounding tests.</span>
  4 |     | <span class='neutral'>interface CryticIERC4626Internal {</span>
  5 |     | <span class='neutral'>    /// @notice Called by the fuzzer. The vault implementation should use TestERC20Token.mint() to credit itself with the amount of profit.</span>
  6 |     | <span class='neutral'>    function recognizeProfit(uint256 profit) external;</span>
  7 |     | <span class='neutral'>    </span>
  8 |     | <span class='neutral'>    /// @notice Called by the fuzzer. The vault implementation should use TestERC20Token.burn()/.transfer() to account for the amount of loss.</span>
  9 |     | <span class='neutral'>    function recognizeLoss(uint256 loss) external;</span>
 10 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/util/RedemptionProxy.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import {IERC4626} from &quot;../../util/IERC4626.sol&quot;;</span>
  4 | *r  | <span class='executed'></span>
  5 |     | <span class='neutral'>contract RedemptionProxy {</span>
  6 |     | <span class='neutral'>    IERC4626 vault;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>    constructor(IERC4626 _vault) {</span>
  9 |     | <span class='unexecuted'>        vault = _vault;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    function redeemOnBehalf(uint256 shares, address receiver, address owner) public returns (uint256 tokensWithdrawn) {</span>
 13 | *   | <span class='executed'>        tokensWithdrawn = vault.redeem(shares, receiver, owner );</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 | *r  | <span class='executed'>    function withdrawOnBehalf(uint256 tokens, address receiver, address owner) public returns (uint256 sharesRedeemed) {</span>
 17 | *r  | <span class='executed'>        sharesRedeemed = vault.withdraw(tokens, receiver, owner );</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/ERC4626/util/TestERC20Token.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 | *r  | <span class='executed'></span>
  3 |     | <span class='neutral'>contract TestERC20Token {</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>  event Transfer(address indexed from, address indexed to, uint256 amount);</span>
  6 |     | <span class='neutral'>  event Approval(address indexed owner, address indexed spender, uint256 amount);</span>
  7 |     | <span class='neutral'></span>
  8 | *r  | <span class='executed'>  string public name;</span>
  9 |     | <span class='unexecuted'>  string public symbol;</span>
 10 | *r  | <span class='executed'>  uint256 public decimals;</span>
 11 | *r  | <span class='executed'>  uint256 public totalSupply;</span>
 12 | *r  | <span class='executed'>  mapping(address =&gt; uint256) public balanceOf;</span>
 13 |     | <span class='unexecuted'>  mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>  constructor(</span>
 16 |     | <span class='neutral'>    string memory _name,</span>
 17 |     | <span class='neutral'>    string memory _symbol,</span>
 18 |     | <span class='neutral'>    uint256 _decimals</span>
 19 |     | <span class='neutral'>  ) {</span>
 20 |     | <span class='unexecuted'>    name = _name;</span>
 21 |     | <span class='unexecuted'>    symbol = _symbol;</span>
 22 |     | <span class='unexecuted'>    decimals = _decimals;</span>
 23 |     | <span class='neutral'>  }</span>
 24 |     | <span class='neutral'></span>
 25 | *r  | <span class='executed'>  function approve(address spender, uint256 amount) public returns (bool) {</span>
 26 | *r  | <span class='executed'>    allowance[msg.sender][spender] = amount;</span>
 27 |     | <span class='neutral'></span>
 28 | *r  | <span class='executed'>    emit Approval(msg.sender, spender, amount);</span>
 29 | *r  | <span class='executed'>    return true;</span>
 30 |     | <span class='neutral'>  }</span>
 31 |     | <span class='neutral'></span>
 32 | *r  | <span class='executed'>  function transfer(address to, uint256 amount) public returns (bool) {</span>
 33 | *r  | <span class='executed'>    balanceOf[msg.sender] -= amount;</span>
 34 | *r  | <span class='executed'>    balanceOf[to] += amount;</span>
 35 |     | <span class='neutral'></span>
 36 | *r  | <span class='executed'>    emit Transfer(msg.sender, to, amount);</span>
 37 |     | <span class='neutral'>    return true;</span>
 38 |     | <span class='neutral'>  }</span>
 39 |     | <span class='neutral'></span>
 40 | *r  | <span class='executed'>  function transferFrom(</span>
 41 |     | <span class='neutral'>    address from,</span>
 42 |     | <span class='neutral'>    address to,</span>
 43 |     | <span class='neutral'>    uint256 amount) </span>
 44 | *r  | <span class='executed'>    public returns (bool) {</span>
 45 |     | <span class='neutral'></span>
 46 | *r  | <span class='executed'>      uint256 spenderAllowance = allowance[from][msg.sender];</span>
 47 | *r  | <span class='executed'>      if (spenderAllowance != type(uint256).max) {</span>
 48 | *r  | <span class='executed'>        allowance[from][msg.sender] = spenderAllowance - amount;</span>
 49 |     | <span class='neutral'>      }</span>
 50 |     | <span class='neutral'></span>
 51 | *r  | <span class='executed'>      balanceOf[from] -= amount;</span>
 52 | *r  | <span class='executed'>      balanceOf[to] += amount;</span>
 53 |     | <span class='neutral'></span>
 54 | *r  | <span class='executed'>      emit Transfer(from, to, amount);</span>
 55 | *r  | <span class='executed'>      return true;</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 | *r  | <span class='executed'>  function mint(address to, uint256 amount) public {</span>
 59 | *r  | <span class='executed'>    totalSupply += amount;</span>
 60 | *r  | <span class='executed'>    balanceOf[to] += amount;</span>
 61 |     | <span class='neutral'></span>
 62 | *r  | <span class='executed'>    emit Transfer(address(0), to, amount);</span>
 63 |     | <span class='neutral'>  }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>  function burn(address from, uint256 amount) public {</span>
 66 |     | <span class='unexecuted'>    totalSupply -= amount;</span>
 67 |     | <span class='unexecuted'>    balanceOf[from] -= amount;</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='unexecuted'>    emit Transfer(from, address(0), amount);</span>
 70 |     | <span class='neutral'>  }</span>
 71 |     | <span class='neutral'></span>
 72 | *r  | <span class='executed'>  function forceApproval(address account, address spender, uint256 amount) public {</span>
 73 | *r  | <span class='executed'>    allowance[account][spender] = amount;</span>
 74 | *r  | <span class='executed'>    emit Approval(account, spender, amount);</span>
 75 |     | <span class='neutral'>  }</span>
 76 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/util/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'>interface IERC20 {</span>
  4 |     | <span class='neutral'>    /**</span>
  5 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
  6 |     | <span class='neutral'>     * another (`to`).</span>
  7 |     | <span class='neutral'>     *</span>
  8 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
  9 |     | <span class='neutral'>     */</span>
 10 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 14 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /**</span>
 29 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 30 |     | <span class='neutral'>     *</span>
 31 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 32 |     | <span class='neutral'>     *</span>
 33 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    /**</span>
 38 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 39 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 40 |     | <span class='neutral'>     * zero by default.</span>
 41 |     | <span class='neutral'>     *</span>
 42 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 48 |     | <span class='neutral'>     *</span>
 49 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 50 |     | <span class='neutral'>     *</span>
 51 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 52 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 53 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 54 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 55 |     | <span class='neutral'>     * desired value afterwards:</span>
 56 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    /**</span>
 63 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 64 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 65 |     | <span class='neutral'>     * allowance.</span>
 66 |     | <span class='neutral'>     *</span>
 67 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 68 |     | <span class='neutral'>     *</span>
 69 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 70 |     | <span class='neutral'>     */</span>
 71 |     | <span class='neutral'>    function transferFrom(</span>
 72 |     | <span class='neutral'>        address from,</span>
 73 |     | <span class='neutral'>        address to,</span>
 74 |     | <span class='neutral'>        uint256 amount</span>
 75 |     | <span class='neutral'>    ) external returns (bool);</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    function decimals() external returns (uint8);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/util/IERC4626.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC4626 is IERC20 {</span>
  7 |     | <span class='neutral'>    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event Withdraw(</span>
 10 |     | <span class='neutral'>        address indexed caller,</span>
 11 |     | <span class='neutral'>        address indexed receiver,</span>
 12 |     | <span class='neutral'>        address indexed owner,</span>
 13 |     | <span class='neutral'>        uint256 assets,</span>
 14 |     | <span class='neutral'>        uint256 shares</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function asset() external view returns (IERC20);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function deposit(uint256 assets, address receiver) external returns (uint256 shares);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function mint(uint256 shares, address receiver) external returns (uint256 assets);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function withdraw(</span>
 24 |     | <span class='neutral'>        uint256 assets,</span>
 25 |     | <span class='neutral'>        address receiver,</span>
 26 |     | <span class='neutral'>        address owner</span>
 27 |     | <span class='neutral'>    ) external returns (uint256 shares);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function redeem(</span>
 30 |     | <span class='neutral'>        uint256 shares,</span>
 31 |     | <span class='neutral'>        address receiver,</span>
 32 |     | <span class='neutral'>        address owner</span>
 33 |     | <span class='neutral'>    ) external returns (uint256 assets);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function totalAssets() external view returns (uint256);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function convertToShares(uint256 assets) external view returns (uint256);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function convertToAssets(uint256 shares) external view returns (uint256);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function previewDeposit(uint256 assets) external view returns (uint256);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function previewMint(uint256 shares) external view returns (uint256);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    function previewWithdraw(uint256 assets) external view returns (uint256);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function previewRedeem(uint256 shares) external view returns (uint256);</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    function maxDeposit(address) external view returns (uint256);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function maxMint(address) external view returns (uint256);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    function maxWithdraw(address owner) external view returns (uint256);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    function maxRedeem(address owner) external view returns (uint256);</span>
 56 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/properties/contracts/util/PropertiesHelper.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>abstract contract PropertiesAsserts {</span>
   4 |     | <span class='neutral'>    event LogUint256(string,uint256);</span>
   5 |     | <span class='neutral'>    event LogAddress(string, address);</span>
   6 |     | <span class='neutral'>    event LogString(string);</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    event AssertFail(string);</span>
   9 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  10 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  11 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  12 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  13 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  14 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  15 |     | <span class='neutral'></span>
  16 | r   | <span class='reverted'>    function assertWithMsg(bool b, string memory reason) internal {</span>
  17 | r   | <span class='reverted'>        if(!b){</span>
  18 | r   | <span class='reverted'>            emit AssertFail(reason);</span>
  19 | r   | <span class='reverted'>            assert(false);</span>
  20 |     | <span class='neutral'>        }</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  24 | *r  | <span class='executed'>    function assertEq(uint256 a, uint256 b, string memory reason) internal {</span>
  25 | *r  | <span class='executed'>        if(a != b){</span>
  26 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  27 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
  28 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;!=&quot;,bStr,&quot;, reason: &quot;, reason);</span>
  29 |     | <span class='unexecuted'>            emit AssertEqFail(string(assertMsg));</span>
  30 |     | <span class='unexecuted'>            assert(false);</span>
  31 |     | <span class='neutral'>        }</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice int256 version of assertEq</span>
  35 |     | <span class='neutral'>    function assertEq(int256 a, int256 b, string memory reason) internal {</span>
  36 |     | <span class='neutral'>        if(a != b){</span>
  37 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  38 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  39 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;!=&quot;,bStr,&quot;, reason: &quot;, reason);</span>
  40 |     | <span class='neutral'>            emit AssertEqFail(string(assertMsg));</span>
  41 |     | <span class='neutral'>            assert(false);</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
  46 | *r  | <span class='executed'>    function assertNeq(uint256 a, uint256 b, string memory reason) internal {</span>
  47 | *r  | <span class='executed'>        if(a == b){</span>
  48 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  49 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
  50 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;==&quot;,bStr,&quot;, reason: &quot;, reason);</span>
  51 |     | <span class='unexecuted'>            emit AssertNeqFail(string(assertMsg));</span>
  52 |     | <span class='neutral'>            assert(false);</span>
  53 |     | <span class='neutral'>        }</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @notice int256 version of assertNeq</span>
  57 |     | <span class='neutral'>    function assertNeq(int256 a, int256 b, string memory reason) internal {</span>
  58 |     | <span class='neutral'>        if(a == b){</span>
  59 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  60 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  61 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;==&quot;,bStr,&quot;, reason: &quot;, reason);</span>
  62 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  63 |     | <span class='neutral'>            assert(false);</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
  68 | *   | <span class='executed'>    function assertGte(uint256 a, uint256 b, string memory reason) internal {</span>
  69 | *   | <span class='executed'>        if(!(a &gt;= b)) {</span>
  70 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  71 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
  72 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&lt;&quot;,bStr,&quot; failed, reason: &quot;, reason);</span>
  73 |     | <span class='unexecuted'>            emit AssertGteFail(string(assertMsg));</span>
  74 |     | <span class='neutral'>            assert(false);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice int256 version of assertGte</span>
  79 |     | <span class='neutral'>    function assertGte(int256 a, int256 b, string memory reason) internal {</span>
  80 |     | <span class='neutral'>        if(!(a &gt;= b)) {</span>
  81 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  82 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  83 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&lt;&quot;,bStr,&quot; failed, reason: &quot;, reason);</span>
  84 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
  85 |     | <span class='neutral'>            assert(false);</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
  90 | *r  | <span class='executed'>    function assertGt(uint256 a, uint256 b, string memory reason) internal {</span>
  91 | *r  | <span class='executed'>        if(!(a &gt; b)) {</span>
  92 | r   | <span class='reverted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  93 | r   | <span class='reverted'>            string memory bStr = PropertiesLibString.toString(b);</span>
  94 | r   | <span class='reverted'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&lt;=&quot;, bStr,&quot; failed, reason: &quot;, reason);</span>
  95 | r   | <span class='reverted'>            emit AssertGtFail(string(assertMsg));</span>
  96 | r   | <span class='reverted'>            assert(false);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice int256 version of assertGt</span>
 101 |     | <span class='neutral'>    function assertGt(int256 a, int256 b, string memory reason) internal {</span>
 102 |     | <span class='neutral'>        if(!(a &gt; b)) {</span>
 103 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 104 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 105 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&lt;=&quot;, bStr,&quot; failed, reason: &quot;, reason);</span>
 106 |     | <span class='neutral'>            emit AssertGtFail(string(assertMsg));</span>
 107 |     | <span class='neutral'>            assert(false);</span>
 108 |     | <span class='neutral'>        }</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 112 | *r  | <span class='executed'>    function assertLte(uint256 a, uint256 b, string memory reason) internal {</span>
 113 | *r  | <span class='executed'>        if(!(a &lt;= b)) {</span>
 114 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 115 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 116 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&gt;&quot;, bStr,&quot; failed, reason: &quot;, reason);</span>
 117 |     | <span class='unexecuted'>            emit AssertLteFail(string(assertMsg));</span>
 118 |     | <span class='unexecuted'>            assert(false);</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @notice int256 version of assertLte</span>
 123 |     | <span class='neutral'>    function assertLte(int256 a, int256 b, string memory reason) internal {</span>
 124 |     | <span class='neutral'>        if(!(a &lt;= b)) {</span>
 125 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 126 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 127 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&gt;&quot;, bStr,&quot; failed, reason: &quot;, reason);</span>
 128 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 129 |     | <span class='neutral'>            assert(false);</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 134 |     | <span class='neutral'>    function assertLt(uint256 a, uint256 b, string memory reason) internal {</span>
 135 |     | <span class='neutral'>        if(!(a &lt; b)) {</span>
 136 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 137 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 138 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&gt;=&quot;,bStr,&quot; failed, reason: &quot;, reason);</span>
 139 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 140 |     | <span class='neutral'>            assert(false);</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @notice int256 version of assertLt</span>
 145 |     | <span class='neutral'>    function assertLt(int256 a, int256 b, string memory reason) internal {</span>
 146 |     | <span class='neutral'>        if(!(a &lt; b)) {</span>
 147 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 148 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 149 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(&quot;Invalid: &quot;, aStr,&quot;&gt;=&quot;,bStr,&quot; failed, reason: &quot;, reason);</span>
 150 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 151 |     | <span class='neutral'>            assert(false);</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
 156 |     | <span class='neutral'>    function clampBetween(uint256 value, uint256 low, uint256 high) internal returns (uint256) {</span>
 157 |     | <span class='neutral'>        if(value &lt; low || value &gt; high) {</span>
 158 |     | <span class='neutral'>            uint ans = low + (value % (high - low + 1));</span>
 159 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 160 |     | <span class='neutral'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 161 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, valueStr, &quot; to &quot;, ansStr);</span>
 162 |     | <span class='neutral'>            emit LogString(string(message));</span>
 163 |     | <span class='neutral'>            return ans;</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>        return value;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /// @notice int256 version of clampBetween</span>
 169 |     | <span class='neutral'>    function clampBetween(int256 value, int256 low, int256 high) internal returns (int256) {</span>
 170 |     | <span class='neutral'>        if(value &lt; low || value &gt; high) {</span>
 171 |     | <span class='neutral'>            int range = high - low + 1;</span>
 172 |     | <span class='neutral'>            int clamped = (value - low) % (range);</span>
 173 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 174 |     | <span class='neutral'>            int ans = low + clamped;</span>
 175 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 176 |     | <span class='neutral'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 177 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, valueStr, &quot; to &quot;, ansStr);</span>
 178 |     | <span class='neutral'>            emit LogString(string(message));</span>
 179 |     | <span class='neutral'>            return ans;</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'>        return value;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 185 |     | <span class='neutral'>    function clampLt(uint256 a, uint256 b) internal returns (uint256){</span>
 186 |     | <span class='neutral'>        if ( !(a &lt; b)) {</span>
 187 |     | <span class='neutral'>            assertNeq(b, 0, &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;);</span>
 188 |     | <span class='neutral'>            uint256 value = a % b;</span>
 189 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 190 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 191 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 192 |     | <span class='neutral'>            emit LogString(string(message));</span>
 193 |     | <span class='neutral'>            return value;</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='neutral'>        return a;</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 199 |     | <span class='neutral'>    function clampLt(int256 a, int256 b) internal returns (int256){</span>
 200 |     | <span class='neutral'>        if ( !(a &lt; b)) {</span>
 201 |     | <span class='neutral'>            int256 value = b-1;</span>
 202 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 203 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 204 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 205 |     | <span class='neutral'>            emit LogString(string(message));</span>
 206 |     | <span class='neutral'>            return value;</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>        return a;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 212 | *r  | <span class='executed'>    function clampLte(uint256 a, uint256 b) internal returns (uint256) {</span>
 213 | *r  | <span class='executed'>        if(!(a &lt;= b)) {</span>
 214 | *r  | <span class='executed'>            uint256 value = a % (b+1);</span>
 215 | *r  | <span class='executed'>            string memory aStr = PropertiesLibString.toString(a);</span>
 216 | *r  | <span class='executed'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 217 | *r  | <span class='executed'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 218 | *r  | <span class='executed'>            emit LogString(string(message));</span>
 219 | *r  | <span class='executed'>            return value;</span>
 220 |     | <span class='neutral'>        }</span>
 221 | *r  | <span class='executed'>        return a;</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 225 |     | <span class='neutral'>    function clampLte(int256 a, int256 b) internal returns (int256) {</span>
 226 |     | <span class='neutral'>        if(!(a &lt;= b)) {</span>
 227 |     | <span class='neutral'>            int256 value = b;</span>
 228 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 229 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 230 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 231 |     | <span class='neutral'>            emit LogString(string(message));</span>
 232 |     | <span class='neutral'>            return value;</span>
 233 |     | <span class='neutral'>        }</span>
 234 |     | <span class='neutral'>        return a;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 238 | *r  | <span class='executed'>    function clampGt(uint256 a, uint256 b) internal returns (uint256) {</span>
 239 | *r  | <span class='executed'>        if(!(a &gt; b)){</span>
 240 | *r  | <span class='executed'>            assertNeq(b, type(uint256).max, &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;);</span>
 241 | *r  | <span class='executed'>            uint256 value = b+1;</span>
 242 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 243 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 244 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 245 |     | <span class='neutral'>            emit LogString(string(message));</span>
 246 |     | <span class='neutral'>            return value;</span>
 247 |     | <span class='neutral'>        } else {</span>
 248 | *r  | <span class='executed'>            return a;</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 253 |     | <span class='neutral'>    function clampGt(int256 a, int256 b) internal returns (int256) {</span>
 254 |     | <span class='neutral'>        if(!(a &gt; b)){</span>
 255 |     | <span class='neutral'>            int256 value = b+1;</span>
 256 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 257 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 258 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 259 |     | <span class='neutral'>            emit LogString(string(message));</span>
 260 |     | <span class='neutral'>            return value;</span>
 261 |     | <span class='neutral'>        } else {</span>
 262 |     | <span class='neutral'>            return a;</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 267 |     | <span class='neutral'>    function clampGte(uint256 a, uint256 b) internal returns (uint256) {</span>
 268 |     | <span class='neutral'>        if(!(a &gt; b)){</span>
 269 |     | <span class='neutral'>            uint256 value = b;</span>
 270 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 271 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 272 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 273 |     | <span class='neutral'>            emit LogString(string(message));</span>
 274 |     | <span class='neutral'>            return value;</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='neutral'>        return a;</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 280 |     | <span class='neutral'>    function clampGte(int256 a, int256 b) internal returns (int256) {</span>
 281 |     | <span class='neutral'>        if(!(a &gt; b)){</span>
 282 |     | <span class='neutral'>            int256 value = b;</span>
 283 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 284 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 285 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(&quot;Clamping value &quot;, aStr, &quot; to &quot;, valueStr);</span>
 286 |     | <span class='neutral'>            emit LogString(string(message));</span>
 287 |     | <span class='neutral'>            return value;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'>        return a;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'>}</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
 294 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
 295 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
 296 |     | <span class='unexecuted'>/// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString</span>
 297 |     | <span class='neutral'>library PropertiesLibString {</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory str) {</span>
 300 |     | <span class='neutral'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
 301 |     | <span class='neutral'>        str = toString(absValue);</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>        if(value &lt; 0) {</span>
 304 |     | <span class='neutral'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 | *r  | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
 309 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 310 |     | <span class='neutral'>        assembly {</span>
 311 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
 312 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
 313 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
 314 | *r  | <span class='executed'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
 317 | *r  | <span class='executed'>            mstore(0x40, newFreeMemoryPointer)</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
 320 | *r  | <span class='executed'>            str := sub(newFreeMemoryPointer, 32)</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
 323 | *r  | <span class='executed'>            mstore(str, 0)</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
 326 | *r  | <span class='executed'>            let end := str</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
 329 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
 330 |     | <span class='neutral'>            // prettier-ignore</span>
 331 | *r  | <span class='executed'>            for { let temp := value } 1 {} {</span>
 332 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
 333 | *r  | <span class='executed'>                str := sub(str, 1)</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>                // Write the character to the pointer.</span>
 336 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
 337 | *r  | <span class='executed'>                mstore8(str, add(48, mod(temp, 10)))</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
 340 | *r  | <span class='executed'>                temp := div(temp, 10)</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>                 // prettier-ignore</span>
 343 | *r  | <span class='executed'>                if iszero(temp) { break }</span>
 344 |     | <span class='neutral'>            }</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
 347 | *r  | <span class='executed'>            let length := sub(end, str)</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
 350 | *r  | <span class='executed'>            str := sub(str, 32)</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
 353 | *r  | <span class='executed'>            mstore(str, length)</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function toString(address value) internal pure returns (string memory str){</span>
 358 |     | <span class='neutral'>        bytes memory s = new bytes(40);</span>
 359 |     | <span class='neutral'>        for (uint i = 0; i &lt; 20; i++) {</span>
 360 |     | <span class='neutral'>            bytes1 b = bytes1(uint8(uint(uint160(value)) / (2**(8*(19 - i)))));</span>
 361 |     | <span class='neutral'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
 362 |     | <span class='neutral'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
 363 |     | <span class='neutral'>            s[2*i] = char(hi);</span>
 364 |     | <span class='neutral'>            s[2*i+1] = char(lo);            </span>
 365 |     | <span class='neutral'>        }</span>
 366 |     | <span class='neutral'>        return string(s);</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
 370 |     | <span class='neutral'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
 371 |     | <span class='neutral'>        else return bytes1(uint8(b) + 0x57);</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'>}</span>
 374 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/mixins/ERC4626.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC20} from &quot;../tokens/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import {SafeTransferLib} from &quot;../utils/SafeTransferLib.sol&quot;;</span>
   6 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;../utils/FixedPointMathLib.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Minimal ERC4626 tokenized Vault implementation.</span>
   9 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)</span>
  10 |     | <span class='neutral'>abstract contract ERC4626 is ERC20 {</span>
  11 |     | <span class='neutral'>    using SafeTransferLib for ERC20;</span>
  12 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  15 |     | <span class='neutral'>                                 EVENTS</span>
  16 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event Withdraw(</span>
  21 |     | <span class='neutral'>        address indexed caller,</span>
  22 |     | <span class='neutral'>        address indexed receiver,</span>
  23 |     | <span class='neutral'>        address indexed owner,</span>
  24 |     | <span class='neutral'>        uint256 assets,</span>
  25 |     | <span class='neutral'>        uint256 shares</span>
  26 |     | <span class='neutral'>    );</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  29 |     | <span class='neutral'>                               IMMUTABLES</span>
  30 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  31 |     | <span class='neutral'></span>
  32 | *   | <span class='executed'>    ERC20 public immutable asset;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    constructor(</span>
  35 |     | <span class='neutral'>        ERC20 _asset,</span>
  36 |     | <span class='neutral'>        string memory _name,</span>
  37 |     | <span class='neutral'>        string memory _symbol</span>
  38 |     | <span class='unexecuted'>    ) ERC20(_name, _symbol, _asset.decimals()) {</span>
  39 |     | <span class='unexecuted'>        asset = _asset;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  43 |     | <span class='neutral'>                        DEPOSIT/WITHDRAWAL LOGIC</span>
  44 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  45 |     | <span class='neutral'></span>
  46 | *r  | <span class='executed'>    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {</span>
  47 |     | <span class='neutral'>        // Check for rounding error since we round down in previewDeposit.</span>
  48 | *r  | <span class='executed'>        require((shares = previewDeposit(assets)) != 0, &quot;ZERO_SHARES&quot;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // Need to transfer before minting or ERC777s could reenter.</span>
  51 | *r  | <span class='executed'>        asset.safeTransferFrom(msg.sender, address(this), assets);</span>
  52 |     | <span class='neutral'></span>
  53 | *r  | <span class='executed'>        _mint(receiver, shares);</span>
  54 |     | <span class='neutral'></span>
  55 | *r  | <span class='executed'>        emit Deposit(msg.sender, receiver, assets, shares);</span>
  56 |     | <span class='neutral'></span>
  57 | *r  | <span class='executed'>        afterDeposit(assets, shares);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 | *r  | <span class='executed'>    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {</span>
  61 | *r  | <span class='executed'>        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // Need to transfer before minting or ERC777s could reenter.</span>
  64 | *r  | <span class='executed'>        asset.safeTransferFrom(msg.sender, address(this), assets);</span>
  65 |     | <span class='neutral'></span>
  66 | *   | <span class='executed'>        _mint(receiver, shares);</span>
  67 |     | <span class='neutral'></span>
  68 | *   | <span class='executed'>        emit Deposit(msg.sender, receiver, assets, shares);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        afterDeposit(assets, shares);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    function withdraw(</span>
  74 |     | <span class='neutral'>        uint256 assets,</span>
  75 |     | <span class='neutral'>        address receiver,</span>
  76 |     | <span class='neutral'>        address owner</span>
  77 |     | <span class='unexecuted'>    ) public virtual returns (uint256 shares) {</span>
  78 |     | <span class='unexecuted'>        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        if (msg.sender != owner) {</span>
  81 |     | <span class='unexecuted'>            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        beforeWithdraw(assets, shares);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        _burn(owner, shares);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        emit Withdraw(msg.sender, receiver, owner, assets, shares);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        asset.safeTransfer(receiver, assets);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function redeem(</span>
  96 |     | <span class='neutral'>        uint256 shares,</span>
  97 |     | <span class='neutral'>        address receiver,</span>
  98 |     | <span class='neutral'>        address owner</span>
  99 |     | <span class='unexecuted'>    ) public virtual returns (uint256 assets) {</span>
 100 |     | <span class='unexecuted'>        if (msg.sender != owner) {</span>
 101 |     | <span class='unexecuted'>            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        // Check for rounding error since we round down in previewRedeem.</span>
 107 |     | <span class='unexecuted'>        require((assets = previewRedeem(shares)) != 0, &quot;ZERO_ASSETS&quot;);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        beforeWithdraw(assets, shares);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        _burn(owner, shares);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        emit Withdraw(msg.sender, receiver, owner, assets, shares);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        asset.safeTransfer(receiver, assets);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 119 |     | <span class='neutral'>                            ACCOUNTING LOGIC</span>
 120 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function totalAssets() public view virtual returns (uint256);</span>
 123 |     | <span class='neutral'></span>
 124 | *r  | <span class='executed'>    function convertToShares(uint256 assets) public view virtual returns (uint256) {</span>
 125 | *r  | <span class='executed'>        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.</span>
 126 |     | <span class='neutral'></span>
 127 | *r  | <span class='executed'>        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 | *r  | <span class='executed'>    function convertToAssets(uint256 shares) public view virtual returns (uint256) {</span>
 131 | *r  | <span class='executed'>        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.</span>
 132 |     | <span class='neutral'></span>
 133 | *r  | <span class='executed'>        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 | *r  | <span class='executed'>    function previewDeposit(uint256 assets) public view virtual returns (uint256) {</span>
 137 | *r  | <span class='executed'>        return convertToShares(assets);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 | *r  | <span class='executed'>    function previewMint(uint256 shares) public view virtual returns (uint256) {</span>
 141 | *r  | <span class='executed'>        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.</span>
 142 |     | <span class='neutral'></span>
 143 | *r  | <span class='executed'>        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 | *r  | <span class='executed'>    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {</span>
 147 | *r  | <span class='executed'>        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.</span>
 148 |     | <span class='neutral'></span>
 149 | *r  | <span class='executed'>        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 | *r  | <span class='executed'>    function previewRedeem(uint256 shares) public view virtual returns (uint256) {</span>
 153 | *r  | <span class='executed'>        return convertToAssets(shares);</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 157 |     | <span class='neutral'>                     DEPOSIT/WITHDRAWAL LIMIT LOGIC</span>
 158 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 159 |     | <span class='neutral'></span>
 160 | *r  | <span class='executed'>    function maxDeposit(address) public view virtual returns (uint256) {</span>
 161 | *r  | <span class='executed'>        return type(uint256).max;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function maxMint(address) public view virtual returns (uint256) {</span>
 165 |     | <span class='neutral'>        return type(uint256).max;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 | *r  | <span class='executed'>    function maxWithdraw(address owner) public view virtual returns (uint256) {</span>
 169 | *r  | <span class='executed'>        return convertToAssets(balanceOf[owner]);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 | *r  | <span class='executed'>    function maxRedeem(address owner) public view virtual returns (uint256) {</span>
 173 | *r  | <span class='executed'>        return balanceOf[owner];</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 177 |     | <span class='neutral'>                          INTERNAL HOOKS LOGIC</span>
 178 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}</span>
 183 |     | <span class='neutral'>}</span>
 184 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/test/utils/DSTestPlus.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DSTest} from &quot;ds-test/test.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Hevm} from &quot;./Hevm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Extended testing framework for DappTools projects.</span>
   9 |     | <span class='unexecuted'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/test/utils/DSTestPlus.sol)</span>
  10 |     | <span class='neutral'>contract DSTestPlus is DSTest {</span>
  11 |     | <span class='neutral'>    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string private checkpointLabel;</span>
  16 |     | <span class='unexecuted'>    uint256 private checkpointGasLeft = 1; // Start the slot warm.</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    modifier brutalizeMemory(bytes memory brutalizeWith) {</span>
  19 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  20 |     | <span class='neutral'>        assembly {</span>
  21 |     | <span class='neutral'>            // Fill the 64 bytes of scratch space with the data.</span>
  22 |     | <span class='neutral'>            pop(</span>
  23 |     | <span class='neutral'>                staticcall(</span>
  24 |     | <span class='neutral'>                    gas(), // Pass along all the gas in the call.</span>
  25 |     | <span class='neutral'>                    0x04, // Call the identity precompile address.</span>
  26 |     | <span class='neutral'>                    brutalizeWith, // Offset is the bytes&#39; pointer.</span>
  27 |     | <span class='neutral'>                    64, // Copy enough to only fill the scratch space.</span>
  28 |     | <span class='neutral'>                    0, // Store the return value in the scratch space.</span>
  29 |     | <span class='neutral'>                    64 // Scratch space is only 64 bytes in size, we don&#39;t want to write further.</span>
  30 |     | <span class='neutral'>                )</span>
  31 |     | <span class='neutral'>            )</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>            let size := add(mload(brutalizeWith), 32) // Add 32 to include the 32 byte length slot.</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>            // Fill the free memory pointer&#39;s destination with the data.</span>
  36 |     | <span class='neutral'>            pop(</span>
  37 |     | <span class='neutral'>                staticcall(</span>
  38 |     | <span class='neutral'>                    gas(), // Pass along all the gas in the call.</span>
  39 |     | <span class='neutral'>                    0x04, // Call the identity precompile address.</span>
  40 |     | <span class='neutral'>                    brutalizeWith, // Offset is the bytes&#39; pointer.</span>
  41 |     | <span class='neutral'>                    size, // We want to pass the length of the bytes.</span>
  42 |     | <span class='neutral'>                    mload(0x40), // Store the return value at the free memory pointer.</span>
  43 |     | <span class='neutral'>                    size // Since the precompile just returns its input, we reuse size.</span>
  44 |     | <span class='neutral'>                )</span>
  45 |     | <span class='neutral'>            )</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        _;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function startMeasuringGas(string memory label) internal virtual {</span>
  52 |     | <span class='neutral'>        checkpointLabel = label;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        checkpointGasLeft = gasleft();</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    function stopMeasuringGas() internal virtual {</span>
  58 |     | <span class='neutral'>        uint256 checkpointGasLeft2 = gasleft();</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        // Subtract 100 to account for the warm SLOAD in startMeasuringGas.</span>
  61 |     | <span class='neutral'>        uint256 gasDelta = checkpointGasLeft - checkpointGasLeft2 - 100;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        emit log_named_uint(string(abi.encodePacked(checkpointLabel, &quot; Gas&quot;)), gasDelta);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function fail(string memory err) internal virtual {</span>
  67 |     | <span class='neutral'>        emit log_named_string(&quot;Error&quot;, err);</span>
  68 |     | <span class='neutral'>        fail();</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function assertFalse(bool data) internal virtual {</span>
  72 |     | <span class='neutral'>        assertTrue(!data);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function assertUint128Eq(uint128 a, uint128 b) internal virtual {</span>
  76 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertUint64Eq(uint64 a, uint64 b) internal virtual {</span>
  80 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function assertUint96Eq(uint96 a, uint96 b) internal virtual {</span>
  84 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function assertUint32Eq(uint32 a, uint32 b) internal virtual {</span>
  88 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function assertBoolEq(bool a, bool b) internal virtual {</span>
  92 |     | <span class='neutral'>        b ? assertTrue(a) : assertFalse(a);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function assertApproxEq(</span>
  96 |     | <span class='neutral'>        uint256 a,</span>
  97 |     | <span class='neutral'>        uint256 b,</span>
  98 |     | <span class='neutral'>        uint256 maxDelta</span>
  99 |     | <span class='neutral'>    ) internal virtual {</span>
 100 |     | <span class='neutral'>        uint256 delta = a &gt; b ? a - b : b - a;</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 103 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 104 |     | <span class='neutral'>            emit log_named_uint(&quot;  Expected&quot;, b);</span>
 105 |     | <span class='neutral'>            emit log_named_uint(&quot;    Actual&quot;, a);</span>
 106 |     | <span class='neutral'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 107 |     | <span class='neutral'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 108 |     | <span class='neutral'>            fail();</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function assertRelApproxEq(</span>
 113 |     | <span class='neutral'>        uint256 a,</span>
 114 |     | <span class='neutral'>        uint256 b,</span>
 115 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 116 |     | <span class='neutral'>    ) internal virtual {</span>
 117 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        uint256 percentDelta = ((a &gt; b ? a - b : b - a) * 1e18) / b;</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 122 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 123 |     | <span class='neutral'>            emit log_named_uint(&quot;    Expected&quot;, b);</span>
 124 |     | <span class='neutral'>            emit log_named_uint(&quot;      Actual&quot;, a);</span>
 125 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 126 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 127 |     | <span class='neutral'>            fail();</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {</span>
 132 |     | <span class='neutral'>        if (keccak256(a) != keccak256(b)) {</span>
 133 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes]&quot;);</span>
 134 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Expected&quot;, b);</span>
 135 |     | <span class='neutral'>            emit log_named_bytes(&quot;    Actual&quot;, a);</span>
 136 |     | <span class='neutral'>            fail();</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function assertUintArrayEq(uint256[] memory a, uint256[] memory b) internal virtual {</span>
 141 |     | <span class='neutral'>        require(a.length == b.length, &quot;LENGTH_MISMATCH&quot;);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; a.length; i++) {</span>
 144 |     | <span class='neutral'>            assertEq(a[i], b[i]);</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function bound(</span>
 149 |     | <span class='neutral'>        uint256 x,</span>
 150 |     | <span class='neutral'>        uint256 min,</span>
 151 |     | <span class='neutral'>        uint256 max</span>
 152 |     | <span class='neutral'>    ) internal virtual returns (uint256 result) {</span>
 153 |     | <span class='neutral'>        require(max &gt;= min, &quot;MAX_LESS_THAN_MIN&quot;);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        uint256 size = max - min;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        if (size == 0) result = min;</span>
 158 |     | <span class='neutral'>        else if (size == type(uint256).max) result = x;</span>
 159 |     | <span class='neutral'>        else {</span>
 160 |     | <span class='neutral'>            ++size; // Make max inclusive.</span>
 161 |     | <span class='neutral'>            uint256 mod = x % size;</span>
 162 |     | <span class='neutral'>            result = min + mod;</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        emit log_named_uint(&quot;Bound Result&quot;, result);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function min3(</span>
 169 |     | <span class='neutral'>        uint256 a,</span>
 170 |     | <span class='neutral'>        uint256 b,</span>
 171 |     | <span class='neutral'>        uint256 c</span>
 172 |     | <span class='neutral'>    ) internal pure returns (uint256) {</span>
 173 |     | <span class='neutral'>        return a &gt; b ? (b &gt; c ? c : b) : (a &gt; c ? c : a);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function min2(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 177 |     | <span class='neutral'>        return a &gt; b ? b : a;</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/test/utils/Hevm.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface Hevm {</span>
   5 |     | <span class='neutral'>    /// @notice Sets the block timestamp.</span>
   6 |     | <span class='neutral'>    function warp(uint256) external;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    /// @notice Sets the block height.</span>
   9 |     | <span class='neutral'>    function roll(uint256) external;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    /// @notice Sets the block base fee.</span>
  12 |     | <span class='neutral'>    function fee(uint256) external;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Loads a storage slot from an address.</span>
  15 |     | <span class='neutral'>    function load(address, bytes32) external returns (bytes32);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Stores a value to an address&#39; storage slot.</span>
  18 |     | <span class='neutral'>    function store(</span>
  19 |     | <span class='neutral'>        address,</span>
  20 |     | <span class='neutral'>        bytes32,</span>
  21 |     | <span class='neutral'>        bytes32</span>
  22 |     | <span class='neutral'>    ) external;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /// @notice Signs a digest with a private key, returns v r s.</span>
  25 |     | <span class='neutral'>    function sign(uint256, bytes32)</span>
  26 |     | <span class='neutral'>        external</span>
  27 |     | <span class='neutral'>        returns (</span>
  28 |     | <span class='neutral'>            uint8,</span>
  29 |     | <span class='neutral'>            bytes32,</span>
  30 |     | <span class='neutral'>            bytes32</span>
  31 |     | <span class='neutral'>        );</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @notice Gets address for a given private key.</span>
  34 |     | <span class='neutral'>    function addr(uint256) external returns (address);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @notice Performs a foreign function call via a terminal call.</span>
  37 |     | <span class='neutral'>    function ffi(string[] calldata) external returns (bytes memory);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @notice Sets the next call&#39;s msg.sender to be the input address.</span>
  40 |     | <span class='neutral'>    function prank(address) external;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice Sets all subsequent calls&#39; msg.sender to be the input address until stopPrank is called.</span>
  43 |     | <span class='neutral'>    function startPrank(address) external;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice Sets the next call&#39;s msg.sender to be the input address and the tx.origin to be the second input.</span>
  46 |     | <span class='neutral'>    function prank(address, address) external;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /// @notice Sets all subsequent calls&#39; msg.sender to be the input address and</span>
  49 |     | <span class='neutral'>    /// sets tx.origin to be the second address inputted until stopPrank is called.</span>
  50 |     | <span class='neutral'>    function startPrank(address, address) external;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @notice Resets msg.sender to its original value before a prank.</span>
  53 |     | <span class='neutral'>    function stopPrank() external;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice Sets an address&#39; balance.</span>
  56 |     | <span class='neutral'>    function deal(address, uint256) external;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice Sets an address&#39; code.</span>
  59 |     | <span class='neutral'>    function etch(address, bytes calldata) external;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /// @notice Expects an error from the next call.</span>
  62 |     | <span class='neutral'>    function expectRevert(bytes calldata) external;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice Expects a revert from the next call.</span>
  65 |     | <span class='neutral'>    function expectRevert(bytes4) external;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @notice Record all storage reads and writes.</span>
  68 |     | <span class='neutral'>    function record() external;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice Gets all accessed reads and write slots from a recording session, for a given address.</span>
  71 |     | <span class='neutral'>    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /// @notice Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).</span>
  74 |     | <span class='neutral'>    /// @notice Call this function, then emit an event, then call a function. Internally after the call, we check</span>
  75 |     | <span class='neutral'>    /// if logs were emitted in the expected order with the expected topics and data as specified by the booleans.</span>
  76 |     | <span class='neutral'>    function expectEmit(</span>
  77 |     | <span class='neutral'>        bool,</span>
  78 |     | <span class='neutral'>        bool,</span>
  79 |     | <span class='neutral'>        bool,</span>
  80 |     | <span class='neutral'>        bool</span>
  81 |     | <span class='neutral'>    ) external;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Mocks the behavior of a contract call, setting the input and output for a function.</span>
  84 |     | <span class='neutral'>    /// @notice Calldata can either be strict or a partial match, e.g. if only passed</span>
  85 |     | <span class='neutral'>    /// a selector to the expected calldata, then the entire function will be mocked.</span>
  86 |     | <span class='neutral'>    function mockCall(</span>
  87 |     | <span class='neutral'>        address,</span>
  88 |     | <span class='neutral'>        bytes calldata,</span>
  89 |     | <span class='neutral'>        bytes calldata</span>
  90 |     | <span class='neutral'>    ) external;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @notice Clears all mocked calls.</span>
  93 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @notice Expect a call to an address with the specified calldata.</span>
  96 |     | <span class='neutral'>    /// @notice Calldata can either be strict or a partial match.</span>
  97 |     | <span class='neutral'>    function expectCall(address, bytes calldata) external;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Fetches the contract bytecode from its artifact file.</span>
 100 |     | <span class='neutral'>    function getCode(string calldata) external returns (bytes memory);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /// @notice Label an address in test traces.</span>
 103 |     | <span class='neutral'>    function label(address addr, string calldata label) external;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /// @notice When fuzzing, generate new inputs if the input conditional is not met.</span>
 106 |     | <span class='neutral'>    function assume(bool) external;</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/test/utils/mocks/MockERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;../../../tokens/ERC20.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract MockERC20 is ERC20 {</span>
  7 |     | <span class='unexecuted'>    constructor(</span>
  8 |     | <span class='neutral'>        string memory _name,</span>
  9 |     | <span class='neutral'>        string memory _symbol,</span>
 10 |     | <span class='neutral'>        uint8 _decimals</span>
 11 |     | <span class='unexecuted'>    ) ERC20(_name, _symbol, _decimals) {}</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function mint(address to, uint256 value) public virtual {</span>
 14 |     | <span class='unexecuted'>        _mint(to, value);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function burn(address from, uint256 value) public virtual {</span>
 18 |     | <span class='unexecuted'>        _burn(from, value);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/test/utils/mocks/MockERC4626.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;../../../tokens/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ERC4626} from &quot;../../../mixins/ERC4626.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract MockERC4626 is ERC4626 {</span>
  8 |     | <span class='unexecuted'>    uint256 public beforeWithdrawHookCalledCounter = 0;</span>
  9 |     | <span class='unexecuted'>    uint256 public afterDepositHookCalledCounter = 0;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(</span>
 12 |     | <span class='neutral'>        ERC20 _underlying,</span>
 13 |     | <span class='neutral'>        string memory _name,</span>
 14 |     | <span class='neutral'>        string memory _symbol</span>
 15 |     | <span class='unexecuted'>    ) ERC4626(_underlying, _name, _symbol) {}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function totalAssets() public view override returns (uint256) {</span>
 18 |     | <span class='unexecuted'>        return asset.balanceOf(address(this));</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function beforeWithdraw(uint256, uint256) internal override {</span>
 22 |     | <span class='unexecuted'>        beforeWithdrawHookCalledCounter++;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function afterDeposit(uint256, uint256) internal override {</span>
 26 |     | <span class='unexecuted'>        afterDepositHookCalledCounter++;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/tokens/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)</span>
   7 |     | <span class='neutral'>/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.</span>
   8 |     | <span class='neutral'>abstract contract ERC20 {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                                 EVENTS</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 amount);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 amount);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  18 |     | <span class='neutral'>                            METADATA STORAGE</span>
  19 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    string public name;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    string public symbol;</span>
  24 |     | <span class='neutral'></span>
  25 | *r  | <span class='executed'>    uint8 public immutable decimals;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                              ERC20 STORAGE</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 | *r  | <span class='executed'>    uint256 public totalSupply;</span>
  32 |     | <span class='neutral'></span>
  33 | *r  | <span class='executed'>    mapping(address =&gt; uint256) public balanceOf;</span>
  34 |     | <span class='neutral'></span>
  35 | *   | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  38 |     | <span class='neutral'>                            EIP-2612 STORAGE</span>
  39 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    uint256 internal immutable INITIAL_CHAIN_ID;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  48 |     | <span class='neutral'>                               CONSTRUCTOR</span>
  49 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    constructor(</span>
  52 |     | <span class='neutral'>        string memory _name,</span>
  53 |     | <span class='neutral'>        string memory _symbol,</span>
  54 |     | <span class='neutral'>        uint8 _decimals</span>
  55 |     | <span class='neutral'>    ) {</span>
  56 |     | <span class='unexecuted'>        name = _name;</span>
  57 |     | <span class='unexecuted'>        symbol = _symbol;</span>
  58 |     | <span class='unexecuted'>        decimals = _decimals;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        INITIAL_CHAIN_ID = block.chainid;</span>
  61 |     | <span class='unexecuted'>        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  65 |     | <span class='neutral'>                               ERC20 LOGIC</span>
  66 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  67 |     | <span class='neutral'></span>
  68 | *r  | <span class='executed'>    function approve(address spender, uint256 amount) public virtual returns (bool) {</span>
  69 | *r  | <span class='executed'>        allowance[msg.sender][spender] = amount;</span>
  70 |     | <span class='neutral'></span>
  71 | *r  | <span class='executed'>        emit Approval(msg.sender, spender, amount);</span>
  72 |     | <span class='neutral'></span>
  73 | *r  | <span class='executed'>        return true;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual returns (bool) {</span>
  77 |     | <span class='unexecuted'>        balanceOf[msg.sender] -= amount;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
  80 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
  81 |     | <span class='neutral'>        unchecked {</span>
  82 |     | <span class='unexecuted'>            balanceOf[to] += amount;</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        return true;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function transferFrom(</span>
  91 |     | <span class='neutral'>        address from,</span>
  92 |     | <span class='neutral'>        address to,</span>
  93 |     | <span class='neutral'>        uint256 amount</span>
  94 |     | <span class='unexecuted'>    ) public virtual returns (bool) {</span>
  95 |     | <span class='unexecuted'>        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
 102 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
 103 |     | <span class='neutral'>        unchecked {</span>
 104 |     | <span class='unexecuted'>            balanceOf[to] += amount;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        return true;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 113 |     | <span class='neutral'>                             EIP-2612 LOGIC</span>
 114 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>    function permit(</span>
 117 |     | <span class='neutral'>        address owner,</span>
 118 |     | <span class='neutral'>        address spender,</span>
 119 |     | <span class='neutral'>        uint256 value,</span>
 120 |     | <span class='neutral'>        uint256 deadline,</span>
 121 |     | <span class='neutral'>        uint8 v,</span>
 122 |     | <span class='neutral'>        bytes32 r,</span>
 123 |     | <span class='neutral'>        bytes32 s</span>
 124 |     | <span class='neutral'>    ) public virtual {</span>
 125 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Unchecked because the only math done is incrementing</span>
 128 |     | <span class='neutral'>        // the owner&#39;s nonce which cannot realistically overflow.</span>
 129 |     | <span class='neutral'>        unchecked {</span>
 130 |     | <span class='unexecuted'>            address recoveredAddress = ecrecover(</span>
 131 |     | <span class='unexecuted'>                keccak256(</span>
 132 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
 133 |     | <span class='neutral'>                        &quot;\x19\x01&quot;,</span>
 134 |     | <span class='unexecuted'>                        DOMAIN_SEPARATOR(),</span>
 135 |     | <span class='unexecuted'>                        keccak256(</span>
 136 |     | <span class='unexecuted'>                            abi.encode(</span>
 137 |     | <span class='unexecuted'>                                keccak256(</span>
 138 |     | <span class='neutral'>                                    &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
 139 |     | <span class='neutral'>                                ),</span>
 140 |     | <span class='neutral'>                                owner,</span>
 141 |     | <span class='neutral'>                                spender,</span>
 142 |     | <span class='neutral'>                                value,</span>
 143 |     | <span class='unexecuted'>                                nonces[owner]++,</span>
 144 |     | <span class='neutral'>                                deadline</span>
 145 |     | <span class='neutral'>                            )</span>
 146 |     | <span class='neutral'>                        )</span>
 147 |     | <span class='neutral'>                    )</span>
 148 |     | <span class='neutral'>                ),</span>
 149 |     | <span class='neutral'>                v,</span>
 150 |     | <span class='neutral'>                r,</span>
 151 |     | <span class='neutral'>                s</span>
 152 |     | <span class='neutral'>            );</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>            require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;INVALID_SIGNER&quot;);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>            allowance[recoveredAddress][spender] = value;</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {</span>
 163 |     | <span class='unexecuted'>        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>    function computeDomainSeparator() internal view virtual returns (bytes32) {</span>
 167 |     | <span class='unexecuted'>        return</span>
 168 |     | <span class='unexecuted'>            keccak256(</span>
 169 |     | <span class='unexecuted'>                abi.encode(</span>
 170 |     | <span class='unexecuted'>                    keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 171 |     | <span class='unexecuted'>                    keccak256(bytes(name)),</span>
 172 |     | <span class='unexecuted'>                    keccak256(&quot;1&quot;),</span>
 173 |     | <span class='unexecuted'>                    block.chainid,</span>
 174 |     | <span class='unexecuted'>                    address(this)</span>
 175 |     | <span class='neutral'>                )</span>
 176 |     | <span class='neutral'>            );</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 180 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 181 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 182 |     | <span class='neutral'></span>
 183 | *r  | <span class='executed'>    function _mint(address to, uint256 amount) internal virtual {</span>
 184 | *r  | <span class='executed'>        totalSupply += amount;</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        // Cannot overflow because the sum of all user</span>
 187 |     | <span class='neutral'>        // balances can&#39;t exceed the max uint256 value.</span>
 188 |     | <span class='neutral'>        unchecked {</span>
 189 | *r  | <span class='executed'>            balanceOf[to] += amount;</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'></span>
 192 | *r  | <span class='executed'>        emit Transfer(address(0), to, amount);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 | *r  | <span class='executed'>    function _burn(address from, uint256 amount) internal virtual {</span>
 196 | *r  | <span class='executed'>        balanceOf[from] -= amount;</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        // Cannot underflow because a user&#39;s balance</span>
 199 |     | <span class='neutral'>        // will never be larger than the total supply.</span>
 200 |     | <span class='neutral'>        unchecked {</span>
 201 | *r  | <span class='executed'>            totalSupply -= amount;</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'></span>
 204 | *r  | <span class='executed'>        emit Transfer(from, address(0), amount);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'>}</span>
 207 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/tokens/WETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;./ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {SafeTransferLib} from &quot;../utils/SafeTransferLib.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @notice Minimalist and modern Wrapped Ether implementation.</span>
  9 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)</span>
 10 |     | <span class='unexecuted'>/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)</span>
 11 |     | <span class='unexecuted'>contract WETH is ERC20(&quot;Wrapped Ether&quot;, &quot;WETH&quot;, 18) {</span>
 12 |     | <span class='neutral'>    using SafeTransferLib for address;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    event Deposit(address indexed from, uint256 amount);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    event Withdrawal(address indexed to, uint256 amount);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function deposit() public payable virtual {</span>
 19 |     | <span class='unexecuted'>        _mint(msg.sender, msg.value);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>        emit Deposit(msg.sender, msg.value);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function withdraw(uint256 amount) public virtual {</span>
 25 |     | <span class='unexecuted'>        _burn(msg.sender, amount);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>        emit Withdrawal(msg.sender, amount);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        msg.sender.safeTransferETH(amount);</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    receive() external payable virtual {</span>
 33 |     | <span class='unexecuted'>        deposit();</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/utils/Bytes32AddressLib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Library for converting between addresses and bytes32 values.</span>
  5 |     | <span class='unexecuted'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)</span>
  6 |     | <span class='neutral'>library Bytes32AddressLib {</span>
  7 |     | <span class='unexecuted'>    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return address(uint160(uint256(bytesValue)));</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {</span>
 12 |     | <span class='neutral'>        return bytes32(bytes20(addressValue));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/utils/CREATE3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Bytes32AddressLib} from &quot;./Bytes32AddressLib.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Deploy to deterministic addresses without an initcode factor.</span>
  7 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)</span>
  8 |     | <span class='unexecuted'>/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)</span>
  9 |     | <span class='neutral'>library CREATE3 {</span>
 10 |     | <span class='neutral'>    using Bytes32AddressLib for bytes32;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 13 |     | <span class='neutral'>    // Opcode     | Opcode + Arguments    | Description      | Stack View             //</span>
 14 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 15 |     | <span class='neutral'>    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //</span>
 16 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //</span>
 17 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //</span>
 18 |     | <span class='neutral'>    // 0x37       |  0x37                 | CALLDATACOPY     |                        //</span>
 19 |     | <span class='neutral'>    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //</span>
 20 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //</span>
 21 |     | <span class='neutral'>    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //</span>
 22 |     | <span class='neutral'>    // 0xf0       |  0xf0                 | CREATE           | newContract            //</span>
 23 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 24 |     | <span class='neutral'>    // Opcode     | Opcode + Arguments    | Description      | Stack View             //</span>
 25 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 26 |     | <span class='neutral'>    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //</span>
 27 |     | <span class='neutral'>    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //</span>
 28 |     | <span class='neutral'>    // 0x52       |  0x52                 | MSTORE           |                        //</span>
 29 |     | <span class='neutral'>    // 0x60       |  0x6008               | PUSH1 08         | 8                      //</span>
 30 |     | <span class='neutral'>    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //</span>
 31 |     | <span class='neutral'>    // 0xf3       |  0xf3                 | RETURN           |                        //</span>
 32 |     | <span class='neutral'>    //--------------------------------------------------------------------------------//</span>
 33 |     | <span class='neutral'>    bytes internal constant PROXY_BYTECODE = hex&quot;67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3&quot;;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function deploy(</span>
 38 |     | <span class='neutral'>        bytes32 salt,</span>
 39 |     | <span class='neutral'>        bytes memory creationCode,</span>
 40 |     | <span class='neutral'>        uint256 value</span>
 41 |     | <span class='unexecuted'>    ) internal returns (address deployed) {</span>
 42 |     | <span class='unexecuted'>        bytes memory proxyChildBytecode = PROXY_BYTECODE;</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        address proxy;</span>
 45 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 46 |     | <span class='neutral'>        assembly {</span>
 47 |     | <span class='neutral'>            // Deploy a new contract with our pre-made bytecode via CREATE2.</span>
 48 |     | <span class='neutral'>            // We start 32 bytes into the code to avoid copying the byte length.</span>
 49 |     | <span class='unexecuted'>            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)</span>
 50 |     | <span class='neutral'>        }</span>
 51 |     | <span class='unexecuted'>        require(proxy != address(0), &quot;DEPLOYMENT_FAILED&quot;);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>        deployed = getDeployed(salt);</span>
 54 |     | <span class='unexecuted'>        (bool success, ) = proxy.call{value: value}(creationCode);</span>
 55 |     | <span class='unexecuted'>        require(success &amp;&amp; deployed.code.length != 0, &quot;INITIALIZATION_FAILED&quot;);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>    function getDeployed(bytes32 salt) internal view returns (address) {</span>
 59 |     | <span class='unexecuted'>        address proxy = keccak256(</span>
 60 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 61 |     | <span class='neutral'>                // Prefix:</span>
 62 |     | <span class='unexecuted'>                bytes1(0xFF),</span>
 63 |     | <span class='neutral'>                // Creator:</span>
 64 |     | <span class='unexecuted'>                address(this),</span>
 65 |     | <span class='neutral'>                // Salt:</span>
 66 |     | <span class='neutral'>                salt,</span>
 67 |     | <span class='neutral'>                // Bytecode hash:</span>
 68 |     | <span class='neutral'>                PROXY_BYTECODE_HASH</span>
 69 |     | <span class='neutral'>            )</span>
 70 |     | <span class='neutral'>        ).fromLast20Bytes();</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>        return</span>
 73 |     | <span class='unexecuted'>            keccak256(</span>
 74 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 75 |     | <span class='neutral'>                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)</span>
 76 |     | <span class='neutral'>                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)</span>
 77 |     | <span class='neutral'>                    hex&quot;d6_94&quot;,</span>
 78 |     | <span class='neutral'>                    proxy,</span>
 79 |     | <span class='neutral'>                    hex&quot;01&quot; // Nonce of the proxy contract (1)</span>
 80 |     | <span class='neutral'>                )</span>
 81 |     | <span class='neutral'>            ).fromLast20Bytes();</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/utils/FixedPointMathLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Arithmetic library with operations for fixed-point numbers.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)</span>
   6 |     | <span class='unexecuted'>/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)</span>
   7 |     | <span class='neutral'>library FixedPointMathLib {</span>
   8 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
   9 |     | <span class='neutral'>                    SIMPLIFIED FIXED POINT OPERATIONS</span>
  10 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    uint256 internal constant MAX_UINT256 = 2**256 - 1;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  17 |     | <span class='unexecuted'>        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  21 |     | <span class='unexecuted'>        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  25 |     | <span class='unexecuted'>        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {</span>
  29 |     | <span class='unexecuted'>        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  33 |     | <span class='neutral'>                    LOW LEVEL FIXED POINT OPERATIONS</span>
  34 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  35 |     | <span class='neutral'></span>
  36 | *r  | <span class='executed'>    function mulDivDown(</span>
  37 |     | <span class='neutral'>        uint256 x,</span>
  38 |     | <span class='neutral'>        uint256 y,</span>
  39 |     | <span class='neutral'>        uint256 denominator</span>
  40 | *r  | <span class='executed'>    ) internal pure returns (uint256 z) {</span>
  41 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  42 |     | <span class='neutral'>        assembly {</span>
  43 |     | <span class='neutral'>            // Equivalent to require(denominator != 0 &amp;&amp; (y == 0 || x &lt;= type(uint256).max / y))</span>
  44 | *r  | <span class='executed'>            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {</span>
  45 | r   | <span class='reverted'>                revert(0, 0)</span>
  46 |     | <span class='neutral'>            }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>            // Divide x * y by the denominator.</span>
  49 | *r  | <span class='executed'>            z := div(mul(x, y), denominator)</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 | *r  | <span class='executed'>    function mulDivUp(</span>
  54 |     | <span class='neutral'>        uint256 x,</span>
  55 |     | <span class='neutral'>        uint256 y,</span>
  56 |     | <span class='neutral'>        uint256 denominator</span>
  57 | *r  | <span class='executed'>    ) internal pure returns (uint256 z) {</span>
  58 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  59 |     | <span class='neutral'>        assembly {</span>
  60 |     | <span class='neutral'>            // Equivalent to require(denominator != 0 &amp;&amp; (y == 0 || x &lt;= type(uint256).max / y))</span>
  61 | *r  | <span class='executed'>            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {</span>
  62 | r   | <span class='reverted'>                revert(0, 0)</span>
  63 |     | <span class='neutral'>            }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>            // If x * y modulo the denominator is strictly greater than 0,</span>
  66 |     | <span class='neutral'>            // 1 is added to round up the division of x * y by the denominator.</span>
  67 | *r  | <span class='executed'>            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function rpow(</span>
  72 |     | <span class='neutral'>        uint256 x,</span>
  73 |     | <span class='neutral'>        uint256 n,</span>
  74 |     | <span class='neutral'>        uint256 scalar</span>
  75 |     | <span class='neutral'>    ) internal pure returns (uint256 z) {</span>
  76 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  77 |     | <span class='neutral'>        assembly {</span>
  78 |     | <span class='neutral'>            switch x</span>
  79 |     | <span class='neutral'>            case 0 {</span>
  80 |     | <span class='neutral'>                switch n</span>
  81 |     | <span class='neutral'>                case 0 {</span>
  82 |     | <span class='neutral'>                    // 0 ** 0 = 1</span>
  83 |     | <span class='neutral'>                    z := scalar</span>
  84 |     | <span class='neutral'>                }</span>
  85 |     | <span class='neutral'>                default {</span>
  86 |     | <span class='neutral'>                    // 0 ** n = 0</span>
  87 |     | <span class='neutral'>                    z := 0</span>
  88 |     | <span class='neutral'>                }</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='neutral'>            default {</span>
  91 |     | <span class='neutral'>                switch mod(n, 2)</span>
  92 |     | <span class='neutral'>                case 0 {</span>
  93 |     | <span class='neutral'>                    // If n is even, store scalar in z for now.</span>
  94 |     | <span class='neutral'>                    z := scalar</span>
  95 |     | <span class='neutral'>                }</span>
  96 |     | <span class='neutral'>                default {</span>
  97 |     | <span class='neutral'>                    // If n is odd, store x in z for now.</span>
  98 |     | <span class='neutral'>                    z := x</span>
  99 |     | <span class='neutral'>                }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>                // Shifting right by 1 is like dividing by 2.</span>
 102 |     | <span class='neutral'>                let half := shr(1, scalar)</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>                for {</span>
 105 |     | <span class='neutral'>                    // Shift n right by 1 before looping to halve it.</span>
 106 |     | <span class='neutral'>                    n := shr(1, n)</span>
 107 |     | <span class='neutral'>                } n {</span>
 108 |     | <span class='neutral'>                    // Shift n right by 1 each iteration to halve it.</span>
 109 |     | <span class='neutral'>                    n := shr(1, n)</span>
 110 |     | <span class='neutral'>                } {</span>
 111 |     | <span class='neutral'>                    // Revert immediately if x ** 2 would overflow.</span>
 112 |     | <span class='neutral'>                    // Equivalent to iszero(eq(div(xx, x), x)) here.</span>
 113 |     | <span class='neutral'>                    if shr(128, x) {</span>
 114 |     | <span class='neutral'>                        revert(0, 0)</span>
 115 |     | <span class='neutral'>                    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>                    // Store x squared.</span>
 118 |     | <span class='neutral'>                    let xx := mul(x, x)</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>                    // Round to the nearest number.</span>
 121 |     | <span class='neutral'>                    let xxRound := add(xx, half)</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>                    // Revert if xx + half overflowed.</span>
 124 |     | <span class='neutral'>                    if lt(xxRound, xx) {</span>
 125 |     | <span class='neutral'>                        revert(0, 0)</span>
 126 |     | <span class='neutral'>                    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>                    // Set x to scaled xxRound.</span>
 129 |     | <span class='neutral'>                    x := div(xxRound, scalar)</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>                    // If n is even:</span>
 132 |     | <span class='neutral'>                    if mod(n, 2) {</span>
 133 |     | <span class='neutral'>                        // Compute z * x.</span>
 134 |     | <span class='neutral'>                        let zx := mul(z, x)</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>                        // If z * x overflowed:</span>
 137 |     | <span class='neutral'>                        if iszero(eq(div(zx, x), z)) {</span>
 138 |     | <span class='neutral'>                            // Revert if x is non-zero.</span>
 139 |     | <span class='neutral'>                            if iszero(iszero(x)) {</span>
 140 |     | <span class='neutral'>                                revert(0, 0)</span>
 141 |     | <span class='neutral'>                            }</span>
 142 |     | <span class='neutral'>                        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>                        // Round to the nearest number.</span>
 145 |     | <span class='neutral'>                        let zxRound := add(zx, half)</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>                        // Revert if zx + half overflowed.</span>
 148 |     | <span class='neutral'>                        if lt(zxRound, zx) {</span>
 149 |     | <span class='neutral'>                            revert(0, 0)</span>
 150 |     | <span class='neutral'>                        }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>                        // Return properly scaled zxRound.</span>
 153 |     | <span class='neutral'>                        z := div(zxRound, scalar)</span>
 154 |     | <span class='neutral'>                    }</span>
 155 |     | <span class='neutral'>                }</span>
 156 |     | <span class='neutral'>            }</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 161 |     | <span class='neutral'>                        GENERAL NUMBER UTILITIES</span>
 162 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function sqrt(uint256 x) internal pure returns (uint256 z) {</span>
 165 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 166 |     | <span class='neutral'>        assembly {</span>
 167 |     | <span class='neutral'>            let y := x // We start y at x, which will help us make our initial estimate.</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>            z := 181 // The &quot;correct&quot; value is 1, but this saves a multiplication later.</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad</span>
 172 |     | <span class='neutral'>            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>            // We check y &gt;= 2^(k + 8) but shift right by k bits</span>
 175 |     | <span class='neutral'>            // each branch to ensure that if x &gt;= 256, then y &gt;= 256.</span>
 176 |     | <span class='neutral'>            if iszero(lt(y, 0x10000000000000000000000000000000000)) {</span>
 177 |     | <span class='neutral'>                y := shr(128, y)</span>
 178 |     | <span class='neutral'>                z := shl(64, z)</span>
 179 |     | <span class='neutral'>            }</span>
 180 |     | <span class='neutral'>            if iszero(lt(y, 0x1000000000000000000)) {</span>
 181 |     | <span class='neutral'>                y := shr(64, y)</span>
 182 |     | <span class='neutral'>                z := shl(32, z)</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>            if iszero(lt(y, 0x10000000000)) {</span>
 185 |     | <span class='neutral'>                y := shr(32, y)</span>
 186 |     | <span class='neutral'>                z := shl(16, z)</span>
 187 |     | <span class='neutral'>            }</span>
 188 |     | <span class='neutral'>            if iszero(lt(y, 0x1000000)) {</span>
 189 |     | <span class='neutral'>                y := shr(16, y)</span>
 190 |     | <span class='neutral'>                z := shl(8, z)</span>
 191 |     | <span class='neutral'>            }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>            // Goal was to get z*z*y within a small factor of x. More iterations could</span>
 194 |     | <span class='neutral'>            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).</span>
 195 |     | <span class='neutral'>            // We ensured y &gt;= 256 so that the relative difference between y and y+1 is small.</span>
 196 |     | <span class='neutral'>            // That&#39;s not possible if x &lt; 256 but we can just verify those cases exhaustively.</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>            // Now, z*z*y &lt;= x &lt; z*z*(y+1), and y &lt;= 2^(16+8), and either y &gt;= 256, or x &lt; 256.</span>
 199 |     | <span class='neutral'>            // Correctness can be checked exhaustively for x &lt; 256, so we assume y &gt;= 256.</span>
 200 |     | <span class='neutral'>            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range</span>
 203 |     | <span class='neutral'>            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate</span>
 206 |     | <span class='neutral'>            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>            // There is no overflow risk here since y &lt; 2^136 after the first branch above.</span>
 209 |     | <span class='neutral'>            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.</span>
 212 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 213 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 214 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 215 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 216 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 217 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 218 |     | <span class='neutral'>            z := shr(1, add(z, div(x, z)))</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>            // If x+1 is a perfect square, the Babylonian method cycles between</span>
 221 |     | <span class='neutral'>            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.</span>
 222 |     | <span class='neutral'>            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division</span>
 223 |     | <span class='neutral'>            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.</span>
 224 |     | <span class='neutral'>            // If you don&#39;t care whether the floor or ceil square root is returned, you can remove this statement.</span>
 225 |     | <span class='neutral'>            z := sub(z, lt(div(x, z), z))</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 230 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 231 |     | <span class='neutral'>        assembly {</span>
 232 |     | <span class='neutral'>            // Mod x by y. Note this will return</span>
 233 |     | <span class='neutral'>            // 0 instead of reverting if y is zero.</span>
 234 |     | <span class='neutral'>            z := mod(x, y)</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {</span>
 239 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 240 |     | <span class='neutral'>        assembly {</span>
 241 |     | <span class='neutral'>            // Divide x by y. Note this will return</span>
 242 |     | <span class='neutral'>            // 0 instead of reverting if y is zero.</span>
 243 |     | <span class='neutral'>            r := div(x, y)</span>
 244 |     | <span class='neutral'>        }</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 248 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 249 |     | <span class='neutral'>        assembly {</span>
 250 |     | <span class='neutral'>            // Add 1 to x * y if x % y &gt; 0. Note this will</span>
 251 |     | <span class='neutral'>            // return 0 instead of reverting if y is zero.</span>
 252 |     | <span class='neutral'>            z := add(gt(mod(x, y), 0), div(x, y))</span>
 253 |     | <span class='neutral'>        }</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'>}</span>
 256 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/lib/solmate/src/utils/SafeTransferLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {ERC20} from &quot;../tokens/ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.</span>
   7 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)</span>
   8 |     | <span class='neutral'>/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.</span>
   9 |     | <span class='unexecuted'>/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.</span>
  10 |     | <span class='neutral'>library SafeTransferLib {</span>
  11 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  12 |     | <span class='neutral'>                             ETH OPERATIONS</span>
  13 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function safeTransferETH(address to, uint256 amount) internal {</span>
  16 |     | <span class='unexecuted'>        bool success;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  19 |     | <span class='neutral'>        assembly {</span>
  20 |     | <span class='neutral'>            // Transfer the ETH and store if it succeeded or not.</span>
  21 |     | <span class='unexecuted'>            success := call(gas(), to, amount, 0, 0, 0, 0)</span>
  22 |     | <span class='neutral'>        }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>        require(success, &quot;ETH_TRANSFER_FAILED&quot;);</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                            ERC20 OPERATIONS</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 | *r  | <span class='executed'>    function safeTransferFrom(</span>
  32 |     | <span class='neutral'>        ERC20 token,</span>
  33 |     | <span class='neutral'>        address from,</span>
  34 |     | <span class='neutral'>        address to,</span>
  35 |     | <span class='neutral'>        uint256 amount</span>
  36 | *r  | <span class='executed'>    ) internal {</span>
  37 | *r  | <span class='executed'>        bool success;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  40 |     | <span class='neutral'>        assembly {</span>
  41 |     | <span class='neutral'>            // Get a pointer to some free memory.</span>
  42 | *r  | <span class='executed'>            let freeMemoryPointer := mload(0x40)</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
  45 | *r  | <span class='executed'>            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)</span>
  46 | *r  | <span class='executed'>            mstore(add(freeMemoryPointer, 4), from) // Append the &quot;from&quot; argument.</span>
  47 | *r  | <span class='executed'>            mstore(add(freeMemoryPointer, 36), to) // Append the &quot;to&quot; argument.</span>
  48 | *r  | <span class='executed'>            mstore(add(freeMemoryPointer, 68), amount) // Append the &quot;amount&quot; argument.</span>
  49 |     | <span class='neutral'></span>
  50 | *r  | <span class='executed'>            success := and(</span>
  51 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
  52 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
  53 | *r  | <span class='executed'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
  54 |     | <span class='neutral'>                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.</span>
  55 |     | <span class='neutral'>                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.</span>
  56 |     | <span class='neutral'>                // Counterintuitively, this call must be positioned second to the or() call in the</span>
  57 |     | <span class='neutral'>                // surrounding and() call or else returndatasize() will be zero during the computation.</span>
  58 | *r  | <span class='executed'>                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)</span>
  59 |     | <span class='neutral'>            )</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'></span>
  62 | *r  | <span class='executed'>        require(success, &quot;TRANSFER_FROM_FAILED&quot;);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 | *r  | <span class='executed'>    function safeTransfer(</span>
  66 |     | <span class='neutral'>        ERC20 token,</span>
  67 |     | <span class='neutral'>        address to,</span>
  68 |     | <span class='neutral'>        uint256 amount</span>
  69 |     | <span class='unexecuted'>    ) internal {</span>
  70 | *r  | <span class='executed'>        bool success;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  73 |     | <span class='neutral'>        assembly {</span>
  74 |     | <span class='neutral'>            // Get a pointer to some free memory.</span>
  75 | *r  | <span class='executed'>            let freeMemoryPointer := mload(0x40)</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
  78 | *r  | <span class='executed'>            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)</span>
  79 | *r  | <span class='executed'>            mstore(add(freeMemoryPointer, 4), to) // Append the &quot;to&quot; argument.</span>
  80 | *r  | <span class='executed'>            mstore(add(freeMemoryPointer, 36), amount) // Append the &quot;amount&quot; argument.</span>
  81 |     | <span class='neutral'></span>
  82 | *r  | <span class='executed'>            success := and(</span>
  83 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
  84 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
  85 | *r  | <span class='executed'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
  86 |     | <span class='neutral'>                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.</span>
  87 |     | <span class='neutral'>                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.</span>
  88 |     | <span class='neutral'>                // Counterintuitively, this call must be positioned second to the or() call in the</span>
  89 |     | <span class='neutral'>                // surrounding and() call or else returndatasize() will be zero during the computation.</span>
  90 | *r  | <span class='executed'>                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)</span>
  91 |     | <span class='neutral'>            )</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 | *r  | <span class='executed'>        require(success, &quot;TRANSFER_FAILED&quot;);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function safeApprove(</span>
  98 |     | <span class='neutral'>        ERC20 token,</span>
  99 |     | <span class='neutral'>        address to,</span>
 100 |     | <span class='neutral'>        uint256 amount</span>
 101 |     | <span class='unexecuted'>    ) internal {</span>
 102 |     | <span class='unexecuted'>        bool success;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 105 |     | <span class='neutral'>        assembly {</span>
 106 |     | <span class='neutral'>            // Get a pointer to some free memory.</span>
 107 |     | <span class='unexecuted'>            let freeMemoryPointer := mload(0x40)</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>            // Write the abi-encoded calldata into memory, beginning with the function selector.</span>
 110 |     | <span class='unexecuted'>            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)</span>
 111 |     | <span class='unexecuted'>            mstore(add(freeMemoryPointer, 4), to) // Append the &quot;to&quot; argument.</span>
 112 |     | <span class='unexecuted'>            mstore(add(freeMemoryPointer, 36), amount) // Append the &quot;amount&quot; argument.</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>            success := and(</span>
 115 |     | <span class='neutral'>                // Set success to whether the call reverted, if not we check it either</span>
 116 |     | <span class='neutral'>                // returned exactly 1 (can&#39;t just be non-zero data), or had no return data.</span>
 117 |     | <span class='unexecuted'>                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),</span>
 118 |     | <span class='neutral'>                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.</span>
 119 |     | <span class='neutral'>                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.</span>
 120 |     | <span class='neutral'>                // Counterintuitively, this call must be positioned second to the or() call in the</span>
 121 |     | <span class='neutral'>                // surrounding and() call or else returndatasize() will be zero during the computation.</span>
 122 |     | <span class='unexecuted'>                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)</span>
 123 |     | <span class='neutral'>            )</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        require(success, &quot;APPROVE_FAILED&quot;);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'>}</span>
 129 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/script/DeployLeveragedEthLocal.s.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/console2.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import {DeployLeveragedEth} from &quot;./base/DeployLeveragedEth.sol&quot;;</span>
  8 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  9 |     | <span class='neutral'>import {MockWETH} from &quot;../test/mocks/MockWETH.sol&quot;;</span>
 10 |     | <span class='neutral'>import {MockUSDC} from &quot;../test/mocks/MockUSDC.sol&quot;;</span>
 11 |     | <span class='unexecuted'></span>
 12 |     | <span class='neutral'>contract DeployScript is DeployLeveragedEth, Test {</span>
 13 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    address constant alice = address(0x06);</span>
 16 |     | <span class='unexecuted'>    address constant bob = address(0x07);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function deployMockTokens() internal override {</span>
 19 |     | <span class='unexecuted'>        weth = new MockWETH();</span>
 20 |     | <span class='unexecuted'>        usdc = new MockUSDC();</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function run() external {</span>
 24 |     | <span class='unexecuted'>        if (block.chainid != 31337) {</span>
 25 |     | <span class='unexecuted'>            console2.log(&quot;Not local&quot;);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>            return;</span>
 28 |     | <span class='neutral'>        }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        deployMockTokens();</span>
 31 |     | <span class='unexecuted'>        deployMocks();</span>
 32 |     | <span class='unexecuted'>        deploy();</span>
 33 |     | <span class='unexecuted'>        fixtures();</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function fixtures() internal {</span>
 37 |     | <span class='unexecuted'>        console2.log(&quot;\nexecuting steth fixtures\n&quot;);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        fund();</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>        deposit(alice, address(wethContract), 10e18);</span>
 42 |     | <span class='unexecuted'>        deposit(bob, address(wethContract), 10e18);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        harvest();</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        redeem(alice);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function fund() internal {</span>
 50 |     | <span class='unexecuted'>        console2.log(&quot;funding&quot;);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        // Dole out ETH</span>
 53 |     | <span class='unexecuted'>        deal(alice, 10e18);</span>
 54 |     | <span class='unexecuted'>        deal(bob, 10e18);</span>
 55 |     | <span class='unexecuted'>        deal(keeper, 10e18);</span>
 56 |     | <span class='unexecuted'>        deal(address(curveEthStEthPool), 100e18);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>        // Dole out WETH</span>
 59 |     | <span class='unexecuted'>        deal(address(weth), 100e18);</span>
 60 |     | <span class='unexecuted'>        deal(address(weth), alice, 100e18);</span>
 61 |     | <span class='unexecuted'>        deal(address(weth), bob, 100e18);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>    function deposit(address from, address to, uint256 amount) internal {</span>
 65 |     | <span class='unexecuted'>        console2.log(&quot;depositing&quot;, from);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>        vm.startPrank(from);</span>
 68 |     | <span class='unexecuted'>        weth.approve(address(to), type(uint256).max);</span>
 69 |     | <span class='unexecuted'>        wethContract.deposit(amount, from);</span>
 70 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>    function harvest() internal {</span>
 74 |     | <span class='unexecuted'>        console2.log(&quot;harvesting&quot;);</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 77 |     | <span class='unexecuted'>        wethContract.harvest();</span>
 78 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='unexecuted'>    function redeem(address redeemer) internal {</span>
 82 |     | <span class='unexecuted'>        console2.log(&quot;redeeming&quot;, redeemer);</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='unexecuted'>        uint256 stEthToEthSlippage = 0.99e18;</span>
 85 |     | <span class='unexecuted'>        curveEthStEthPool.setSlippage(stEthToEthSlippage);</span>
 86 |     | <span class='neutral'></span>
 87 |     | <span class='unexecuted'>        uint256 withdrawAmount = 1e18;</span>
 88 |     | <span class='unexecuted'>        uint256 sharesToReddem = wethContract.convertToShares(withdrawAmount);</span>
 89 |     | <span class='unexecuted'>        vm.prank(redeemer);</span>
 90 |     | <span class='unexecuted'>        wethContract.redeem(sharesToReddem, redeemer, redeemer);</span>
 91 |     | <span class='neutral'>    }</span>
 92 |     | <span class='neutral'>}</span>
 93 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/script/DeployLeveragedEthMainnet.s.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {CREATE3Script} from &quot;./base/CREATE3Script.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  8 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  9 |     | <span class='neutral'>import {IPoolDataProvider} from &quot;aave-v3/interfaces/IPoolDataProvider.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>import {Constants as C} from &quot;../src/lib/Constants.sol&quot;;</span>
 12 |     | <span class='neutral'>import {ICurvePool} from &quot;../src/interfaces/curve/ICurvePool.sol&quot;;</span>
 13 |     | <span class='neutral'>import {ILido} from &quot;../src/interfaces/lido/ILido.sol&quot;;</span>
 14 |     | <span class='neutral'>import {IwstETH} from &quot;../src/interfaces/lido/IwstETH.sol&quot;;</span>
 15 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
 16 |     | <span class='neutral'>import {IVault} from &quot;../src/interfaces/balancer/IVault.sol&quot;;</span>
 17 |     | <span class='neutral'>import {ISwapRouter} from &quot;../src/interfaces/uniswap/ISwapRouter.sol&quot;;</span>
 18 |     | <span class='neutral'>import {scWETH} from &quot;../src/steth/scWETH.sol&quot;;</span>
 19 |     | <span class='neutral'>import {scUSDC} from &quot;../src/steth/scUSDC.sol&quot;;</span>
 20 |     | <span class='unexecuted'></span>
 21 |     | <span class='neutral'>contract DeployScript is CREATE3Script {</span>
 22 |     | <span class='unexecuted'>    constructor() CREATE3Script(vm.envString(&quot;VERSION&quot;)) {}</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function run() external returns (scWETH scWeth, scUSDC scUsdc) {</span>
 25 |     | <span class='unexecuted'>        uint256 deployerPrivateKey = uint256(vm.envBytes32(&quot;PRIVATE_KEY&quot;));</span>
 26 |     | <span class='unexecuted'>        address keeper = vm.envAddress(&quot;KEEPER&quot;);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>        vm.startBroadcast(deployerPrivateKey);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory scWethParams = scWETH.ConstructorParams({</span>
 31 |     | <span class='unexecuted'>            admin: address(this),</span>
 32 |     | <span class='neutral'>            keeper: keeper,</span>
 33 |     | <span class='unexecuted'>            targetLtv: 0.7e18,</span>
 34 |     | <span class='unexecuted'>            slippageTolerance: 0.99e18,</span>
 35 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
 36 |     | <span class='neutral'>            aaveAwstEth: IAToken(C.AAVE_AWSTETH_TOKEN),</span>
 37 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
 38 |     | <span class='neutral'>            curveEthStEthPool: ICurvePool(C.CURVE_ETH_STETH_POOL),</span>
 39 |     | <span class='neutral'>            stEth: ILido(C.STETH),</span>
 40 |     | <span class='neutral'>            wstEth: IwstETH(C.WSTETH),</span>
 41 |     | <span class='neutral'>            weth: WETH(payable(C.WETH)),</span>
 42 |     | <span class='neutral'>            stEthToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_STETH_ETH_PRICE_FEED),</span>
 43 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
 44 |     | <span class='neutral'>        });</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        scWeth = new scWETH(scWethParams);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>        scUSDC.ConstructorParams memory scUsdcParams = scUSDC.ConstructorParams({</span>
 49 |     | <span class='unexecuted'>            admin: address(this),</span>
 50 |     | <span class='neutral'>            keeper: keeper,</span>
 51 |     | <span class='neutral'>            scWETH: scWeth,</span>
 52 |     | <span class='neutral'>            usdc: ERC20(C.USDC),</span>
 53 |     | <span class='neutral'>            weth: WETH(payable(C.WETH)),</span>
 54 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
 55 |     | <span class='neutral'>            aavePoolDataProvider: IPoolDataProvider(C.AAVE_POOL_DATA_PROVIDER),</span>
 56 |     | <span class='neutral'>            aaveAUsdc: IAToken(C.AAVE_AUSDC_TOKEN),</span>
 57 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
 58 |     | <span class='neutral'>            uniswapSwapRouter: ISwapRouter(C.UNISWAP_V3_SWAP_ROUTER),</span>
 59 |     | <span class='neutral'>            chainlinkUsdcToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_USDC_ETH_PRICE_FEED),</span>
 60 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
 61 |     | <span class='neutral'>        });</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>        scUsdc = new scUSDC(scUsdcParams);</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>        vm.stopBroadcast();</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/script/DeployLeveragedEthTestnet.s.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/console2.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import {DeployLeveragedEth} from &quot;./base/DeployLeveragedEth.sol&quot;;</span>
  8 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  9 |     | <span class='neutral'>import {MockWETH} from &quot;../test/mocks/MockWETH.sol&quot;;</span>
 10 |     | <span class='neutral'>import {MockUSDC} from &quot;../test/mocks/MockUSDC.sol&quot;;</span>
 11 |     | <span class='unexecuted'></span>
 12 |     | <span class='neutral'>contract DeployScript is DeployLeveragedEth {</span>
 13 |     | <span class='unexecuted'>    function deployMockTokens() internal override {</span>
 14 |     | <span class='unexecuted'>        weth = new MockWETH();</span>
 15 |     | <span class='unexecuted'>        usdc = MockUSDC(0x30e2B7a907997fDC5a71E377Ece54FAae9F5392D);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function run() external {</span>
 19 |     | <span class='unexecuted'>        deployMockTokens();</span>
 20 |     | <span class='unexecuted'>        deployMocks();</span>
 21 |     | <span class='unexecuted'>        deploy();</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/script/base/CREATE3Script.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {CREATE3Factory} from &quot;create3-factory/CREATE3Factory.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;forge-std/Script.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract CREATE3Script is Script {</span>
  9 |     | <span class='neutral'>    CREATE3Factory internal constant create3 = CREATE3Factory(0x9fBB3DF7C40Da2e5A0dE984fFE2CCB7C47cd0ABf);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    string internal version;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    constructor(string memory version_) {</span>
 14 |     | <span class='unexecuted'>        version = version_;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function getCreate3Contract(string memory name) internal view virtual returns (address) {</span>
 18 |     | <span class='neutral'>        uint256 deployerPrivateKey = uint256(vm.envBytes32(&quot;PRIVATE_KEY&quot;));</span>
 19 |     | <span class='neutral'>        address deployer = vm.addr(deployerPrivateKey);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>        return create3.getDeployed(deployer, getCreate3ContractSalt(name));</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function getCreate3ContractSalt(string memory name) internal view virtual returns (bytes32) {</span>
 25 |     | <span class='neutral'>        return keccak256(bytes(string.concat(name, &quot;-v&quot;, version)));</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/script/base/DeployLeveragedEth.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/console2.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {CREATE3Script} from &quot;./CREATE3Script.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IPoolDataProvider} from &quot;aave-v3/interfaces/IPoolDataProvider.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>import {Constants as C} from &quot;../../src/lib/Constants.sol&quot;;</span>
  14 |     | <span class='neutral'>import {ICurvePool} from &quot;../../src/interfaces/curve/ICurvePool.sol&quot;;</span>
  15 |     | <span class='neutral'>import {ILido} from &quot;../../src/interfaces/lido/ILido.sol&quot;;</span>
  16 |     | <span class='neutral'>import {IwstETH} from &quot;../../src/interfaces/lido/IwstETH.sol&quot;;</span>
  17 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IVault} from &quot;../../src/interfaces/balancer/IVault.sol&quot;;</span>
  19 |     | <span class='neutral'>import {ISwapRouter} from &quot;../../src/interfaces/uniswap/ISwapRouter.sol&quot;;</span>
  20 |     | <span class='neutral'>import {scWETH} from &quot;../../src/steth/scWETH.sol&quot;;</span>
  21 |     | <span class='neutral'>import {scUSDC} from &quot;../../src/steth/scUSDC.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>import {MockWETH} from &quot;../../test/mocks/MockWETH.sol&quot;;</span>
  24 |     | <span class='neutral'>import {MockUSDC} from &quot;../../test/mocks/MockUSDC.sol&quot;;</span>
  25 |     | <span class='neutral'>import {MockAavePool} from &quot;../../test/mocks/aave-v3/MockAavePool.sol&quot;;</span>
  26 |     | <span class='neutral'>import {MockAavePoolDataProvider} from &quot;../../test/mocks/aave-v3/MockAavePoolDataProvider.sol&quot;;</span>
  27 |     | <span class='neutral'>import {MockAUsdc} from &quot;../../test/mocks/aave-v3/MockAUsdc.sol&quot;;</span>
  28 |     | <span class='neutral'>import {MockVarDebtWETH} from &quot;../../test/mocks/aave-v3/MockVarDebtWETH.sol&quot;;</span>
  29 |     | <span class='neutral'>import {MockAwstETH} from &quot;../../test/mocks/aave-v3/MockAwstETH.sol&quot;;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>import {MockStETH} from &quot;../../test/mocks/lido/MockStETH.sol&quot;;</span>
  32 |     | <span class='neutral'>import {MockWstETH} from &quot;../../test/mocks/lido/MockWstETH.sol&quot;;</span>
  33 |     | <span class='neutral'>import {MockCurvePool} from &quot;../../test/mocks/curve/MockCurvePool.sol&quot;;</span>
  34 |     | <span class='neutral'>import {MockChainlinkPriceFeed} from &quot;../../test/mocks/chainlink/MockChainlinkPriceFeed.sol&quot;;</span>
  35 |     | <span class='neutral'>import {MockBalancerVault} from &quot;../../test/mocks/balancer/MockBalancerVault.sol&quot;;</span>
  36 |     | <span class='neutral'>import {MockSwapRouter} from &quot;../../test/mocks/uniswap/MockSwapRouter.sol&quot;;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>abstract contract DeployLeveragedEth is CREATE3Script {</span>
  39 |     | <span class='neutral'>    MockWETH weth;</span>
  40 |     | <span class='neutral'>    MockUSDC usdc;</span>
  41 |     | <span class='neutral'>    MockAavePool aavePool;</span>
  42 |     | <span class='neutral'>    MockAavePoolDataProvider aavePoolDataProvider;</span>
  43 |     | <span class='neutral'>    MockAUsdc aaveAUsdc;</span>
  44 |     | <span class='neutral'>    MockVarDebtWETH aaveVarDWeth;</span>
  45 |     | <span class='neutral'>    MockStETH stEth;</span>
  46 |     | <span class='neutral'>    MockWstETH wstEth;</span>
  47 |     | <span class='neutral'>    MockAwstETH aaveAwstEth;</span>
  48 |     | <span class='neutral'>    MockCurvePool curveEthStEthPool;</span>
  49 |     | <span class='neutral'>    MockChainlinkPriceFeed stEthToEthPriceFeed;</span>
  50 |     | <span class='neutral'>    MockChainlinkPriceFeed usdcToEthPriceFeed;</span>
  51 |     | <span class='neutral'>    MockBalancerVault balancerVault;</span>
  52 |     | <span class='neutral'>    MockSwapRouter uniswapRouter;</span>
  53 |     | <span class='neutral'>    scWETH wethContract;</span>
  54 |     | <span class='neutral'>    scUSDC usdcContract;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    address keeper = vm.envAddress(&quot;KEEPER&quot;);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    constructor() CREATE3Script(vm.envString(&quot;VERSION&quot;)) {}</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function deploy() internal {</span>
  61 |     | <span class='unexecuted'>        uint256 deployerPrivateKey = uint256(vm.envBytes32(&quot;PRIVATE_KEY&quot;));</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        vm.startBroadcast(deployerPrivateKey);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        deployMocks();</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory scWethParams = scWETH.ConstructorParams({</span>
  68 |     | <span class='unexecuted'>            admin: address(this),</span>
  69 |     | <span class='unexecuted'>            keeper: keeper,</span>
  70 |     | <span class='unexecuted'>            targetLtv: 0.7e18,</span>
  71 |     | <span class='unexecuted'>            slippageTolerance: 0.99e18,</span>
  72 |     | <span class='unexecuted'>            aavePool: aavePool,</span>
  73 |     | <span class='unexecuted'>            aaveAwstEth: IAToken(address(aaveAwstEth)),</span>
  74 |     | <span class='unexecuted'>            aaveVarDWeth: ERC20(address(aaveVarDWeth)),</span>
  75 |     | <span class='unexecuted'>            curveEthStEthPool: curveEthStEthPool,</span>
  76 |     | <span class='unexecuted'>            stEth: ILido(address(stEth)),</span>
  77 |     | <span class='unexecuted'>            wstEth: IwstETH(address(wstEth)),</span>
  78 |     | <span class='unexecuted'>            weth: WETH(payable(weth)),</span>
  79 |     | <span class='unexecuted'>            stEthToEthPriceFeed: stEthToEthPriceFeed,</span>
  80 |     | <span class='unexecuted'>            balancerVault: balancerVault</span>
  81 |     | <span class='neutral'>        });</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        wethContract = new scWETH(scWethParams);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>        scUSDC.ConstructorParams memory scUsdcParams = scUSDC.ConstructorParams({</span>
  86 |     | <span class='unexecuted'>            admin: address(this),</span>
  87 |     | <span class='unexecuted'>            keeper: keeper,</span>
  88 |     | <span class='neutral'>            scWETH: wethContract,</span>
  89 |     | <span class='unexecuted'>            usdc: usdc,</span>
  90 |     | <span class='unexecuted'>            weth: WETH(payable(weth)),</span>
  91 |     | <span class='unexecuted'>            aavePool: aavePool,</span>
  92 |     | <span class='unexecuted'>            aavePoolDataProvider: aavePoolDataProvider,</span>
  93 |     | <span class='unexecuted'>            aaveAUsdc: IAToken(address(aaveAUsdc)),</span>
  94 |     | <span class='unexecuted'>            aaveVarDWeth: ERC20(address(aaveVarDWeth)),</span>
  95 |     | <span class='unexecuted'>            uniswapSwapRouter: uniswapRouter,</span>
  96 |     | <span class='unexecuted'>            chainlinkUsdcToEthPriceFeed: usdcToEthPriceFeed,</span>
  97 |     | <span class='unexecuted'>            balancerVault: balancerVault</span>
  98 |     | <span class='neutral'>        });</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        usdcContract = new scUSDC(scUsdcParams);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        vm.stopBroadcast();</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function deployMockTokens() internal virtual {}</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function deployMocks() internal {</span>
 108 |     | <span class='unexecuted'>        stEth = new MockStETH();</span>
 109 |     | <span class='unexecuted'>        wstEth = new MockWstETH(stEth);</span>
 110 |     | <span class='unexecuted'>        stEthToEthPriceFeed = new MockChainlinkPriceFeed(address(stEth), address(weth), 1e18);</span>
 111 |     | <span class='unexecuted'>        usdcToEthPriceFeed = new MockChainlinkPriceFeed(address(usdc), address(weth), 0.001e18);</span>
 112 |     | <span class='unexecuted'>        aavePool = new MockAavePool();</span>
 113 |     | <span class='unexecuted'>        aavePool.setStEthToEthPriceFeed(stEthToEthPriceFeed, wstEth, weth);</span>
 114 |     | <span class='unexecuted'>        aavePoolDataProvider = new MockAavePoolDataProvider(address(usdc), address(weth));</span>
 115 |     | <span class='unexecuted'>        aaveAUsdc = new MockAUsdc(aavePool, usdc);</span>
 116 |     | <span class='unexecuted'>        aaveVarDWeth = new MockVarDebtWETH(aavePool, weth);</span>
 117 |     | <span class='unexecuted'>        aaveAwstEth = new MockAwstETH(aavePool, wstEth);</span>
 118 |     | <span class='unexecuted'>        curveEthStEthPool = new MockCurvePool(stEth);</span>
 119 |     | <span class='unexecuted'>        balancerVault = new MockBalancerVault(weth);</span>
 120 |     | <span class='unexecuted'>        uniswapRouter = new MockSwapRouter();</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        console2.log(&quot;weth: contract MockWETH&quot;, address(weth));</span>
 123 |     | <span class='unexecuted'>        console2.log(&quot;usdc: contract MockUSDC&quot;, address(usdc));</span>
 124 |     | <span class='unexecuted'>        console2.log(&quot;aavePool: contract MockAavePool&quot;, address(aavePool));</span>
 125 |     | <span class='unexecuted'>        console2.log(&quot;aavePoolDataProvider: contract MockAavePoolDataProvider&quot;, address(aavePoolDataProvider));</span>
 126 |     | <span class='unexecuted'>        console2.log(&quot;aaveAUsdc: contract MockAUsdc&quot;, address(aaveAUsdc));</span>
 127 |     | <span class='unexecuted'>        console2.log(&quot;aaveVarDWeth: contract MockVarDebtWETH&quot;, address(aaveVarDWeth));</span>
 128 |     | <span class='unexecuted'>        console2.log(&quot;stEth: contract MockStETH&quot;, address(stEth));</span>
 129 |     | <span class='unexecuted'>        console2.log(&quot;wstEth: contract MockWstETH&quot;, address(wstEth));</span>
 130 |     | <span class='unexecuted'>        console2.log(&quot;aaveAwstEth: contract MockAwstETH&quot;, address(aaveAwstEth));</span>
 131 |     | <span class='unexecuted'>        console2.log(&quot;curveEthStEthPool: contract MockCurvePool&quot;, address(curveEthStEthPool));</span>
 132 |     | <span class='unexecuted'>        console2.log(&quot;stEthToEthPriceFeed: contract MockChainlinkPriceFeed&quot;, address(stEthToEthPriceFeed));</span>
 133 |     | <span class='unexecuted'>        console2.log(&quot;usdcToEthPriceFeed: contract MockChainlinkPriceFeed&quot;, address(usdcToEthPriceFeed));</span>
 134 |     | <span class='unexecuted'>        console2.log(&quot;balancerVault: contract MockBalancerVault&quot;, address(balancerVault));</span>
 135 |     | <span class='unexecuted'>        console2.log(&quot;uniswapRouter: contract MockSwapRouter&quot;, address(uniswapRouter));</span>
 136 |     | <span class='unexecuted'>        console2.log(&quot;&quot;);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        weth.mint(address(balancerVault), 100e18);</span>
 139 |     | <span class='unexecuted'>        weth.mint(address(aavePool), 100e18);</span>
 140 |     | <span class='unexecuted'>        console2.log(&quot;weth: minted 100e18 to balancerVault&quot;, address(balancerVault));</span>
 141 |     | <span class='unexecuted'>        console2.log(&quot;weth: minted 100e18 to aavePool&quot;, address(aavePool));</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        console2.log(&quot;NOTE: 1 mWETH = 1000 mUSDC&quot;);</span>
 144 |     | <span class='unexecuted'>        console2.log(&quot;NOTE: 1 mstETH = 1 ETH&quot;);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'>}</span>
 147 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/errors/scErrors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.10;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>error InvalidTargetLtv();</span>
  5 |     | <span class='neutral'>error InvalidMaxLtv();</span>
  6 |     | <span class='neutral'>error InvalidFlashLoanCaller();</span>
  7 |     | <span class='neutral'>error InvalidSlippageTolerance();</span>
  8 |     | <span class='neutral'>error ZeroAddress();</span>
  9 |     | <span class='neutral'>error PleaseUseRedeemMethod();</span>
 10 |     | <span class='neutral'>error FeesTooHigh();</span>
 11 |     | <span class='neutral'>error TreasuryCannotBeZero();</span>
 12 |     | <span class='neutral'>error VaultNotUnderwater();</span>
 13 |     | <span class='neutral'>error CallerNotAdmin();</span>
 14 |     | <span class='neutral'>error CallerNotKeeper();</span>
 15 |     | <span class='neutral'>error NoProfitsToSell();</span>
 16 |     | <span class='neutral'>error EndUsdcBalanceTooLow();</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/balancer/IFlashLoanRecipient.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// Inspired by Aave Protocol&#39;s IFlashLoanReceiver.</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IFlashLoanRecipient {</span>
  7 |     | <span class='neutral'>    /**</span>
  8 |     | <span class='neutral'>     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.</span>
  9 |     | <span class='neutral'>     *</span>
 10 |     | <span class='neutral'>     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this</span>
 11 |     | <span class='neutral'>     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the</span>
 12 |     | <span class='neutral'>     * Vault, or else the entire flash loan will revert.</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * `userData` is the same value passed in the `IVault.flashLoan` call.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function receiveFlashLoan(</span>
 17 |     | <span class='neutral'>        address[] memory tokens,</span>
 18 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 19 |     | <span class='neutral'>        uint256[] memory feeAmounts,</span>
 20 |     | <span class='neutral'>        bytes memory userData</span>
 21 |     | <span class='neutral'>    ) external;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/balancer/IVault.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IVault {</span>
  5 |     | <span class='neutral'>    /**</span>
  6 |     | <span class='neutral'>     * @dev Performs a &#39;flash loan&#39;, sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,</span>
  7 |     | <span class='neutral'>     * and then reverting unless the tokens plus a proportional protocol fee have been returned.</span>
  8 |     | <span class='neutral'>     *</span>
  9 |     | <span class='neutral'>     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount</span>
 10 |     | <span class='neutral'>     * for each token contract. `tokens` must be sorted in ascending order.</span>
 11 |     | <span class='neutral'>     *</span>
 12 |     | <span class='neutral'>     * The &#39;userData&#39; field is ignored by the Vault, and forwarded as-is to `recipient` as part of the</span>
 13 |     | <span class='neutral'>     * `receiveFlashLoan` call.</span>
 14 |     | <span class='neutral'>     *</span>
 15 |     | <span class='neutral'>     * Emits `FlashLoan` events.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function flashLoan(address recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData)</span>
 18 |     | <span class='neutral'>        external;</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/chainlink/AggregatorV3Interface.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface AggregatorV3Interface {</span>
  5 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function description() external view returns (string memory);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function version() external view returns (uint256);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function getRoundData(uint80 _roundId)</span>
 12 |     | <span class='neutral'>        external</span>
 13 |     | <span class='neutral'>        view</span>
 14 |     | <span class='neutral'>        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function latestRoundData()</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/curve/ICurveExchange.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.10;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ICurveExchange {</span>
  5 |     | <span class='neutral'>    function get_exchange_amount(address _pool, address _from, address _to, uint256 _amount)</span>
  6 |     | <span class='neutral'>        external</span>
  7 |     | <span class='neutral'>        view</span>
  8 |     | <span class='neutral'>        returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/curve/ICurvePool.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.10;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface ICurvePool {</span>
 5 |     | <span class='neutral'>    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns (uint256);</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/lido/ILido.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.10;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;openzeppelin-contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ILido is IERC20 {</span>
  7 |     | <span class='neutral'>    function submit(address _referral) external payable returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    /**</span>
 10 |     | <span class='neutral'>     * @return the entire amount of Ether controlled by the protocol.</span>
 11 |     | <span class='neutral'>     *</span>
 12 |     | <span class='neutral'>     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='neutral'>    function getTotalPooledEther() external view returns (uint256);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/lido/IwstETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.10;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;openzeppelin-contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IwstETH is IERC20 {</span>
  7 |     | <span class='neutral'>    function wrap(uint256 _stETHAmount) external returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    /**</span>
 10 |     | <span class='neutral'>     * @notice Exchanges wstETH to stETH</span>
 11 |     | <span class='neutral'>     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH</span>
 12 |     | <span class='neutral'>     * @dev Requirements:</span>
 13 |     | <span class='neutral'>     *  - `_wstETHAmount` must be non-zero</span>
 14 |     | <span class='neutral'>     *  - msg.sender must have at least `_wstETHAmount` wstETH.</span>
 15 |     | <span class='neutral'>     * @return Amount of stETH user receives after unwrap</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function unwrap(uint256 _wstETHAmount) external returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @notice Get amount of wstETH for a given amount of stETH</span>
 21 |     | <span class='neutral'>     * @param _stETHAmount amount of stETH</span>
 22 |     | <span class='neutral'>     * @return Amount of wstETH for a given stETH amount</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /**</span>
 27 |     | <span class='neutral'>     * @notice Get amount of stETH for a given amount of wstETH</span>
 28 |     | <span class='neutral'>     * @param _wstETHAmount amount of wstETH</span>
 29 |     | <span class='neutral'>     * @return Amount of stETH for a given wstETH amount</span>
 30 |     | <span class='neutral'>     */</span>
 31 |     | <span class='neutral'>    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /**</span>
 34 |     | <span class='neutral'>     * @notice Get amount of stETH for a one wstETH</span>
 35 |     | <span class='neutral'>     * @return Amount of stETH for 1 wstETH</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function stEthPerToken() external view returns (uint256);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @notice Get amount of wstETH for a one stETH</span>
 41 |     | <span class='neutral'>     * @return Amount of wstETH for a 1 stETH</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='neutral'>    function tokensPerStEth() external view returns (uint256);</span>
 44 |     | <span class='neutral'>}</span>
 45 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/interfaces/uniswap/ISwapRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Router token swapping functionality</span>
  5 |     | <span class='neutral'>/// @notice Functions for swapping tokens via Uniswap V3</span>
  6 |     | <span class='neutral'>interface ISwapRouter {</span>
  7 |     | <span class='neutral'>    struct ExactInputSingleParams {</span>
  8 |     | <span class='neutral'>        address tokenIn;</span>
  9 |     | <span class='neutral'>        address tokenOut;</span>
 10 |     | <span class='neutral'>        uint24 fee;</span>
 11 |     | <span class='neutral'>        address recipient;</span>
 12 |     | <span class='neutral'>        uint256 deadline;</span>
 13 |     | <span class='neutral'>        uint256 amountIn;</span>
 14 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 15 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another token</span>
 19 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata</span>
 20 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 21 |     | <span class='neutral'>    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    struct ExactOutputSingleParams {</span>
 24 |     | <span class='neutral'>        address tokenIn;</span>
 25 |     | <span class='neutral'>        address tokenOut;</span>
 26 |     | <span class='neutral'>        uint24 fee;</span>
 27 |     | <span class='neutral'>        address recipient;</span>
 28 |     | <span class='neutral'>        uint256 deadline;</span>
 29 |     | <span class='neutral'>        uint256 amountOut;</span>
 30 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 31 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another token</span>
 35 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata</span>
 36 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 37 |     | <span class='neutral'>    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/lib/Constants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='unexecuted'></span>
  4 |     | <span class='neutral'>library Constants {</span>
  5 |     | <span class='unexecuted'>    uint256 public constant ONE = 1e18;</span>
  6 |     | <span class='neutral'>    // decimals difference between WETH and USDC (18 - 6)</span>
  7 |     | <span class='unexecuted'>    uint256 public constant WETH_USDC_DECIMALS_DIFF = 1e12;</span>
  8 |     | <span class='neutral'>    // value for the variable interest rate mode on Aave</span>
  9 |     | <span class='unexecuted'>    uint256 public constant AAVE_VAR_INTEREST_RATE_MODE = 2;</span>
 10 |     | <span class='neutral'>    // enable efficeincy mode on Aave (used to allow greater LTV when asset and debt tokens are correlated in price)</span>
 11 |     | <span class='unexecuted'>    uint8 public constant AAVE_EMODE_ID = 1;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 14 |     | <span class='neutral'>                          MAINNET ADDRESSES</span>
 15 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // address of the USDC token contract</span>
 18 |     | <span class='unexecuted'>    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;</span>
 19 |     | <span class='neutral'>    // address of the WETH token contract</span>
 20 |     | <span class='unexecuted'>    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;</span>
 21 |     | <span class='neutral'>    // address of the wrapped stETH token contract</span>
 22 |     | <span class='unexecuted'>    address public constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;</span>
 23 |     | <span class='neutral'>    // address of the Lido stETH token contract</span>
 24 |     | <span class='unexecuted'>    address public constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // address of the Curve pool for ETH-stETH</span>
 27 |     | <span class='unexecuted'>    address public constant CURVE_ETH_STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // address of the Uniswap v3 swap router contract</span>
 30 |     | <span class='unexecuted'>    address public constant UNISWAP_V3_SWAP_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    // address of the Aave pool contract</span>
 33 |     | <span class='unexecuted'>    address public constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;</span>
 34 |     | <span class='neutral'>    // address of the Aave pool data provider contract</span>
 35 |     | <span class='unexecuted'>    address public constant AAVE_POOL_DATA_PROVIDER = 0x7B4EB56E7CD4b454BA8ff71E4518426369a138a3;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    // address of the Aave &quot;aEthUSDC&quot; token (supply token)</span>
 38 |     | <span class='unexecuted'>    address public constant AAVE_AUSDC_TOKEN = 0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c;</span>
 39 |     | <span class='neutral'>    // address of the Aave &quot;aEthwstETH&quot; token (supply token)</span>
 40 |     | <span class='unexecuted'>    address public constant AAVE_AWSTETH_TOKEN = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;</span>
 41 |     | <span class='neutral'>    // address of the Aave &quot;variableDebtEthWETH&quot; token (variable debt token)</span>
 42 |     | <span class='unexecuted'>    address public constant AAVAAVE_VAR_DEBT_WETH_TOKEN = 0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE;</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    // adress of the Chainlink aggregator for the USDC/eth price feed</span>
 45 |     | <span class='unexecuted'>    address public constant CHAINLINK_USDC_ETH_PRICE_FEED = 0x986b5E1e1755e3C2440e960477f25201B0a8bbD4;</span>
 46 |     | <span class='neutral'>    // Chainlink pricefeed (stETH -&gt; ETH)</span>
 47 |     | <span class='unexecuted'>    address public constant CHAINLINK_STETH_ETH_PRICE_FEED = 0x86392dC19c0b719886221c78AB11eb8Cf5c52812;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    // address of the Balancer vault contract</span>
 50 |     | <span class='unexecuted'>    address public constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    // address of the 0x swap router contract</span>
 53 |     | <span class='unexecuted'>    address public constant ZEROX_ROUTER = 0xDef1C0ded9bec7F1a1670819833240f027b25EfF;</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/sc4626.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.10;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ERC4626} from &quot;solmate/mixins/ERC4626.sol&quot;;</span>
  6 |     | <span class='neutral'>import {AccessControl} from &quot;openzeppelin-contracts/access/AccessControl.sol&quot;;</span>
  7 |     | <span class='neutral'>import {</span>
  8 |     | <span class='neutral'>    TreasuryCannotBeZero,</span>
  9 |     | <span class='neutral'>    FeesTooHigh,</span>
 10 |     | <span class='neutral'>    CallerNotAdmin,</span>
 11 |     | <span class='neutral'>    CallerNotKeeper,</span>
 12 |     | <span class='neutral'>    ZeroAddress,</span>
 13 |     | <span class='neutral'>    InvalidFlashLoanCaller</span>
 14 |     | <span class='neutral'>} from &quot;./errors/scErrors.sol&quot;;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>abstract contract sc4626 is ERC4626, AccessControl {</span>
 17 |     | <span class='unexecuted'>    constructor(address _admin, address _keeper, ERC20 _asset, string memory _name, string memory _symbol)</span>
 18 |     | <span class='unexecuted'>        ERC4626(_asset, _name, _symbol)</span>
 19 |     | <span class='neutral'>    {</span>
 20 |     | <span class='unexecuted'>        if (_admin == address(0)) revert ZeroAddress();</span>
 21 |     | <span class='unexecuted'>        if (_keeper == address(0)) revert ZeroAddress();</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        _grantRole(DEFAULT_ADMIN_ROLE, _admin);</span>
 24 |     | <span class='unexecuted'>        _grantRole(KEEPER_ROLE, _keeper);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        treasury = _admin;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    bool flashLoanInitiated;</span>
 30 |     | <span class='unexecuted'>    uint256 public performanceFee = 0.1e18;</span>
 31 |     | <span class='unexecuted'>    uint256 public floatPercentage = 0.01e18;</span>
 32 |     | <span class='unexecuted'>    address public treasury;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// Role allowed to harvest/reinvest</span>
 35 |     | <span class='unexecuted'>    bytes32 public constant KEEPER_ROLE = keccak256(&quot;KEEPER_ROLE&quot;);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    event PerformanceFeeUpdated(address indexed user, uint256 newPerformanceFee);</span>
 38 |     | <span class='neutral'>    event FloatPercentageUpdated(address indexed user, uint256 newFloatPercentage);</span>
 39 |     | <span class='neutral'>    event TreasuryUpdated(address indexed user, address newTreasury);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    modifier onlyAdmin() {</span>
 42 |     | <span class='unexecuted'>        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) revert CallerNotAdmin();</span>
 43 |     | <span class='neutral'>        _;</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    modifier onlyKeeper() {</span>
 47 |     | <span class='unexecuted'>        if (!hasRole(KEEPER_ROLE, msg.sender)) revert CallerNotKeeper();</span>
 48 |     | <span class='unexecuted'>        _;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function setPerformanceFee(uint256 newPerformanceFee) external onlyAdmin {</span>
 52 |     | <span class='unexecuted'>        if (newPerformanceFee &gt; 1e18) revert FeesTooHigh();</span>
 53 |     | <span class='unexecuted'>        performanceFee = newPerformanceFee;</span>
 54 |     | <span class='unexecuted'>        emit PerformanceFeeUpdated(msg.sender, newPerformanceFee);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>    function setFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {</span>
 58 |     | <span class='unexecuted'>        require(newFloatPercentage &lt;= 1e18, &quot;float percentage too high&quot;);</span>
 59 |     | <span class='unexecuted'>        floatPercentage = newFloatPercentage;</span>
 60 |     | <span class='unexecuted'>        emit FloatPercentageUpdated(msg.sender, newFloatPercentage);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function setTreasury(address newTreasury) external onlyAdmin {</span>
 64 |     | <span class='unexecuted'>        if (newTreasury == address(0)) revert TreasuryCannotBeZero();</span>
 65 |     | <span class='unexecuted'>        treasury = newTreasury;</span>
 66 |     | <span class='unexecuted'>        emit TreasuryUpdated(msg.sender, newTreasury);</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='unexecuted'>    function _initiateFlashLoan() internal {</span>
 70 |     | <span class='unexecuted'>        flashLoanInitiated = true;</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>    function _finalizeFlashLoan() internal {</span>
 74 |     | <span class='unexecuted'>        flashLoanInitiated = false;</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='unexecuted'>    function _isFlashLoanInitiated() internal view {</span>
 78 |     | <span class='unexecuted'>        if (!flashLoanInitiated) revert InvalidFlashLoanCaller();</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'>}</span>
 81 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/steth/scUSDC.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {</span>
   5 |     | <span class='neutral'>    InvalidTargetLtv,</span>
   6 |     | <span class='neutral'>    InvalidSlippageTolerance,</span>
   7 |     | <span class='neutral'>    InvalidFlashLoanCaller,</span>
   8 |     | <span class='neutral'>    VaultNotUnderwater,</span>
   9 |     | <span class='neutral'>    NoProfitsToSell,</span>
  10 |     | <span class='neutral'>    EndUsdcBalanceTooLow</span>
  11 |     | <span class='neutral'>} from &quot;../errors/scErrors.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  14 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
  15 |     | <span class='neutral'>import {ERC4626} from &quot;solmate/mixins/ERC4626.sol&quot;;</span>
  16 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solmate/utils/SafeTransferLib.sol&quot;;</span>
  17 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  19 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  20 |     | <span class='neutral'>import {IPoolDataProvider} from &quot;aave-v3/interfaces/IPoolDataProvider.sol&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>import {Constants as C} from &quot;../lib/Constants.sol&quot;;</span>
  23 |     | <span class='neutral'>import {IVault} from &quot;../interfaces/balancer/IVault.sol&quot;;</span>
  24 |     | <span class='neutral'>import {ISwapRouter} from &quot;../interfaces/uniswap/ISwapRouter.sol&quot;;</span>
  25 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  26 |     | <span class='neutral'>import {IFlashLoanRecipient} from &quot;../interfaces/balancer/IFlashLoanRecipient.sol&quot;;</span>
  27 |     | <span class='neutral'>import {sc4626} from &quot;../sc4626.sol&quot;;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>/**</span>
  30 |     | <span class='neutral'> * @title Sandclock USDC Vault</span>
  31 |     | <span class='neutral'> * @notice A vault that allows users to earn interest on their USDC deposits from leveraged WETH staking.</span>
  32 |     | <span class='neutral'> * @dev This vault uses Sandclock&#39;s leveraged WETH staking vault - scWETH.</span>
  33 |     | <span class='unexecuted'> */</span>
  34 |     | <span class='neutral'>contract scUSDC is sc4626, IFlashLoanRecipient {</span>
  35 |     | <span class='neutral'>    using SafeTransferLib for ERC20;</span>
  36 |     | <span class='neutral'>    using SafeTransferLib for WETH;</span>
  37 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    event NewTargetLtvApplied(address indexed admin, uint256 newTargetLtv);</span>
  40 |     | <span class='neutral'>    event SlippageToleranceUpdated(address indexed admin, uint256 newSlippageTolerance);</span>
  41 |     | <span class='neutral'>    event EmergencyExitExecuted(</span>
  42 |     | <span class='neutral'>        address indexed admin, uint256 wethWithdrawn, uint256 debtRepaid, uint256 collateralReleased</span>
  43 |     | <span class='neutral'>    );</span>
  44 |     | <span class='neutral'>    event Rebalanced(</span>
  45 |     | <span class='neutral'>        uint256 targetLtv,</span>
  46 |     | <span class='neutral'>        uint256 initialDebt,</span>
  47 |     | <span class='neutral'>        uint256 finalDebt,</span>
  48 |     | <span class='neutral'>        uint256 initialCollateral,</span>
  49 |     | <span class='neutral'>        uint256 finalCollateral,</span>
  50 |     | <span class='neutral'>        uint256 initialUsdcBalance,</span>
  51 |     | <span class='neutral'>        uint256 finalUsdcBalance</span>
  52 |     | <span class='neutral'>    );</span>
  53 |     | <span class='neutral'>    event ProfitSold(uint256 wethSold, uint256 usdcReceived);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    WETH public immutable weth;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    // delta threshold for rebalancing in percentage</span>
  58 |     | <span class='unexecuted'>    uint256 constant DEBT_DELTA_THRESHOLD = 0.01e18;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // main aave contract for interaction with the protocol</span>
  61 |     | <span class='unexecuted'>    IPool public immutable aavePool;</span>
  62 |     | <span class='neutral'>    // aave protocol data provider</span>
  63 |     | <span class='unexecuted'>    IPoolDataProvider public immutable aavePoolDataProvider;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // aave &quot;aEthUSDC&quot; token</span>
  66 |     | <span class='unexecuted'>    IAToken public immutable aUsdc;</span>
  67 |     | <span class='neutral'>    // aave &quot;variableDebtEthWETH&quot; token</span>
  68 |     | <span class='unexecuted'>    ERC20 public immutable dWeth;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    // Uniswap V3 router</span>
  71 |     | <span class='unexecuted'>    ISwapRouter public immutable swapRouter;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    // Chainlink pricefeed (USDC -&gt; WETH)</span>
  74 |     | <span class='unexecuted'>    AggregatorV3Interface public immutable usdcToEthPriceFeed;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    // Balancer vault for flashloans</span>
  77 |     | <span class='unexecuted'>    IVault public immutable balancerVault;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    // USDC / WETH target LTV</span>
  80 |     | <span class='unexecuted'>    uint256 public targetLtv = 0.65e18;</span>
  81 |     | <span class='neutral'>    // max slippage for swapping WETH -&gt; USDC</span>
  82 |     | <span class='unexecuted'>    uint256 public slippageTolerance = 0.99e18; // 1% default</span>
  83 |     | <span class='unexecuted'>    uint256 public constant rebalanceMinimum = 10e6; // 10 USDC</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    // leveraged (w)eth vault</span>
  86 |     | <span class='unexecuted'>    ERC4626 public immutable scWETH;</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    struct ConstructorParams {</span>
  89 |     | <span class='neutral'>        address admin;</span>
  90 |     | <span class='neutral'>        address keeper;</span>
  91 |     | <span class='neutral'>        ERC4626 scWETH;</span>
  92 |     | <span class='neutral'>        ERC20 usdc;</span>
  93 |     | <span class='neutral'>        WETH weth;</span>
  94 |     | <span class='neutral'>        IPool aavePool;</span>
  95 |     | <span class='neutral'>        IPoolDataProvider aavePoolDataProvider;</span>
  96 |     | <span class='neutral'>        IAToken aaveAUsdc;</span>
  97 |     | <span class='neutral'>        ERC20 aaveVarDWeth;</span>
  98 |     | <span class='neutral'>        ISwapRouter uniswapSwapRouter;</span>
  99 |     | <span class='neutral'>        AggregatorV3Interface chainlinkUsdcToEthPriceFeed;</span>
 100 |     | <span class='neutral'>        IVault balancerVault;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    constructor(ConstructorParams memory _params)</span>
 104 |     | <span class='unexecuted'>        sc4626(_params.admin, _params.keeper, _params.usdc, &quot;Sandclock USDC Vault&quot;, &quot;scUSDC&quot;)</span>
 105 |     | <span class='neutral'>    {</span>
 106 |     | <span class='unexecuted'>        scWETH = _params.scWETH;</span>
 107 |     | <span class='unexecuted'>        weth = _params.weth;</span>
 108 |     | <span class='unexecuted'>        aavePool = _params.aavePool;</span>
 109 |     | <span class='unexecuted'>        aavePoolDataProvider = _params.aavePoolDataProvider;</span>
 110 |     | <span class='unexecuted'>        aUsdc = _params.aaveAUsdc;</span>
 111 |     | <span class='unexecuted'>        dWeth = _params.aaveVarDWeth;</span>
 112 |     | <span class='unexecuted'>        swapRouter = _params.uniswapSwapRouter;</span>
 113 |     | <span class='unexecuted'>        usdcToEthPriceFeed = _params.chainlinkUsdcToEthPriceFeed;</span>
 114 |     | <span class='unexecuted'>        balancerVault = _params.balancerVault;</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        asset.safeApprove(address(aavePool), type(uint256).max);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        weth.safeApprove(address(aavePool), type(uint256).max);</span>
 119 |     | <span class='unexecuted'>        weth.safeApprove(address(swapRouter), type(uint256).max);</span>
 120 |     | <span class='unexecuted'>        weth.safeApprove(address(_params.scWETH), type(uint256).max);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 124 |     | <span class='neutral'>                            PUBLIC API</span>
 125 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /**</span>
 128 |     | <span class='neutral'>     * @notice Set the slippage tolerance for swapping WETH to USDC on Uniswap.</span>
 129 |     | <span class='neutral'>     * @param _newSlippageTolerance The new slippage tolerance value.</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='unexecuted'>    function setSlippageTolerance(uint256 _newSlippageTolerance) external onlyAdmin {</span>
 132 |     | <span class='unexecuted'>        if (_newSlippageTolerance &gt; C.ONE) revert InvalidSlippageTolerance();</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        slippageTolerance = _newSlippageTolerance;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        emit SlippageToleranceUpdated(msg.sender, _newSlippageTolerance);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @notice Apply a new target LTV and trigger a rebalance.</span>
 141 |     | <span class='neutral'>     * @param _newTargetLtv The new target LTV value.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='unexecuted'>    function applyNewTargetLtv(uint256 _newTargetLtv) external onlyKeeper {</span>
 144 |     | <span class='unexecuted'>        if (_newTargetLtv &gt; getMaxLtv()) revert InvalidTargetLtv();</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        targetLtv = _newTargetLtv;</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        rebalance();</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>        emit NewTargetLtvApplied(msg.sender, _newTargetLtv);</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /**</span>
 154 |     | <span class='neutral'>     * @notice Rebalance the vault&#39;s positions.</span>
 155 |     | <span class='neutral'>     * @dev Called to increase or decrease the WETH debt to match the target LTV.</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='unexecuted'>    function rebalance() public onlyKeeper {</span>
 158 |     | <span class='unexecuted'>        uint256 initialBalance = getUsdcBalance();</span>
 159 |     | <span class='unexecuted'>        uint256 currentBalance = initialBalance;</span>
 160 |     | <span class='unexecuted'>        uint256 collateral = getCollateral();</span>
 161 |     | <span class='unexecuted'>        uint256 invested = getInvested();</span>
 162 |     | <span class='unexecuted'>        uint256 initialDebt = getDebt();</span>
 163 |     | <span class='unexecuted'>        uint256 floatRequired =</span>
 164 |     | <span class='unexecuted'>            _calculateTotalAssets(currentBalance, collateral, invested, initialDebt).mulWadDown(floatPercentage);</span>
 165 |     | <span class='unexecuted'>        uint256 excessUsdc = currentBalance &gt; floatRequired ? currentBalance - floatRequired : 0;</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>        // deposit excess usdc as collateral</span>
 168 |     | <span class='unexecuted'>        if (excessUsdc &gt;= rebalanceMinimum) {</span>
 169 |     | <span class='unexecuted'>            aavePool.supply(address(asset), excessUsdc, address(this), 0);</span>
 170 |     | <span class='unexecuted'>            collateral += excessUsdc;</span>
 171 |     | <span class='unexecuted'>            currentBalance -= excessUsdc;</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        // rebalance to target ltv</span>
 175 |     | <span class='unexecuted'>        uint256 targetDebt = getWethFromUsdc(collateral.mulWadDown(targetLtv));</span>
 176 |     | <span class='unexecuted'>        uint256 delta = initialDebt &gt; targetDebt ? initialDebt - targetDebt : targetDebt - initialDebt;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        if (delta &lt;= targetDebt.mulWadDown(DEBT_DELTA_THRESHOLD)) return;</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>        if (initialDebt &gt; targetDebt) {</span>
 181 |     | <span class='unexecuted'>            uint256 withdrawn = _disinvest(delta);</span>
 182 |     | <span class='unexecuted'>            aavePool.repay(address(weth), withdrawn, C.AAVE_VAR_INTEREST_RATE_MODE, address(this));</span>
 183 |     | <span class='neutral'>        } else {</span>
 184 |     | <span class='unexecuted'>            aavePool.borrow(address(weth), delta, C.AAVE_VAR_INTEREST_RATE_MODE, 0, address(this));</span>
 185 |     | <span class='unexecuted'>            scWETH.deposit(delta, address(this));</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>        emit Rebalanced(</span>
 189 |     | <span class='unexecuted'>            targetLtv, initialDebt, getDebt(), collateral - excessUsdc, collateral, initialBalance, currentBalance</span>
 190 |     | <span class='neutral'>        );</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    /**</span>
 194 |     | <span class='neutral'>     * @notice Sells WETH profits to USDC.</span>
 195 |     | <span class='neutral'>     * @param _usdcAmountOutMin The minimum amount of USDC to receive.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function sellProfit(uint256 _usdcAmountOutMin) external onlyKeeper {</span>
 198 |     | <span class='unexecuted'>        uint256 profits = _calculateWethProfit(getInvested(), getDebt());</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        if (profits == 0) revert NoProfitsToSell();</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        uint256 withdrawn = _disinvest(profits);</span>
 203 |     | <span class='unexecuted'>        uint256 usdcReceived = _swapWethForUsdc(withdrawn, _usdcAmountOutMin);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        emit ProfitSold(withdrawn, usdcReceived);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @notice Emergency exit to release collateral if the vault is underwater.</span>
 210 |     | <span class='neutral'>     * @param _endUsdcBalanceMin The minimum USDC balance to end with after all positions are closed.</span>
 211 |     | <span class='neutral'>     */</span>
 212 |     | <span class='unexecuted'>    function exitAllPositions(uint256 _endUsdcBalanceMin) external onlyAdmin {</span>
 213 |     | <span class='unexecuted'>        uint256 debt = getDebt();</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>        if (getInvested() &gt;= debt) {</span>
 216 |     | <span class='unexecuted'>            revert VaultNotUnderwater();</span>
 217 |     | <span class='neutral'>        }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>        uint256 wethBalance = scWETH.redeem(scWETH.balanceOf(address(this)), address(this), address(this));</span>
 220 |     | <span class='unexecuted'>        uint256 collateral = getCollateral();</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>        address[] memory tokens = new address[](1);</span>
 223 |     | <span class='unexecuted'>        tokens[0] = address(weth);</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1);</span>
 226 |     | <span class='unexecuted'>        amounts[0] = debt - wethBalance;</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        _initiateFlashLoan();</span>
 229 |     | <span class='unexecuted'>        balancerVault.flashLoan(address(this), tokens, amounts, abi.encode(collateral, debt));</span>
 230 |     | <span class='unexecuted'>        _finalizeFlashLoan();</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>        if (getUsdcBalance() &lt; _endUsdcBalanceMin) revert EndUsdcBalanceTooLow();</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>        emit EmergencyExitExecuted(msg.sender, wethBalance, debt, collateral);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @notice Handles the repayment and collateral release logic for flash loans.</span>
 239 |     | <span class='neutral'>     * @param userData Data passed to the callback function.</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='unexecuted'>    function receiveFlashLoan(address[] memory, uint256[] memory amounts, uint256[] memory, bytes memory userData)</span>
 242 |     | <span class='neutral'>        external</span>
 243 |     | <span class='unexecuted'>    {</span>
 244 |     | <span class='unexecuted'>        if (msg.sender != address(balancerVault)) {</span>
 245 |     | <span class='unexecuted'>            revert InvalidFlashLoanCaller();</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='unexecuted'>        _isFlashLoanInitiated();</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>        uint256 flashLoanAmount = amounts[0];</span>
 250 |     | <span class='unexecuted'>        (uint256 collateral, uint256 debt) = abi.decode(userData, (uint256, uint256));</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>        aavePool.repay(address(weth), debt, C.AAVE_VAR_INTEREST_RATE_MODE, address(this));</span>
 253 |     | <span class='unexecuted'>        aavePool.withdraw(address(asset), collateral, address(this));</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>        asset.approve(address(swapRouter), type(uint256).max);</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({</span>
 258 |     | <span class='unexecuted'>            tokenIn: address(asset),</span>
 259 |     | <span class='unexecuted'>            tokenOut: address(weth),</span>
 260 |     | <span class='unexecuted'>            fee: 500,</span>
 261 |     | <span class='unexecuted'>            recipient: address(this),</span>
 262 |     | <span class='unexecuted'>            deadline: block.timestamp,</span>
 263 |     | <span class='neutral'>            amountOut: flashLoanAmount,</span>
 264 |     | <span class='unexecuted'>            amountInMaximum: type(uint256).max, // ignore slippage</span>
 265 |     | <span class='neutral'>            sqrtPriceLimitX96: 0</span>
 266 |     | <span class='neutral'>        });</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>        swapRouter.exactOutputSingle(params);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        asset.approve(address(swapRouter), 0);</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>        weth.safeTransfer(address(balancerVault), flashLoanAmount);</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>    function totalAssets() public view override returns (uint256) {</span>
 276 |     | <span class='unexecuted'>        return _calculateTotalAssets(getUsdcBalance(), getCollateral(), getInvested(), getDebt());</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='unexecuted'>    function getUsdcFromWeth(uint256 _wethAmount) public view returns (uint256) {</span>
 280 |     | <span class='unexecuted'>        (, int256 usdcPriceInWeth,,,) = usdcToEthPriceFeed.latestRoundData();</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        return _wethAmount.divWadDown(uint256(usdcPriceInWeth) * C.WETH_USDC_DECIMALS_DIFF);</span>
 283 |     | <span class='neutral'>    }</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>    function getWethFromUsdc(uint256 _usdcAmount) public view returns (uint256) {</span>
 286 |     | <span class='unexecuted'>        (, int256 usdcPriceInWeth,,,) = usdcToEthPriceFeed.latestRoundData();</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>        return (_usdcAmount * C.WETH_USDC_DECIMALS_DIFF).mulWadDown(uint256(usdcPriceInWeth));</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    /**</span>
 292 |     | <span class='neutral'>     * @notice Returns the USDC balance of the vault.</span>
 293 |     | <span class='neutral'>     * @return The USDC balance.</span>
 294 |     | <span class='neutral'>     */</span>
 295 |     | <span class='unexecuted'>    function getUsdcBalance() public view returns (uint256) {</span>
 296 |     | <span class='unexecuted'>        return asset.balanceOf(address(this));</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    /**</span>
 300 |     | <span class='neutral'>     * @notice Returns the total USDC supplied as collateral to Aave.</span>
 301 |     | <span class='neutral'>     * @return The USDC collateral amount.</span>
 302 |     | <span class='neutral'>     */</span>
 303 |     | <span class='unexecuted'>    function getCollateral() public view returns (uint256) {</span>
 304 |     | <span class='unexecuted'>        return aUsdc.balanceOf(address(this));</span>
 305 |     | <span class='neutral'>    }</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>    /**</span>
 308 |     | <span class='neutral'>     * @notice Returns the total WETH borrowed on Aave.</span>
 309 |     | <span class='neutral'>     * @return The borrowed WETH amount.</span>
 310 |     | <span class='neutral'>     */</span>
 311 |     | <span class='unexecuted'>    function getDebt() public view returns (uint256) {</span>
 312 |     | <span class='unexecuted'>        return dWeth.balanceOf(address(this));</span>
 313 |     | <span class='neutral'>    }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>    /**</span>
 316 |     | <span class='neutral'>     * @notice Returns the amount of WETH invested in the leveraged WETH vault.</span>
 317 |     | <span class='neutral'>     * @return The WETH invested amount.</span>
 318 |     | <span class='neutral'>     */</span>
 319 |     | <span class='unexecuted'>    function getInvested() public view returns (uint256) {</span>
 320 |     | <span class='unexecuted'>        return scWETH.convertToAssets(scWETH.balanceOf(address(this)));</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='unexecuted'>    function getProfit() public view returns (uint256) {</span>
 324 |     | <span class='unexecuted'>        return _calculateWethProfit(getInvested(), getDebt());</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    /**</span>
 328 |     | <span class='neutral'>     * @notice Returns the net LTV at which the vault has borrowed until now.</span>
 329 |     | <span class='neutral'>     * @return The current LTV (1e18 = 100%).</span>
 330 |     | <span class='neutral'>     */</span>
 331 |     | <span class='unexecuted'>    function getLtv() public view returns (uint256) {</span>
 332 |     | <span class='unexecuted'>        (uint256 totalCollateralBase, uint256 totalDebtBase,,,,) = aavePool.getUserAccountData(address(this));</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>        if (totalCollateralBase == 0) return 0;</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>        return totalDebtBase.divWadUp(totalCollateralBase);</span>
 337 |     | <span class='neutral'>    }</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    /**</span>
 340 |     | <span class='neutral'>     * @notice Returns the current max LTV for USDC / WETH loans on Aave.</span>
 341 |     | <span class='neutral'>     * @return The max LTV (1e18 = 100%).</span>
 342 |     | <span class='neutral'>     */</span>
 343 |     | <span class='unexecuted'>    function getMaxLtv() public view returns (uint256) {</span>
 344 |     | <span class='unexecuted'>        (, uint256 ltv,,,,,,,,) = aavePoolDataProvider.getReserveConfigurationData(address(asset));</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>        // ltv is returned as a percentage with 2 decimals (e.g. 80% = 8000) so we need to multiply by 1e14</span>
 347 |     | <span class='unexecuted'>        return ltv * 1e14;</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 351 |     | <span class='neutral'>                            INTERNAL API</span>
 352 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='unexecuted'>    function beforeWithdraw(uint256 _assets, uint256) internal override {</span>
 355 |     | <span class='unexecuted'>        uint256 initialBalance = getUsdcBalance();</span>
 356 |     | <span class='unexecuted'>        if (initialBalance &gt;= _assets) return;</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        uint256 collateral = getCollateral();</span>
 359 |     | <span class='unexecuted'>        uint256 debt = getDebt();</span>
 360 |     | <span class='unexecuted'>        uint256 invested = getInvested();</span>
 361 |     | <span class='unexecuted'>        uint256 total = _calculateTotalAssets(initialBalance, collateral, invested, debt);</span>
 362 |     | <span class='unexecuted'>        uint256 profit = _calculateWethProfit(invested, debt);</span>
 363 |     | <span class='unexecuted'>        uint256 floatRequired = total &gt; _assets ? (total - _assets).mulWadUp(floatPercentage) : 0;</span>
 364 |     | <span class='unexecuted'>        uint256 usdcNeeded = _assets + floatRequired - initialBalance;</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='neutral'>        // first try to sell profits to cover withdrawal amount</span>
 367 |     | <span class='unexecuted'>        if (profit != 0) {</span>
 368 |     | <span class='unexecuted'>            uint256 withdrawn = _disinvest(profit);</span>
 369 |     | <span class='unexecuted'>            uint256 usdcAmountOutMin = getUsdcFromWeth(withdrawn).mulWadDown(slippageTolerance);</span>
 370 |     | <span class='unexecuted'>            uint256 usdcReceived = _swapWethForUsdc(withdrawn, usdcAmountOutMin);</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='unexecuted'>            if (initialBalance + usdcReceived &gt;= _assets) return;</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='unexecuted'>            usdcNeeded -= usdcReceived;</span>
 375 |     | <span class='neutral'>        }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>        // if we still need more usdc, we need to repay debt and withdraw collateral</span>
 378 |     | <span class='unexecuted'>        _repayDebtAndReleaseCollateral(debt, collateral, invested, usdcNeeded);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='unexecuted'>    function _repayDebtAndReleaseCollateral(uint256 _debt, uint256 _collateral, uint256 _invested, uint256 _usdcNeeded)</span>
 382 |     | <span class='neutral'>        internal</span>
 383 |     | <span class='unexecuted'>    {</span>
 384 |     | <span class='neutral'>        // handle rounding errors when withdrawing everything</span>
 385 |     | <span class='unexecuted'>        _usdcNeeded = _usdcNeeded &gt; _collateral ? _collateral : _usdcNeeded;</span>
 386 |     | <span class='neutral'>        // to keep the same ltv, weth debt to repay has to be proportional to collateral withdrawn</span>
 387 |     | <span class='unexecuted'>        uint256 wethNeeded = _usdcNeeded.mulDivUp(_debt, _collateral);</span>
 388 |     | <span class='unexecuted'>        wethNeeded = wethNeeded &gt; _invested ? _invested : wethNeeded;</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='unexecuted'>        uint256 withdrawn = _disinvest(wethNeeded);</span>
 391 |     | <span class='unexecuted'>        aavePool.repay(address(weth), withdrawn, C.AAVE_VAR_INTEREST_RATE_MODE, address(this));</span>
 392 |     | <span class='unexecuted'>        aavePool.withdraw(address(asset), _usdcNeeded, address(this));</span>
 393 |     | <span class='neutral'>    }</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='unexecuted'>    function _calculateTotalAssets(uint256 _float, uint256 _collateral, uint256 _invested, uint256 _debt)</span>
 396 |     | <span class='neutral'>        internal</span>
 397 |     | <span class='neutral'>        view</span>
 398 |     | <span class='unexecuted'>        returns (uint256 total)</span>
 399 |     | <span class='unexecuted'>    {</span>
 400 |     | <span class='unexecuted'>        total = _float + _collateral;</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='unexecuted'>        uint256 profit = _calculateWethProfit(_invested, _debt);</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='unexecuted'>        if (profit != 0) {</span>
 405 |     | <span class='neutral'>            // account for slippage when selling weth profits</span>
 406 |     | <span class='unexecuted'>            total += getUsdcFromWeth(profit).mulWadDown(slippageTolerance);</span>
 407 |     | <span class='neutral'>        } else {</span>
 408 |     | <span class='unexecuted'>            total -= getUsdcFromWeth(_debt - _invested);</span>
 409 |     | <span class='neutral'>        }</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='unexecuted'>    function _calculateWethProfit(uint256 _invested, uint256 _debt) internal pure returns (uint256) {</span>
 413 |     | <span class='unexecuted'>        return _invested &gt; _debt ? _invested - _debt : 0;</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='unexecuted'>    function _disinvest(uint256 _wethAmount) internal returns (uint256 amountWithdrawn) {</span>
 417 |     | <span class='unexecuted'>        uint256 shares = scWETH.convertToShares(_wethAmount);</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='unexecuted'>        amountWithdrawn = scWETH.redeem(shares, address(this), address(this));</span>
 420 |     | <span class='neutral'>    }</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='unexecuted'>    function _swapWethForUsdc(uint256 _wethAmount, uint256 _usdcAmountOutMin) internal returns (uint256) {</span>
 423 |     | <span class='unexecuted'>        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({</span>
 424 |     | <span class='unexecuted'>            tokenIn: address(weth),</span>
 425 |     | <span class='unexecuted'>            tokenOut: address(asset),</span>
 426 |     | <span class='unexecuted'>            fee: 500,</span>
 427 |     | <span class='unexecuted'>            recipient: address(this),</span>
 428 |     | <span class='unexecuted'>            deadline: block.timestamp,</span>
 429 |     | <span class='neutral'>            amountIn: _wethAmount,</span>
 430 |     | <span class='neutral'>            amountOutMinimum: _usdcAmountOutMin,</span>
 431 |     | <span class='neutral'>            sqrtPriceLimitX96: 0</span>
 432 |     | <span class='neutral'>        });</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='unexecuted'>        return swapRouter.exactInputSingle(params);</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'>}</span>
 437 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/src/steth/scWETH.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {</span>
   5 |     | <span class='neutral'>    InvalidTargetLtv,</span>
   6 |     | <span class='neutral'>    ZeroAddress,</span>
   7 |     | <span class='neutral'>    InvalidSlippageTolerance,</span>
   8 |     | <span class='neutral'>    PleaseUseRedeemMethod,</span>
   9 |     | <span class='neutral'>    InvalidFlashLoanCaller</span>
  10 |     | <span class='neutral'>} from &quot;../errors/scErrors.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  13 |     | <span class='neutral'>import {SafeTransferLib} from &quot;solmate/utils/SafeTransferLib.sol&quot;;</span>
  14 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  15 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
  16 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  17 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IVariableDebtToken} from &quot;aave-v3/interfaces/IVariableDebtToken.sol&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>import {Constants as C} from &quot;../lib/Constants.sol&quot;;</span>
  21 |     | <span class='neutral'>import {sc4626} from &quot;../sc4626.sol&quot;;</span>
  22 |     | <span class='neutral'>import {ICurvePool} from &quot;../interfaces/curve/ICurvePool.sol&quot;;</span>
  23 |     | <span class='neutral'>import {ILido} from &quot;../interfaces/lido/ILido.sol&quot;;</span>
  24 |     | <span class='neutral'>import {IwstETH} from &quot;../interfaces/lido/IwstETH.sol&quot;;</span>
  25 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  26 |     | <span class='neutral'>import {IVault} from &quot;../interfaces/balancer/IVault.sol&quot;;</span>
  27 |     | <span class='neutral'>import {IFlashLoanRecipient} from &quot;../interfaces/balancer/IFlashLoanRecipient.sol&quot;;</span>
  28 | *r  | <span class='executed'></span>
  29 |     | <span class='neutral'>contract scWETH is sc4626, IFlashLoanRecipient {</span>
  30 |     | <span class='neutral'>    using SafeTransferLib for ERC20;</span>
  31 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event SlippageToleranceUpdated(address indexed admin, uint256 newSlippageTolerance);</span>
  34 |     | <span class='neutral'>    event ExchangeProxyAddressUpdated(address indexed user, address newAddress);</span>
  35 |     | <span class='neutral'>    event NewTargetLtvApplied(address indexed admin, uint256 newTargetLtv);</span>
  36 |     | <span class='neutral'>    event Harvest(uint256 profitSinceLastHarvest, uint256 performanceFee);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    IPool public immutable aavePool;</span>
  39 |     | <span class='neutral'>    // aToken is a rebasing token and pegged 1:1 to the underlying</span>
  40 |     | <span class='unexecuted'>    IAToken public immutable aToken;</span>
  41 |     | <span class='unexecuted'>    ERC20 public immutable variableDebtToken;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // Curve pool for ETH-stETH</span>
  44 |     | <span class='unexecuted'>    ICurvePool public immutable curvePool;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // Lido staking contract (stETH)</span>
  47 |     | <span class='unexecuted'>    ILido public immutable stEth;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    IwstETH public immutable wstETH;</span>
  50 |     | <span class='unexecuted'>    WETH public immutable weth;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // Chainlink pricefeed (stETH -&gt; ETH)</span>
  53 |     | <span class='unexecuted'>    AggregatorV3Interface public stEThToEthPriceFeed;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    // Balancer vault for flashloans</span>
  56 | *   | <span class='executed'>    IVault public immutable balancerVault;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    // total invested during last harvest/rebalance</span>
  59 |     | <span class='unexecuted'>    uint256 public totalInvested;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    // total profit generated for this vault</span>
  62 |     | <span class='unexecuted'>    uint256 public totalProfit;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    // the target ltv ratio at which we actually borrow (&lt;= maxLtv)</span>
  65 |     | <span class='unexecuted'>    uint256 public targetLtv;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // slippage for curve swaps</span>
  68 |     | <span class='unexecuted'>    uint256 public slippageTolerance;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    struct ConstructorParams {</span>
  71 |     | <span class='neutral'>        address admin;</span>
  72 |     | <span class='neutral'>        address keeper;</span>
  73 |     | <span class='neutral'>        uint256 targetLtv;</span>
  74 |     | <span class='neutral'>        uint256 slippageTolerance;</span>
  75 |     | <span class='neutral'>        IPool aavePool;</span>
  76 |     | <span class='neutral'>        IAToken aaveAwstEth;</span>
  77 |     | <span class='neutral'>        ERC20 aaveVarDWeth;</span>
  78 |     | <span class='neutral'>        ICurvePool curveEthStEthPool;</span>
  79 |     | <span class='neutral'>        ILido stEth;</span>
  80 |     | <span class='neutral'>        IwstETH wstEth;</span>
  81 |     | <span class='neutral'>        WETH weth;</span>
  82 |     | <span class='neutral'>        AggregatorV3Interface stEthToEthPriceFeed;</span>
  83 |     | <span class='neutral'>        IVault balancerVault;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    constructor(ConstructorParams memory _params)</span>
  87 |     | <span class='unexecuted'>        sc4626(_params.admin, _params.keeper, _params.weth, &quot;Sandclock WETH Vault&quot;, &quot;scWETH&quot;)</span>
  88 |     | <span class='neutral'>    {</span>
  89 |     | <span class='unexecuted'>        if (_params.slippageTolerance &gt; C.ONE) revert InvalidSlippageTolerance();</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        aavePool = _params.aavePool;</span>
  92 |     | <span class='unexecuted'>        aToken = _params.aaveAwstEth;</span>
  93 |     | <span class='unexecuted'>        variableDebtToken = _params.aaveVarDWeth;</span>
  94 |     | <span class='unexecuted'>        curvePool = _params.curveEthStEthPool;</span>
  95 |     | <span class='unexecuted'>        stEth = _params.stEth;</span>
  96 |     | <span class='unexecuted'>        wstETH = _params.wstEth;</span>
  97 |     | <span class='unexecuted'>        weth = _params.weth;</span>
  98 |     | <span class='unexecuted'>        stEThToEthPriceFeed = _params.stEthToEthPriceFeed;</span>
  99 |     | <span class='unexecuted'>        balancerVault = _params.balancerVault;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        ERC20(address(stEth)).safeApprove(address(wstETH), type(uint256).max);</span>
 102 |     | <span class='unexecuted'>        ERC20(address(stEth)).safeApprove(address(curvePool), type(uint256).max);</span>
 103 |     | <span class='unexecuted'>        ERC20(address(wstETH)).safeApprove(address(aavePool), type(uint256).max);</span>
 104 |     | <span class='unexecuted'>        ERC20(address(weth)).safeApprove(address(aavePool), type(uint256).max);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        // set e-mode on aave-v3 for increased borrowing capacity to 90% of collateral</span>
 107 |     | <span class='unexecuted'>        aavePool.setUserEMode(C.AAVE_EMODE_ID);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (_params.targetLtv &gt;= getMaxLtv()) revert InvalidTargetLtv();</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        targetLtv = _params.targetLtv;</span>
 112 |     | <span class='unexecuted'>        slippageTolerance = _params.slippageTolerance;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice set the slippage tolerance for curve swaps</span>
 116 |     | <span class='neutral'>    /// @param newSlippageTolerance the new slippage tolerance</span>
 117 |     | <span class='neutral'>    /// @dev slippage tolerance is a number between 0 and 1e18</span>
 118 |     | <span class='unexecuted'>    function setSlippageTolerance(uint256 newSlippageTolerance) external onlyAdmin {</span>
 119 |     | <span class='unexecuted'>        if (newSlippageTolerance &gt; C.ONE) revert InvalidSlippageTolerance();</span>
 120 |     | <span class='unexecuted'>        slippageTolerance = newSlippageTolerance;</span>
 121 |     | <span class='unexecuted'>        emit SlippageToleranceUpdated(msg.sender, newSlippageTolerance);</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /// @notice set stEThToEthPriceFeed address</span>
 125 |     | <span class='neutral'>    /// @param newAddress the new address of the stEThToEthPriceFeed</span>
 126 |     | <span class='unexecuted'>    function setStEThToEthPriceFeed(address newAddress) external onlyAdmin {</span>
 127 |     | <span class='unexecuted'>        if (newAddress == address(0)) revert ZeroAddress();</span>
 128 |     | <span class='unexecuted'>        stEThToEthPriceFeed = AggregatorV3Interface(newAddress);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /////////////////// ADMIN/KEEPER METHODS //////////////////////////////////</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @notice harvest profits and rebalance the position by investing profits back into the strategy</span>
 134 |     | <span class='neutral'>    /// @dev for the first deposit, deposits everything into the strategy.</span>
 135 |     | <span class='neutral'>    /// @dev reduces the getLtv() back to the target ltv</span>
 136 |     | <span class='neutral'>    /// @dev also mints performance fee tokens to the treasury</span>
 137 |     | <span class='unexecuted'>    function harvest() external onlyKeeper {</span>
 138 |     | <span class='neutral'>        // reinvest</span>
 139 |     | <span class='unexecuted'>        _rebalancePosition();</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        // store the old total</span>
 142 |     | <span class='unexecuted'>        uint256 oldTotalInvested = totalInvested;</span>
 143 |     | <span class='unexecuted'>        uint256 assets = totalAssets();</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>        if (assets &gt; oldTotalInvested) {</span>
 146 |     | <span class='unexecuted'>            totalInvested = assets;</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>            // profit since last harvest, zero if there was a loss</span>
 149 |     | <span class='unexecuted'>            uint256 profit = assets - oldTotalInvested;</span>
 150 |     | <span class='unexecuted'>            totalProfit += profit;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>            uint256 fee = profit.mulWadDown(performanceFee);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>            // mint equivalent amount of tokens to the performance fee beneficiary ie the treasury</span>
 155 |     | <span class='unexecuted'>            _mint(treasury, convertToShares(fee));</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>            emit Harvest(profit, fee);</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /// @notice increase/decrease the target ltv used on borrows</span>
 162 |     | <span class='neutral'>    /// @param newTargetLtv the new target ltv</span>
 163 |     | <span class='neutral'>    /// @dev the new target ltv must be less than the max ltv allowed on aave</span>
 164 |     | <span class='unexecuted'>    function applyNewTargetLtv(uint256 newTargetLtv) public onlyKeeper {</span>
 165 |     | <span class='unexecuted'>        if (newTargetLtv &gt;= getMaxLtv()) revert InvalidTargetLtv();</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        targetLtv = newTargetLtv;</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='unexecuted'>        _rebalancePosition();</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>        emit NewTargetLtvApplied(msg.sender, newTargetLtv);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /// @notice withdraw funds from the strategy into the vault</span>
 175 |     | <span class='neutral'>    /// @param amount : amount of assets to withdraw into the vault</span>
 176 | *r  | <span class='executed'>    function withdrawToVault(uint256 amount) external onlyKeeper {</span>
 177 | *r  | <span class='executed'>        _withdrawToVault(amount);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    //////////////////// VIEW METHODS //////////////////////////</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /// @notice returns the total assets (WETH) held by the strategy</span>
 183 | *r  | <span class='executed'>    function totalAssets() public view override returns (uint256 assets) {</span>
 184 |     | <span class='neutral'>        // value of the supplied collateral in eth terms using chainlink oracle</span>
 185 | *r  | <span class='executed'>        assets = getCollateral();</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // subtract the debt</span>
 188 | *r  | <span class='executed'>        assets -= getDebt();</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // add float</span>
 191 | *r  | <span class='executed'>        assets += asset.balanceOf(address(this));</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /// @notice returns the total wstETH supplied as collateral (in ETH)</span>
 195 | *r  | <span class='executed'>    function getCollateral() public view returns (uint256) {</span>
 196 | *r  | <span class='executed'>        return _wstEthToEth(aToken.balanceOf(address(this)));</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    /// @notice returns the total ETH borrowed</span>
 200 | *r  | <span class='executed'>    function getDebt() public view returns (uint256) {</span>
 201 | *r  | <span class='executed'>        return variableDebtToken.balanceOf(address(this));</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /// @notice returns the net leverage that the strategy is using right now (1e18 = 100%)</span>
 205 |     | <span class='unexecuted'>    function getLeverage() public view returns (uint256) {</span>
 206 |     | <span class='unexecuted'>        uint256 coll = getCollateral();</span>
 207 |     | <span class='unexecuted'>        return coll &gt; 0 ? coll.divWadUp(coll - getDebt()) : 0;</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    /// @notice returns the net LTV at which we have borrowed till now (1e18 = 100%)</span>
 211 |     | <span class='unexecuted'>    function getLtv() public view returns (uint256) {</span>
 212 |     | <span class='unexecuted'>        (uint256 totalCollateralBase, uint256 totalDebtBase,,,,) = aavePool.getUserAccountData(address(this));</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='unexecuted'>        if (totalCollateralBase == 0) return 0;</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>        return totalDebtBase.divWadUp(totalCollateralBase);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    /// @notice returns the max loan to value(ltv) ratio for borrowing eth on Aavev3 with wsteth as collateral for the flashloan (1e18 = 100%)</span>
 220 |     | <span class='unexecuted'>    function getMaxLtv() public view returns (uint256) {</span>
 221 |     | <span class='unexecuted'>        return uint256(aavePool.getEModeCategoryData(C.AAVE_EMODE_ID).ltv) * 1e14;</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    //////////////////// EXTERNAL METHODS //////////////////////////</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /// @notice helper method to directly deposit ETH instead of weth</span>
 227 |     | <span class='unexecuted'>    function deposit(address receiver) external payable returns (uint256 shares) {</span>
 228 |     | <span class='unexecuted'>        uint256 assets = msg.value;</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>        // Check for rounding error since we round down in previewDeposit.</span>
 231 |     | <span class='unexecuted'>        require((shares = previewDeposit(assets)) != 0, &quot;ZERO_SHARES&quot;);</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>        // wrap eth</span>
 234 |     | <span class='unexecuted'>        weth.deposit{value: assets}();</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        _mint(receiver, shares);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>        emit Deposit(msg.sender, receiver, assets, shares);</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>        afterDeposit(assets, shares);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 | *r  | <span class='executed'>    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {</span>
 244 | *r  | <span class='executed'>        if (msg.sender != owner) {</span>
 245 | *r  | <span class='executed'>            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.</span>
 246 |     | <span class='neutral'></span>
 247 | *r  | <span class='executed'>            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>        // Check for rounding error since we round down in previewRedeem.</span>
 251 | *r  | <span class='executed'>        require((assets = previewRedeem(shares)) != 0, &quot;ZERO_ASSETS&quot;);</span>
 252 |     | <span class='neutral'></span>
 253 | *r  | <span class='executed'>        beforeWithdraw(assets, shares);</span>
 254 |     | <span class='neutral'></span>
 255 | *r  | <span class='executed'>        _burn(owner, shares);</span>
 256 |     | <span class='neutral'></span>
 257 | *r  | <span class='executed'>        uint256 balance = asset.balanceOf(address(this));</span>
 258 |     | <span class='neutral'></span>
 259 | *r  | <span class='executed'>        if (assets &gt; balance) {</span>
 260 |     | <span class='unexecuted'>            assets = balance;</span>
 261 |     | <span class='neutral'>        }</span>
 262 |     | <span class='neutral'></span>
 263 | *r  | <span class='executed'>        emit Withdraw(msg.sender, receiver, owner, assets, shares);</span>
 264 |     | <span class='neutral'></span>
 265 | *r  | <span class='executed'>        asset.safeTransfer(receiver, assets);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 | *r  | <span class='executed'>    function withdraw(uint256, address, address) public virtual override returns (uint256) {</span>
 269 | *r  | <span class='executed'>        revert PleaseUseRedeemMethod();</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    /// @dev called after the flashLoan on _rebalancePosition</span>
 273 |     | <span class='unexecuted'>    function receiveFlashLoan(address[] memory, uint256[] memory amounts, uint256[] memory, bytes memory userData)</span>
 274 |     | <span class='neutral'>        external</span>
 275 |     | <span class='unexecuted'>    {</span>
 276 |     | <span class='unexecuted'>        if (msg.sender != address(balancerVault)) {</span>
 277 |     | <span class='unexecuted'>            revert InvalidFlashLoanCaller();</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='unexecuted'>        _isFlashLoanInitiated();</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>        // the amount flashloaned</span>
 282 |     | <span class='unexecuted'>        uint256 flashLoanAmount = amounts[0];</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>        // decode user data</span>
 285 |     | <span class='unexecuted'>        (bool isDeposit, uint256 amount) = abi.decode(userData, (bool, uint256));</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>        amount += flashLoanAmount;</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>        // if flashloan received as part of a deposit</span>
 290 |     | <span class='unexecuted'>        if (isDeposit) {</span>
 291 |     | <span class='neutral'>            // unwrap eth</span>
 292 |     | <span class='unexecuted'>            weth.withdraw(amount);</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>            // stake to lido / eth =&gt; stETH</span>
 295 |     | <span class='unexecuted'>            stEth.submit{value: amount}(address(0x00));</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>            // wrap stETH</span>
 298 |     | <span class='unexecuted'>            wstETH.wrap(stEth.balanceOf(address(this)));</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>            //add wstETH liquidity on aave-v3</span>
 301 |     | <span class='unexecuted'>            aavePool.supply(address(wstETH), wstETH.balanceOf(address(this)), address(this), 0);</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>            //borrow enough weth from aave-v3 to payback flashloan</span>
 304 |     | <span class='unexecuted'>            aavePool.borrow(address(weth), flashLoanAmount, C.AAVE_VAR_INTEREST_RATE_MODE, 0, address(this));</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>        // if flashloan received as part of a withdrawal</span>
 307 |     | <span class='unexecuted'>        else {</span>
 308 |     | <span class='neutral'>            // repay debt + withdraw collateral</span>
 309 |     | <span class='unexecuted'>            if (flashLoanAmount &gt;= getDebt()) {</span>
 310 |     | <span class='unexecuted'>                aavePool.repay(address(weth), type(uint256).max, C.AAVE_VAR_INTEREST_RATE_MODE, address(this));</span>
 311 |     | <span class='unexecuted'>                aavePool.withdraw(address(wstETH), type(uint256).max, address(this));</span>
 312 |     | <span class='neutral'>            } else {</span>
 313 |     | <span class='unexecuted'>                aavePool.repay(address(weth), flashLoanAmount, C.AAVE_VAR_INTEREST_RATE_MODE, address(this));</span>
 314 |     | <span class='unexecuted'>                aavePool.withdraw(address(wstETH), _ethToWstEth(amount), address(this));</span>
 315 |     | <span class='neutral'>            }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>            // unwrap wstETH</span>
 318 |     | <span class='unexecuted'>            uint256 stEthAmount = wstETH.unwrap(wstETH.balanceOf(address(this)));</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>            // stETH to eth</span>
 321 |     | <span class='unexecuted'>            curvePool.exchange(1, 0, stEthAmount, _stEthToEth(stEthAmount).mulWadDown(slippageTolerance));</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>            // wrap eth</span>
 324 |     | <span class='unexecuted'>            weth.deposit{value: address(this).balance}();</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>        // payback flashloan</span>
 328 |     | <span class='unexecuted'>        asset.safeTransfer(address(balancerVault), flashLoanAmount);</span>
 329 |     | <span class='neutral'>    }</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>    // need to be able to receive eth</span>
 332 |     | <span class='neutral'>    receive() external payable {}</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    //////////////////// INTERNAL METHODS //////////////////////////</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>    function _rebalancePosition() internal {</span>
 337 |     | <span class='neutral'>        // storage loads</span>
 338 |     | <span class='unexecuted'>        uint256 amount = asset.balanceOf(address(this));</span>
 339 |     | <span class='unexecuted'>        uint256 ltv = targetLtv;</span>
 340 |     | <span class='unexecuted'>        uint256 debt = getDebt();</span>
 341 |     | <span class='unexecuted'>        uint256 collateral = getCollateral();</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>        uint256 target = ltv.mulWadDown(amount + collateral);</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        // whether we should deposit or withdraw</span>
 346 |     | <span class='unexecuted'>        bool isDeposit = target &gt; debt;</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>        // calculate the flashloan amount needed</span>
 349 |     | <span class='unexecuted'>        uint256 flashLoanAmount = (isDeposit ? target - debt : debt - target).divWadDown(C.ONE - ltv);</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='unexecuted'>        address[] memory tokens = new address[](1);</span>
 352 |     | <span class='unexecuted'>        tokens[0] = address(weth);</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1);</span>
 355 |     | <span class='unexecuted'>        amounts[0] = flashLoanAmount;</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>        // needed otherwise counted as profit during harvest</span>
 358 |     | <span class='unexecuted'>        totalInvested += amount;</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>        // when deleveraging, withdraw extra to cover slippage</span>
 361 |     | <span class='unexecuted'>        if (!isDeposit) amount += flashLoanAmount.mulWadDown(C.ONE - slippageTolerance);</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>        // take flashloan</span>
 364 |     | <span class='unexecuted'>        _initiateFlashLoan();</span>
 365 |     | <span class='unexecuted'>        balancerVault.flashLoan(address(this), tokens, amounts, abi.encode(isDeposit, amount));</span>
 366 |     | <span class='unexecuted'>        _finalizeFlashLoan();</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 | r   | <span class='reverted'>    function _withdrawToVault(uint256 amount) internal {</span>
 370 | r   | <span class='reverted'>        uint256 debt = getDebt();</span>
 371 | r   | <span class='reverted'>        uint256 collateral = getCollateral();</span>
 372 |     | <span class='neutral'></span>
 373 | r   | <span class='reverted'>        uint256 flashLoanAmount = amount.mulDivDown(debt, collateral - debt);</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='unexecuted'>        address[] memory tokens = new address[](1);</span>
 376 |     | <span class='unexecuted'>        tokens[0] = address(weth);</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1);</span>
 379 |     | <span class='unexecuted'>        amounts[0] = flashLoanAmount;</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>        // needed otherwise counted as loss during harvest</span>
 382 |     | <span class='unexecuted'>        totalInvested -= amount;</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>        // take flashloan</span>
 385 |     | <span class='unexecuted'>        _initiateFlashLoan();</span>
 386 |     | <span class='unexecuted'>        balancerVault.flashLoan(address(this), tokens, amounts, abi.encode(false, amount));</span>
 387 |     | <span class='unexecuted'>        _finalizeFlashLoan();</span>
 388 |     | <span class='neutral'>    }</span>
 389 |     | <span class='neutral'></span>
 390 | *r  | <span class='executed'>    function _stEthToEth(uint256 stEthAmount) internal view returns (uint256 ethAmount) {</span>
 391 | *r  | <span class='executed'>        if (stEthAmount &gt; 0) {</span>
 392 |     | <span class='neutral'>            // stEth to eth</span>
 393 |     | <span class='unexecuted'>            (, int256 price,,,) = stEThToEthPriceFeed.latestRoundData();</span>
 394 |     | <span class='unexecuted'>            ethAmount = stEthAmount.mulWadDown(uint256(price));</span>
 395 |     | <span class='neutral'>        }</span>
 396 |     | <span class='neutral'>    }</span>
 397 |     | <span class='neutral'></span>
 398 | *r  | <span class='executed'>    function _wstEthToEth(uint256 wstEthAmount) internal view returns (uint256 ethAmount) {</span>
 399 |     | <span class='neutral'>        // wstETh to stEth using exchangeRate</span>
 400 | *r  | <span class='executed'>        uint256 stEthAmount = wstETH.getStETHByWstETH(wstEthAmount);</span>
 401 | *r  | <span class='executed'>        ethAmount = _stEthToEth(stEthAmount);</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 | *r  | <span class='executed'>    function _ethToWstEth(uint256 ethAmount) internal view returns (uint256 wstEthAmount) {</span>
 405 | *r  | <span class='executed'>        if (ethAmount &gt; 0) {</span>
 406 |     | <span class='unexecuted'>            (, int256 price,,,) = stEThToEthPriceFeed.latestRoundData();</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>            // eth to stEth</span>
 409 |     | <span class='unexecuted'>            uint256 stEthAmount = ethAmount.divWadDown(uint256(price));</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='neutral'>            // stEth to wstEth</span>
 412 |     | <span class='unexecuted'>            wstEthAmount = wstETH.getWstETHByStETH(stEthAmount);</span>
 413 |     | <span class='neutral'>        }</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 | *r  | <span class='executed'>    function beforeWithdraw(uint256 assets, uint256) internal override {</span>
 417 | *r  | <span class='executed'>        uint256 float = asset.balanceOf(address(this));</span>
 418 | *r  | <span class='executed'>        if (assets &lt;= float) {</span>
 419 | *r  | <span class='executed'>            return;</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'></span>
 422 | r   | <span class='reverted'>        uint256 missing = (assets - float);</span>
 423 |     | <span class='neutral'></span>
 424 | *r  | <span class='executed'>        _withdrawToVault(missing);</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'>}</span>
 427 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/CryticTest.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import {CryticERC4626PropertyTests} from &quot;properties/ERC4626/ERC4626PropertyTests.sol&quot;;</span>
   4 |     | <span class='neutral'>import {TestERC20Token} from &quot;properties/ERC4626/util/TestERC20Token.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Constants as C} from &quot;../src/lib/Constants.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IPoolDataProvider} from &quot;aave-v3/interfaces/IPoolDataProvider.sol&quot;;</span>
  11 |     | <span class='neutral'>import {ICurvePool} from &quot;../src/interfaces/curve/ICurvePool.sol&quot;;</span>
  12 |     | <span class='neutral'>import {ILido} from &quot;../src/interfaces/lido/ILido.sol&quot;;</span>
  13 |     | <span class='neutral'>import {ISwapRouter} from &quot;../src/interfaces/uniswap/ISwapRouter.sol&quot;;</span>
  14 |     | <span class='neutral'>import {IwstETH} from &quot;../src/interfaces/lido/IwstETH.sol&quot;;</span>
  15 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  16 |     | <span class='neutral'>import {IVault} from &quot;../src/interfaces/balancer/IVault.sol&quot;;</span>
  17 |     | <span class='neutral'>import {scWETH} from &quot;../src/steth/scWETH.sol&quot;;</span>
  18 |     | <span class='neutral'>import {scUSDC} from &quot;../src/steth/scUSDC.sol&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>interface Hevm {</span>
  21 |     | <span class='neutral'>    function prank(address) external;</span>
  22 |     | <span class='neutral'>    function roll(uint256) external;</span>
  23 |     | <span class='neutral'>    function warp(uint256) external;</span>
  24 |     | <span class='neutral'>}</span>
  25 |     | <span class='unexecuted'></span>
  26 |     | <span class='neutral'>contract CryticERC4626_scUSDC is CryticERC4626PropertyTests {</span>
  27 |     | <span class='unexecuted'>    address constant HEVM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;</span>
  28 |     | <span class='unexecuted'>    Hevm hevm = Hevm(HEVM_ADDRESS);</span>
  29 |     | <span class='unexecuted'>    address _admin = address(this);</span>
  30 |     | <span class='unexecuted'>    address _keeper = address(0x05);</span>
  31 |     | <span class='unexecuted'>    uint256 _slippageTolerance = 0.99e18;</span>
  32 |     | <span class='unexecuted'>    uint256 _targetLtv = 0.7e18;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    constructor() {</span>
  35 |     | <span class='unexecuted'>        hevm.roll(16771449); // sets the correct block number</span>
  36 |     | <span class='unexecuted'>        hevm.warp(1678131671); // sets the expected timestamp for the block number</span>
  37 |     | <span class='unexecuted'>        TestERC20Token _asset = new TestERC20Token(&quot;Test WETH&quot;, &quot;TW&quot;, 18);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory scWethParams = scWETH.ConstructorParams({</span>
  40 |     | <span class='unexecuted'>            admin: address(this),</span>
  41 |     | <span class='neutral'>            keeper: address(this),</span>
  42 |     | <span class='unexecuted'>            targetLtv: 0.7e18,</span>
  43 |     | <span class='unexecuted'>            slippageTolerance: 0.99e18,</span>
  44 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
  45 |     | <span class='neutral'>            aaveAwstEth: IAToken(C.AAVE_AWSTETH_TOKEN),</span>
  46 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
  47 |     | <span class='neutral'>            curveEthStEthPool: ICurvePool(C.CURVE_ETH_STETH_POOL),</span>
  48 |     | <span class='neutral'>            stEth: ILido(C.STETH),</span>
  49 |     | <span class='neutral'>            wstEth: IwstETH(C.WSTETH),</span>
  50 |     | <span class='neutral'>            weth: WETH(payable(C.WETH)),</span>
  51 |     | <span class='neutral'>            stEthToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_STETH_ETH_PRICE_FEED),</span>
  52 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
  53 |     | <span class='neutral'>        });</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>        scWETH _vault = new scWETH(scWethParams);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        scUSDC.ConstructorParams memory scUsdcParams = scUSDC.ConstructorParams({</span>
  58 |     | <span class='unexecuted'>            admin: address(this),</span>
  59 |     | <span class='neutral'>            keeper: address(this),</span>
  60 |     | <span class='neutral'>            scWETH: _vault,</span>
  61 |     | <span class='neutral'>            usdc: ERC20(address(_asset)),</span>
  62 |     | <span class='neutral'>            weth: WETH(payable(C.WETH)),</span>
  63 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
  64 |     | <span class='neutral'>            aavePoolDataProvider: IPoolDataProvider(C.AAVE_POOL_DATA_PROVIDER),</span>
  65 |     | <span class='neutral'>            aaveAUsdc: IAToken(C.AAVE_AUSDC_TOKEN),</span>
  66 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
  67 |     | <span class='neutral'>            uniswapSwapRouter: ISwapRouter(C.UNISWAP_V3_SWAP_ROUTER),</span>
  68 |     | <span class='neutral'>            chainlinkUsdcToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_USDC_ETH_PRICE_FEED),</span>
  69 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
  70 |     | <span class='neutral'>        });</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        scUSDC scUsdc = new scUSDC(scUsdcParams);</span>
  73 |     | <span class='unexecuted'>        initialize(address(scUsdc), address(scUsdc.asset()), false);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'>}</span>
  76 | *r  | <span class='executed'></span>
  77 |     | <span class='neutral'>contract CryticERC4626_scWETH is CryticERC4626PropertyTests {</span>
  78 |     | <span class='unexecuted'>    address constant HEVM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;</span>
  79 |     | <span class='unexecuted'>    Hevm hevm = Hevm(HEVM_ADDRESS);</span>
  80 |     | <span class='unexecuted'>    address _admin = address(this);</span>
  81 |     | <span class='unexecuted'>    address _keeper = address(0x05);</span>
  82 |     | <span class='unexecuted'>    uint256 _slippageTolerance = 0.99e18;</span>
  83 |     | <span class='unexecuted'>    uint256 _targetLtv = 0.7e18;</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    constructor() {</span>
  86 |     | <span class='unexecuted'>        hevm.roll(16771449); // sets the correct block number</span>
  87 |     | <span class='unexecuted'>        hevm.warp(1678131671); // sets the expected timestamp for the block number</span>
  88 |     | <span class='unexecuted'>        TestERC20Token _asset = new TestERC20Token(&quot;Test WETH&quot;, &quot;TW&quot;, 18);</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory scWethParams = scWETH.ConstructorParams({</span>
  91 |     | <span class='unexecuted'>            admin: address(this),</span>
  92 |     | <span class='neutral'>            keeper: address(this),</span>
  93 |     | <span class='unexecuted'>            targetLtv: 0.7e18,</span>
  94 |     | <span class='unexecuted'>            slippageTolerance: 0.99e18,</span>
  95 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
  96 |     | <span class='neutral'>            aaveAwstEth: IAToken(C.AAVE_AWSTETH_TOKEN),</span>
  97 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
  98 |     | <span class='neutral'>            curveEthStEthPool: ICurvePool(C.CURVE_ETH_STETH_POOL),</span>
  99 |     | <span class='neutral'>            stEth: ILido(C.STETH),</span>
 100 |     | <span class='neutral'>            wstEth: IwstETH(C.WSTETH),</span>
 101 |     | <span class='neutral'>            weth: WETH(payable(address(_asset))),</span>
 102 |     | <span class='neutral'>            stEthToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_STETH_ETH_PRICE_FEED),</span>
 103 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
 104 |     | <span class='neutral'>        });</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        scWETH _vault = new scWETH(scWethParams);</span>
 107 |     | <span class='unexecuted'>        initialize(address(_vault), address(_vault.asset()), false);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'>}</span>
 110 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/MockUSDC.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MockERC20} from &quot;solmate/test/utils/mocks/MockERC20.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract MockUSDC is MockERC20 {</span>
  7 |     | <span class='unexecuted'>    constructor() MockERC20(&quot;Mock USDC&quot;, &quot;mUSDC&quot;, 6) {}</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/MockWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MockERC20} from &quot;solmate/test/utils/mocks/MockERC20.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract MockWETH is MockERC20 {</span>
  7 |     | <span class='unexecuted'>    constructor() MockERC20(&quot;Mock Wrapped Ether&quot;, &quot;mWETH&quot;, 18) {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event Deposit(address indexed from, uint256 amount);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event Withdrawal(address indexed to, uint256 amount);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function deposit() public payable {</span>
 14 |     | <span class='unexecuted'>        _mint(msg.sender, msg.value);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>        emit Deposit(msg.sender, msg.value);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function withdraw(uint256 amount) public {</span>
 20 |     | <span class='unexecuted'>        require(amount &lt;= address(this).balance, &quot;MockWETH: INSUFFICIENT_ETH_BALANCE&quot;);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>        _burn(msg.sender, amount);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>        emit Withdrawal(msg.sender, amount);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        payable(msg.sender).transfer(amount);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    receive() external payable {</span>
 30 |     | <span class='unexecuted'>        deposit();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/aave-v3/MockAUsdc.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  6 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IAaveIncentivesController} from &quot;aave-v3/interfaces/IAaveIncentivesController.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>import {MockAavePool} from &quot;./MockAavePool.sol&quot;;</span>
 10 |     | <span class='neutral'>import {MockUSDC} from &quot;../MockUSDC.sol&quot;;</span>
 11 |     | <span class='unexecuted'></span>
 12 |     | <span class='neutral'>contract MockAUsdc is IAToken {</span>
 13 |     | <span class='unexecuted'>    MockAavePool public aavePool;</span>
 14 |     | <span class='unexecuted'>    MockUSDC public mockUsdc;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(MockAavePool _aavePool, MockUSDC _mockUsdc) {</span>
 17 |     | <span class='unexecuted'>        aavePool = _aavePool;</span>
 18 |     | <span class='unexecuted'>        mockUsdc = _mockUsdc;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function balanceOf(address account) external view returns (uint256) {</span>
 22 |     | <span class='unexecuted'>        (uint256 supplyAmount,) = aavePool.book(account, address(mockUsdc));</span>
 23 |     | <span class='neutral'>        return supplyAmount;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 27 |     | <span class='neutral'>                            UNUSED FUNCTIONS</span>
 28 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function mint(address caller, address onBehalfOf, uint256 amount, uint256 index) external override returns (bool) {}</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external override {}</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function mintToTreasury(uint256 amount, uint256 index) external override {}</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function transferOnLiquidation(address from, address to, uint256 value) external override {}</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function transferUnderlyingTo(address target, uint256 amount) external override {}</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function handleRepayment(address user, address onBehalfOf, uint256 amount) external override {}</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 43 |     | <span class='neutral'>        external</span>
 44 |     | <span class='neutral'>        override</span>
 45 |     | <span class='neutral'>    {}</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {}</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function RESERVE_TREASURY_ADDRESS() external view override returns (address) {}</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view override returns (bytes32) {}</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    function nonces(address owner) external view override returns (uint256) {}</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    function rescueTokens(address token, address to, uint256 amount) external override {}</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>    function allowance(address owner, address spender) external view returns (uint256) {}</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) external returns (bool) {}</span>
 60 |     | <span class='neutral'>    function getPreviousIndex(address user) external view returns (uint256) {}</span>
 61 |     | <span class='unexecuted'>    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256) {}</span>
 62 |     | <span class='neutral'>    function scaledTotalSupply() external view returns (uint256) {}</span>
 63 |     | <span class='unexecuted'>    function totalSupply() external view returns (uint256) {}</span>
 64 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool) {}</span>
 65 |     | <span class='unexecuted'>    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {}</span>
 66 |     | <span class='unexecuted'>    function scaledBalanceOf(address user) external view returns (uint256) {}</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>    function initialize(</span>
 69 |     | <span class='neutral'>        IPool pool,</span>
 70 |     | <span class='neutral'>        address treasury,</span>
 71 |     | <span class='neutral'>        address underlyingAsset,</span>
 72 |     | <span class='neutral'>        IAaveIncentivesController incentivesController,</span>
 73 |     | <span class='neutral'>        uint8 aTokenDecimals,</span>
 74 |     | <span class='neutral'>        string calldata aTokenName,</span>
 75 |     | <span class='neutral'>        string calldata aTokenSymbol,</span>
 76 |     | <span class='neutral'>        bytes calldata params</span>
 77 |     | <span class='neutral'>    ) external {}</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/aave-v3/MockAavePool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IPoolAddressesProvider} from &quot;aave-v3/interfaces/IPoolAddressesProvider.sol&quot;;</span>
   8 |     | <span class='neutral'>import {DataTypes} from &quot;aave-v3/protocol/libraries/types/DataTypes.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import {Constants as C} from &quot;../../../src/lib/Constants.sol&quot;;</span>
  11 |     | <span class='neutral'>import {MockChainlinkPriceFeed} from &quot;../chainlink/MockChainlinkPriceFeed.sol&quot;;</span>
  12 |     | <span class='neutral'>import {MockWETH} from &quot;../MockWETH.sol&quot;;</span>
  13 |     | <span class='unexecuted'></span>
  14 |     | <span class='neutral'>contract MockAavePool is IPool {</span>
  15 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct AssetData {</span>
  18 |     | <span class='neutral'>        uint256 supplyAmount;</span>
  19 |     | <span class='neutral'>        uint256 borrowAmount;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    ERC20 usdc;</span>
  23 |     | <span class='neutral'>    MockWETH weth;</span>
  24 |     | <span class='neutral'>    MockChainlinkPriceFeed usdcToEthPriceFeed;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    ERC20 wstEth;</span>
  27 |     | <span class='neutral'>    MockChainlinkPriceFeed stEthToEthPriceFeed;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; AssetData)) public book;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function supply(address asset, uint256 amount, address, uint16) external override {</span>
  32 |     | <span class='unexecuted'>        book[msg.sender][asset].supplyAmount += amount;</span>
  33 |     | <span class='unexecuted'>        ERC20(asset).transferFrom(msg.sender, address(this), amount);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function withdraw(address asset, uint256 amount, address to) external override returns (uint256) {</span>
  37 |     | <span class='unexecuted'>        uint256 balance = book[msg.sender][asset].supplyAmount;</span>
  38 |     | <span class='unexecuted'>        require(balance &gt; amount, &quot;MockAavePool: AMOUNT_TOO_HIGH&quot;);</span>
  39 |     | <span class='unexecuted'>        require(ERC20(asset).balanceOf(address(this)) &gt;= amount, &quot;MockAavePool: INSUFFICIENT_BALANCE_IN_POOL&quot;);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>        ERC20(asset).transfer(to, amount);</span>
  42 |     | <span class='unexecuted'>        book[msg.sender][asset].supplyAmount -= amount;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>        return amount;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function borrow(address asset, uint256 amount, uint256, uint16, address) external override {</span>
  48 |     | <span class='unexecuted'>        require(ERC20(asset).balanceOf(address(this)) &gt;= amount, &quot;MockAavePool: INSUFFICIENT_BALANCE_IN_POOL&quot;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        book[msg.sender][asset].borrowAmount += amount;</span>
  51 |     | <span class='unexecuted'>        ERC20(asset).transfer(msg.sender, amount);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function repay(address asset, uint256 amount, uint256, address) external override returns (uint256) {</span>
  55 |     | <span class='unexecuted'>        uint256 balance = book[msg.sender][asset].borrowAmount;</span>
  56 |     | <span class='unexecuted'>        require(balance &gt;= amount, &quot;MockAavePool: AMOUNT_TOO_HIGH&quot;);</span>
  57 |     | <span class='unexecuted'>        require(ERC20(asset).balanceOf(address(this)) &gt;= amount, &quot;MockAavePool: INSUFFICIENT_BALANCE_IN_POOL&quot;);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        book[msg.sender][asset].borrowAmount -= amount;</span>
  60 |     | <span class='unexecuted'>        ERC20(asset).transferFrom(msg.sender, address(this), amount);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        return amount;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function addInterestOnSupply(address user, address asset, uint256 amount) external {</span>
  66 |     | <span class='unexecuted'>        require(book[user][asset].supplyAmount != 0, &quot;MockAavePool: USER_SUPPLY_ZERO&quot;);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        book[user][asset].supplyAmount += amount;</span>
  69 |     | <span class='unexecuted'>        ERC20(asset).transferFrom(msg.sender, address(this), amount);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function addInterestOnDebt(address user, address asset, uint256 amount) external {</span>
  73 |     | <span class='unexecuted'>        require(book[user][asset].borrowAmount != 0, &quot;MockAavePool: USER_DEBT_ZERO&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        book[user][asset].borrowAmount += amount;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function getEModeCategoryData(uint8) external pure override returns (DataTypes.EModeCategory memory) {</span>
  79 |     | <span class='unexecuted'>        return DataTypes.EModeCategory(9000, 0, 0, address(0), &quot;&quot;);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function setUsdcWethPriceFeed(MockChainlinkPriceFeed _usdcToEthPriceFeed, ERC20 _usdc, MockWETH _weth) external {</span>
  83 |     | <span class='unexecuted'>        usdcToEthPriceFeed = _usdcToEthPriceFeed;</span>
  84 |     | <span class='unexecuted'>        usdc = _usdc;</span>
  85 |     | <span class='unexecuted'>        weth = _weth;</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function setStEthToEthPriceFeed(MockChainlinkPriceFeed _stEthToEthPriceFeed, ERC20 _wstEth, MockWETH _weth)</span>
  89 |     | <span class='neutral'>        external</span>
  90 |     | <span class='neutral'>    {</span>
  91 |     | <span class='unexecuted'>        stEthToEthPriceFeed = _stEthToEthPriceFeed;</span>
  92 |     | <span class='unexecuted'>        wstEth = _wstEth;</span>
  93 |     | <span class='unexecuted'>        weth = _weth;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function getUserAccountData(address user)</span>
  97 |     | <span class='neutral'>        external</span>
  98 |     | <span class='neutral'>        view</span>
  99 |     | <span class='neutral'>        override</span>
 100 |     | <span class='neutral'>        returns (</span>
 101 |     | <span class='unexecuted'>            uint256 totalCollateralBase,</span>
 102 |     | <span class='neutral'>            uint256 totalDebtBase,</span>
 103 |     | <span class='neutral'>            uint256 availableBorrowsBase,</span>
 104 |     | <span class='neutral'>            uint256 currentLiquidationThreshold,</span>
 105 |     | <span class='neutral'>            uint256 ltv,</span>
 106 |     | <span class='neutral'>            uint256 healthFactor</span>
 107 |     | <span class='neutral'>        )</span>
 108 |     | <span class='neutral'>    {</span>
 109 |     | <span class='neutral'>        // to ignore unused variables compiler warning</span>
 110 |     | <span class='neutral'>        availableBorrowsBase = 0;</span>
 111 |     | <span class='neutral'>        currentLiquidationThreshold = 0;</span>
 112 |     | <span class='neutral'>        ltv = 0;</span>
 113 |     | <span class='neutral'>        healthFactor = 0;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        if (book[user][address(usdc)].supplyAmount &gt; 0) {</span>
 116 |     | <span class='unexecuted'>            totalCollateralBase = book[user][address(usdc)].supplyAmount;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>            uint256 borrowedWeth = book[user][address(weth)].borrowAmount;</span>
 119 |     | <span class='unexecuted'>            (, int256 usdcPriceInWeth,,,) = usdcToEthPriceFeed.latestRoundData();</span>
 120 |     | <span class='unexecuted'>            totalDebtBase = (borrowedWeth / C.WETH_USDC_DECIMALS_DIFF).divWadDown(uint256(usdcPriceInWeth));</span>
 121 |     | <span class='unexecuted'>        } else {</span>
 122 |     | <span class='unexecuted'>            totalCollateralBase = book[user][address(wstEth)].supplyAmount;</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>            uint256 borrowedWeth = book[user][address(weth)].borrowAmount;</span>
 125 |     | <span class='unexecuted'>            (, int256 wstEthPriceInWeth,,,) = stEthToEthPriceFeed.latestRoundData();</span>
 126 |     | <span class='unexecuted'>            totalDebtBase = borrowedWeth.divWadDown(uint256(wstEthPriceInWeth));</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 131 |     | <span class='neutral'>                            UNUSED FUNCTIONS</span>
 132 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function rebalanceStableBorrowRate(address asset, address user) external override {}</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external override {}</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function liquidationCall(</span>
 139 |     | <span class='neutral'>        address collateralAsset,</span>
 140 |     | <span class='neutral'>        address debtAsset,</span>
 141 |     | <span class='neutral'>        address user,</span>
 142 |     | <span class='neutral'>        uint256 debtToCover,</span>
 143 |     | <span class='neutral'>        bool receiveAToken</span>
 144 |     | <span class='neutral'>    ) external override {}</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function flashLoan(</span>
 147 |     | <span class='neutral'>        address receiverAddress,</span>
 148 |     | <span class='neutral'>        address[] calldata assets,</span>
 149 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
 150 |     | <span class='neutral'>        uint256[] calldata modes,</span>
 151 |     | <span class='neutral'>        address onBehalfOf,</span>
 152 |     | <span class='neutral'>        bytes calldata params,</span>
 153 |     | <span class='neutral'>        uint16 referralCode</span>
 154 |     | <span class='neutral'>    ) external override {}</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>    function mintUnbacked(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external override {}</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function backUnbacked(address asset, uint256 amount, uint256 fee) external override returns (uint256) {}</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function supplyWithPermit(</span>
 161 |     | <span class='neutral'>        address asset,</span>
 162 |     | <span class='neutral'>        uint256 amount,</span>
 163 |     | <span class='neutral'>        address onBehalfOf,</span>
 164 |     | <span class='neutral'>        uint16 referralCode,</span>
 165 |     | <span class='neutral'>        uint256 deadline,</span>
 166 |     | <span class='neutral'>        uint8 permitV,</span>
 167 |     | <span class='neutral'>        bytes32 permitR,</span>
 168 |     | <span class='neutral'>        bytes32 permitS</span>
 169 |     | <span class='neutral'>    ) external override {}</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function repayWithPermit(</span>
 172 |     | <span class='neutral'>        address asset,</span>
 173 |     | <span class='neutral'>        uint256 amount,</span>
 174 |     | <span class='neutral'>        uint256 interestRateMode,</span>
 175 |     | <span class='neutral'>        address onBehalfOf,</span>
 176 |     | <span class='neutral'>        uint256 deadline,</span>
 177 |     | <span class='neutral'>        uint8 permitV,</span>
 178 |     | <span class='neutral'>        bytes32 permitR,</span>
 179 |     | <span class='neutral'>        bytes32 permitS</span>
 180 |     | <span class='unexecuted'>    ) external override returns (uint256) {}</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>    function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode)</span>
 183 |     | <span class='neutral'>        external</span>
 184 |     | <span class='neutral'>        override</span>
 185 |     | <span class='unexecuted'>        returns (uint256)</span>
 186 |     | <span class='neutral'>    {}</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>    function swapBorrowRateMode(address asset, uint256 interestRateMode) external override {}</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function flashLoanSimple(</span>
 191 |     | <span class='neutral'>        address receiverAddress,</span>
 192 |     | <span class='neutral'>        address asset,</span>
 193 |     | <span class='neutral'>        uint256 amount,</span>
 194 |     | <span class='neutral'>        bytes calldata params,</span>
 195 |     | <span class='neutral'>        uint16 referralCode</span>
 196 |     | <span class='neutral'>    ) external override {}</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function initReserve(</span>
 199 |     | <span class='neutral'>        address asset,</span>
 200 |     | <span class='neutral'>        address aTokenAddress,</span>
 201 |     | <span class='neutral'>        address stableDebtAddress,</span>
 202 |     | <span class='neutral'>        address variableDebtAddress,</span>
 203 |     | <span class='neutral'>        address interestRateStrategyAddress</span>
 204 |     | <span class='neutral'>    ) external override {}</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function dropReserve(address asset) external override {}</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external override {}</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>    function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)</span>
 211 |     | <span class='neutral'>        external</span>
 212 |     | <span class='neutral'>        override</span>
 213 |     | <span class='neutral'>    {}</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    function getConfiguration(address asset)</span>
 216 |     | <span class='neutral'>        external</span>
 217 |     | <span class='neutral'>        view</span>
 218 |     | <span class='neutral'>        override</span>
 219 |     | <span class='neutral'>        returns (DataTypes.ReserveConfigurationMap memory)</span>
 220 |     | <span class='neutral'>    {}</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>    function getUserConfiguration(address user)</span>
 223 |     | <span class='neutral'>        external</span>
 224 |     | <span class='neutral'>        view</span>
 225 |     | <span class='neutral'>        override</span>
 226 |     | <span class='neutral'>        returns (DataTypes.UserConfigurationMap memory)</span>
 227 |     | <span class='neutral'>    {}</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function getReserveNormalizedIncome(address asset) external view override returns (uint256) {}</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {}</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>    function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {}</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>    function finalizeTransfer(</span>
 236 |     | <span class='neutral'>        address asset,</span>
 237 |     | <span class='neutral'>        address from,</span>
 238 |     | <span class='neutral'>        address to,</span>
 239 |     | <span class='neutral'>        uint256 amount,</span>
 240 |     | <span class='neutral'>        uint256 balanceFromBefore,</span>
 241 |     | <span class='neutral'>        uint256 balanceToBefore</span>
 242 |     | <span class='neutral'>    ) external override {}</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>    function getReservesList() external view override returns (address[] memory) {}</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>    function getReserveAddressById(uint16 id) external view override returns (address) {}</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='unexecuted'>    function ADDRESSES_PROVIDER() external view override returns (IPoolAddressesProvider) {}</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='unexecuted'>    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external override {}</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>    function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol)</span>
 253 |     | <span class='neutral'>        external</span>
 254 |     | <span class='neutral'>        override</span>
 255 |     | <span class='neutral'>    {}</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external override {}</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>    function setUserEMode(uint8 categoryId) external override {}</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    function getUserEMode(address user) external view override returns (uint256) {}</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>    function resetIsolationModeTotalDebt(address asset) external override {}</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view override returns (uint256) {}</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>    function FLASHLOAN_PREMIUM_TOTAL() external view override returns (uint128) {}</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>    function BRIDGE_PROTOCOL_FEE() external view override returns (uint256) {}</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view override returns (uint128) {}</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    function MAX_NUMBER_RESERVES() external view override returns (uint16) {}</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>    function mintToTreasury(address[] calldata assets) external override {}</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>    function rescueTokens(address token, address to, uint256 amount) external override {}</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external override {}</span>
 280 |     | <span class='neutral'>}</span>
 281 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/aave-v3/MockAavePoolDataProvider.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IPoolDataProvider} from &quot;aave-v3/interfaces/IPoolDataProvider.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IPoolAddressesProvider} from &quot;aave-v3/interfaces/IPoolAddressesProvider.sol&quot;;</span>
   6 |     | <span class='unexecuted'></span>
   7 |     | <span class='neutral'>contract MockAavePoolDataProvider is IPoolDataProvider {</span>
   8 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public ltvMap;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>    constructor(address usdc, address weth) {</span>
  11 |     | <span class='unexecuted'>        ltvMap[usdc] = 8000;</span>
  12 |     | <span class='unexecuted'>        ltvMap[weth] = 8000;</span>
  13 |     | <span class='neutral'>    }</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function setLtv(address asset, uint256 ltv) external {</span>
  16 |     | <span class='unexecuted'>        ltvMap[asset] = ltv;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    function getReserveConfigurationData(address asset)</span>
  20 |     | <span class='neutral'>        external</span>
  21 |     | <span class='neutral'>        view</span>
  22 |     | <span class='neutral'>        override</span>
  23 |     | <span class='neutral'>        returns (</span>
  24 |     | <span class='unexecuted'>            uint256 decimals,</span>
  25 |     | <span class='unexecuted'>            uint256 ltv,</span>
  26 |     | <span class='unexecuted'>            uint256 liquidationThreshold,</span>
  27 |     | <span class='unexecuted'>            uint256 liquidationBonus,</span>
  28 |     | <span class='unexecuted'>            uint256 reserveFactor,</span>
  29 |     | <span class='unexecuted'>            bool usageAsCollateralEnabled,</span>
  30 |     | <span class='unexecuted'>            bool borrowingEnabled,</span>
  31 |     | <span class='unexecuted'>            bool stableBorrowRateEnabled,</span>
  32 |     | <span class='unexecuted'>            bool isActive,</span>
  33 |     | <span class='unexecuted'>            bool isFrozen</span>
  34 |     | <span class='neutral'>        )</span>
  35 |     | <span class='neutral'>    {}</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  38 |     | <span class='neutral'>                            UNUSED FUNCTIONS</span>
  39 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function ADDRESSES_PROVIDER() external view override returns (IPoolAddressesProvider) {}</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function getAllReservesTokens() external view override returns (TokenData[] memory) {}</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    function getAllATokens() external view override returns (TokenData[] memory) {}</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function getReserveEModeCategory(address asset) external view override returns (uint256) {}</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function getReserveCaps(address asset) external view override returns (uint256 borrowCap, uint256 supplyCap) {}</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function getPaused(address asset) external view override returns (bool isPaused) {}</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function getSiloedBorrowing(address asset) external view override returns (bool) {}</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function getLiquidationProtocolFee(address asset) external view override returns (uint256) {}</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    function getUnbackedMintCap(address asset) external view override returns (uint256) {}</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function getDebtCeiling(address asset) external view override returns (uint256) {}</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function getDebtCeilingDecimals() external pure override returns (uint256) {}</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function getReserveData(address asset)</span>
  64 |     | <span class='neutral'>        external</span>
  65 |     | <span class='neutral'>        view</span>
  66 |     | <span class='neutral'>        override</span>
  67 |     | <span class='neutral'>        returns (</span>
  68 |     | <span class='unexecuted'>            uint256 unbacked,</span>
  69 |     | <span class='unexecuted'>            uint256 accruedToTreasuryScaled,</span>
  70 |     | <span class='unexecuted'>            uint256 totalAToken,</span>
  71 |     | <span class='unexecuted'>            uint256 totalStableDebt,</span>
  72 |     | <span class='unexecuted'>            uint256 totalVariableDebt,</span>
  73 |     | <span class='unexecuted'>            uint256 liquidityRate,</span>
  74 |     | <span class='unexecuted'>            uint256 variableBorrowRate,</span>
  75 |     | <span class='unexecuted'>            uint256 stableBorrowRate,</span>
  76 |     | <span class='unexecuted'>            uint256 averageStableBorrowRate,</span>
  77 |     | <span class='unexecuted'>            uint256 liquidityIndex,</span>
  78 |     | <span class='unexecuted'>            uint256 variableBorrowIndex,</span>
  79 |     | <span class='unexecuted'>            uint40 lastUpdateTimestamp</span>
  80 |     | <span class='neutral'>        )</span>
  81 |     | <span class='neutral'>    {}</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function getATokenTotalSupply(address asset) external view override returns (uint256) {}</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function getTotalDebt(address asset) external view override returns (uint256) {}</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function getUserReserveData(address asset, address user)</span>
  88 |     | <span class='neutral'>        external</span>
  89 |     | <span class='neutral'>        view</span>
  90 |     | <span class='neutral'>        override</span>
  91 |     | <span class='neutral'>        returns (</span>
  92 |     | <span class='unexecuted'>            uint256 currentATokenBalance,</span>
  93 |     | <span class='unexecuted'>            uint256 currentStableDebt,</span>
  94 |     | <span class='unexecuted'>            uint256 currentVariableDebt,</span>
  95 |     | <span class='unexecuted'>            uint256 principalStableDebt,</span>
  96 |     | <span class='unexecuted'>            uint256 scaledVariableDebt,</span>
  97 |     | <span class='unexecuted'>            uint256 stableBorrowRate,</span>
  98 |     | <span class='unexecuted'>            uint256 liquidityRate,</span>
  99 |     | <span class='unexecuted'>            uint40 stableRateLastUpdated,</span>
 100 |     | <span class='unexecuted'>            bool usageAsCollateralEnabled</span>
 101 |     | <span class='neutral'>        )</span>
 102 |     | <span class='neutral'>    {}</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function getReserveTokensAddresses(address asset)</span>
 105 |     | <span class='neutral'>        external</span>
 106 |     | <span class='neutral'>        view</span>
 107 |     | <span class='neutral'>        override</span>
 108 |     | <span class='unexecuted'>        returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress)</span>
 109 |     | <span class='neutral'>    {}</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function getInterestRateStrategyAddress(address asset) external view override returns (address irStrategyAddress) {}</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    function getFlashLoanEnabled(address asset) external view override returns (bool) {}</span>
 114 |     | <span class='neutral'>}</span>
 115 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/aave-v3/MockAwstETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MockAavePool} from &quot;./MockAavePool.sol&quot;;</span>
  5 |     | <span class='neutral'>import {MockWstETH} from &quot;../lido/MockWstETH.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract MockAwstETH {</span>
  8 |     | <span class='unexecuted'>    MockAavePool public aavePool;</span>
  9 |     | <span class='unexecuted'>    MockWstETH public mockWstEth;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(MockAavePool _aavePool, MockWstETH _mockWstEth) {</span>
 12 |     | <span class='unexecuted'>        aavePool = _aavePool;</span>
 13 |     | <span class='unexecuted'>        mockWstEth = _mockWstEth;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function balanceOf(address account) external view returns (uint256) {</span>
 17 |     | <span class='unexecuted'>        (uint256 supplyAmount,) = aavePool.book(account, address(mockWstEth));</span>
 18 |     | <span class='neutral'>        return supplyAmount;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/aave-v3/MockVarDebtWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {MockAavePool} from &quot;./MockAavePool.sol&quot;;</span>
  5 |     | <span class='neutral'>import {MockWETH} from &quot;../MockWETH.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract MockVarDebtWETH {</span>
  8 |     | <span class='unexecuted'>    MockAavePool public aavePool;</span>
  9 |     | <span class='unexecuted'>    MockWETH public mockWeth;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(MockAavePool _aavePool, MockWETH _mockWeth) {</span>
 12 |     | <span class='unexecuted'>        aavePool = _aavePool;</span>
 13 |     | <span class='unexecuted'>        mockWeth = _mockWeth;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function balanceOf(address account) external view returns (uint256) {</span>
 17 |     | <span class='unexecuted'>        (, uint256 borrowAmount) = aavePool.book(account, address(mockWeth));</span>
 18 |     | <span class='neutral'>        return borrowAmount;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/balancer/MockBalancerVault.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IVault} from &quot;../../../src/interfaces/balancer/IVault.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IFlashLoanRecipient} from &quot;../../../src/interfaces/balancer/IFlashLoanRecipient.sol&quot;;</span>
  6 |     | <span class='neutral'>import {MockWETH} from &quot;../MockWETH.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract MockBalancerVault is IVault {</span>
  9 |     | <span class='unexecuted'>    MockWETH public weth;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(MockWETH _weth) {</span>
 12 |     | <span class='unexecuted'>        weth = _weth;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function flashLoan(address recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData)</span>
 16 |     | <span class='neutral'>        external</span>
 17 |     | <span class='neutral'>        override</span>
 18 |     | <span class='unexecuted'>    {</span>
 19 |     | <span class='unexecuted'>        require(recipient != address(0), &quot;MockBalancerVault: INVALID_RECIPIENT&quot;);</span>
 20 |     | <span class='unexecuted'>        require(tokens.length == 1, &quot;MockBalancerVault: INVALID_TOKENS_LENGTH&quot;);</span>
 21 |     | <span class='unexecuted'>        require(amounts.length == 1, &quot;MockBalancerVault: INVALID_AMOUNTS_LENGTH&quot;);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        require(tokens[0] == address(weth), &quot;MockBalancerVault: INVALID_TOKEN&quot;);</span>
 24 |     | <span class='unexecuted'>        require(amounts[0] &lt;= weth.balanceOf(address(this)), &quot;MockBalancerVault: INSUFFICIENT_WETH_BALANCE&quot;);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        uint256 initialBalance = weth.balanceOf(address(this));</span>
 27 |     | <span class='unexecuted'>        uint256[] memory feeAmounts;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        weth.transfer(recipient, amounts[0]);</span>
 30 |     | <span class='unexecuted'>        IFlashLoanRecipient(recipient).receiveFlashLoan(tokens, amounts, feeAmounts, userData);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        require(weth.balanceOf(address(this)) == initialBalance, &quot;MockBalancerVault: FLASH_LOAN_NOT_RETURNED&quot;);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/chainlink/MockChainlinkPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../../../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract MockChainlinkPriceFeed is AggregatorV3Interface {</span>
  7 |     | <span class='unexecuted'>    address public immutable baseToken;</span>
  8 |     | <span class='unexecuted'>    address public immutable quoteToken;</span>
  9 |     | <span class='unexecuted'>    int256 public answer = 1e18;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(address _baseToken, address _quoteToken, int256 _exchangeRate) {</span>
 12 |     | <span class='unexecuted'>        baseToken = _baseToken;</span>
 13 |     | <span class='unexecuted'>        quoteToken = _quoteToken;</span>
 14 |     | <span class='unexecuted'>        answer = _exchangeRate;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function setLatestAnswer(int256 _answer) external {</span>
 18 |     | <span class='unexecuted'>        answer = _answer;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function latestRoundData()</span>
 22 |     | <span class='neutral'>        external</span>
 23 |     | <span class='neutral'>        view</span>
 24 |     | <span class='neutral'>        override</span>
 25 |     | <span class='unexecuted'>        returns (uint80 roundId, int256 _answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)</span>
 26 |     | <span class='neutral'>    {</span>
 27 |     | <span class='unexecuted'>        return (0, answer, 0, 0, 0);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function decimals() external pure override returns (uint8) {</span>
 31 |     | <span class='unexecuted'>        return 18;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 35 |     | <span class='neutral'>                            UNUSED FUNCTIONS</span>
 36 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function description() external view override returns (string memory) {}</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function version() external view override returns (uint256) {}</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function getRoundData(uint80 _roundId)</span>
 43 |     | <span class='neutral'>        external</span>
 44 |     | <span class='neutral'>        view</span>
 45 |     | <span class='neutral'>        override</span>
 46 |     | <span class='unexecuted'>        returns (uint80 roundId, int256 _answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)</span>
 47 |     | <span class='neutral'>    {}</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/curve/MockCurvePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ICurvePool} from &quot;../../../src/interfaces/curve/ICurvePool.sol&quot;;</span>
  6 |     | <span class='neutral'>import {MockStETH} from &quot;../lido/MockStETH.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract MockCurvePool is ICurvePool {</span>
  9 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    MockStETH public stEth;</span>
 12 |     | <span class='unexecuted'>    uint256 slippagePct = 1e18; // no slippage</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    constructor(MockStETH _stEth) {</span>
 15 |     | <span class='unexecuted'>        stEth = _stEth;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function setSlippage(uint256 _slippagePct) external {</span>
 19 |     | <span class='unexecuted'>        require(_slippagePct &lt;= 1e18, &quot;MockCurvePool: INVALID_SLIPPAGE&quot;);</span>
 20 |     | <span class='unexecuted'>        slippagePct = _slippagePct;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function exchange(int128 i, int128, uint256 dx, uint256 min_dy) external payable override returns (uint256) {</span>
 24 |     | <span class='unexecuted'>        require(dx.mulWadUp(slippagePct) &gt;= min_dy, &quot;MockCurvePool: INSUFFICIENT_TOKEN_OUT_AMOUNT&quot;);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        if (i == 0) {</span>
 27 |     | <span class='unexecuted'>            require(stEth.balanceOf(address(this)) &gt;= dx, &quot;MockCurvePool: INSUFFICIENT_TOKEN_OUT_BALANCE&quot;);</span>
 28 |     | <span class='unexecuted'>            require(dx == msg.value, &quot;MockCurvePool: INVALID_ETH_AMOUNT&quot;);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>            stEth.transfer(msg.sender, dx.mulWadDown(slippagePct));</span>
 31 |     | <span class='neutral'>        } else {</span>
 32 |     | <span class='unexecuted'>            require(stEth.allowance(msg.sender, address(this)) &gt;= dx, &quot;MockCurvePool: INSUFFICIENT_TOKEN_IN_ALLOWANCE&quot;);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>            stEth.transferFrom(msg.sender, address(this), dx);</span>
 35 |     | <span class='unexecuted'>            payable(msg.sender).transfer(dx.mulWadDown(slippagePct));</span>
 36 |     | <span class='neutral'>        }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>        return dx;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/lido/MockStETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;openzeppelin-contracts/token/ERC20/IERC20.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract MockStETH is ERC20 {</span>
  8 |     | <span class='unexecuted'>    constructor() ERC20(&quot;Mock staked Ether&quot;, &quot;mstETH&quot;, 18) {}</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    function submit(address) external payable returns (uint256) {</span>
 11 |     | <span class='unexecuted'>        _mint(msg.sender, msg.value);</span>
 12 |     | <span class='unexecuted'>        return msg.value;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function getTotalPooledEther() external view returns (uint256) {}</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/lido/MockWstETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {MockStETH} from &quot;./MockStETH.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract MockWstETH is ERC20 {</span>
  8 |     | <span class='unexecuted'>    MockStETH public stEth;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(MockStETH _stEth) ERC20(&quot;Mock wrapped staked Ether&quot;, &quot;mwstETH&quot;, 18) {</span>
 11 |     | <span class='unexecuted'>        stEth = _stEth;</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    function wrap(uint256 _stETHAmount) external returns (uint256) {</span>
 15 |     | <span class='unexecuted'>        require(stEth.allowance(msg.sender, address(this)) &gt;= _stETHAmount, &quot;MockWstETH: INSUFFICIENT_stETH_ALLOWANCE&quot;);</span>
 16 |     | <span class='unexecuted'>        require(stEth.balanceOf(msg.sender) &gt;= _stETHAmount, &quot;MockWstETH: INSUFFICIENT_stETH_BALANCE&quot;);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>        stEth.transferFrom(msg.sender, address(this), _stETHAmount);</span>
 19 |     | <span class='unexecuted'>        _mint(msg.sender, _stETHAmount);</span>
 20 |     | <span class='unexecuted'>        return _stETHAmount;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function unwrap(uint256 _wstETHAmount) external returns (uint256) {</span>
 24 |     | <span class='unexecuted'>        require(this.balanceOf(msg.sender) &gt;= _wstETHAmount, &quot;MockWstETH: INSUFFICIENT_wstETH_BALANCE&quot;);</span>
 25 |     | <span class='unexecuted'>        require(stEth.balanceOf(address(this)) &gt;= _wstETHAmount, &quot;MockWstETH: INSUFFICIENT_stETH_BALANCE&quot;);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>        _burn(msg.sender, _wstETHAmount);</span>
 28 |     | <span class='unexecuted'>        stEth.transfer(msg.sender, _wstETHAmount);</span>
 29 |     | <span class='unexecuted'>        return _wstETHAmount;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function getWstETHByStETH(uint256 _stETHAmount) external pure returns (uint256) {</span>
 33 |     | <span class='unexecuted'>        return _stETHAmount;</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function getStETHByWstETH(uint256 _wstETHAmount) external pure returns (uint256) {</span>
 37 |     | <span class='neutral'>        return _wstETHAmount;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function stEthPerToken() external pure returns (uint256) {</span>
 41 |     | <span class='unexecuted'>        return 1e18;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function tokensPerStEth() external pure returns (uint256) {</span>
 45 |     | <span class='neutral'>        return 1e18;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/mocks/uniswap/MockSwapRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import {ISwapRouter} from &quot;../../../src/interfaces/uniswap/ISwapRouter.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract MockSwapRouter is ISwapRouter {</span>
  9 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function exactInputSingle(ExactInputSingleParams calldata params)</span>
 12 |     | <span class='neutral'>        external</span>
 13 |     | <span class='neutral'>        payable</span>
 14 |     | <span class='neutral'>        override</span>
 15 |     | <span class='unexecuted'>        returns (uint256 amountOut)</span>
 16 |     | <span class='neutral'>    {</span>
 17 |     | <span class='unexecuted'>        ERC20 tokenIn = ERC20(params.tokenIn);</span>
 18 |     | <span class='unexecuted'>        ERC20 tokenOut = ERC20(params.tokenOut);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>        require(</span>
 21 |     | <span class='unexecuted'>            tokenIn.allowance(msg.sender, address(this)) &gt;= params.amountIn,</span>
 22 |     | <span class='neutral'>            &quot;MockSwapRouter: INSUFFICIENT_TOKEN_IN_ALLOWANCE&quot;</span>
 23 |     | <span class='neutral'>        );</span>
 24 |     | <span class='unexecuted'>        require(</span>
 25 |     | <span class='unexecuted'>            tokenOut.balanceOf(address(this)) &gt;= params.amountOutMinimum,</span>
 26 |     | <span class='neutral'>            &quot;MockSwapRouter: INSUFFICIENT_TOKEN_OUT_BALANCE&quot;</span>
 27 |     | <span class='neutral'>        );</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        tokenIn.transferFrom(msg.sender, address(this), params.amountIn);</span>
 30 |     | <span class='unexecuted'>        tokenOut.transfer(msg.sender, params.amountOutMinimum);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        return params.amountOutMinimum;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function exactOutputSingle(ExactOutputSingleParams calldata /* params */ )</span>
 36 |     | <span class='neutral'>        external</span>
 37 |     | <span class='neutral'>        payable</span>
 38 |     | <span class='neutral'>        override</span>
 39 |     | <span class='unexecuted'>        returns (uint256 /* amountIn */ )</span>
 40 |     | <span class='neutral'>    {</span>
 41 |     | <span class='unexecuted'>        revert(&quot;MockSwapRouter: NOT_IMPLEMENTED&quot;);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/scUSDC.t.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import &quot;forge-std/console2.sol&quot;;</span>
    5 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
    6 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
    7 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
    8 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
    9 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
   10 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
   11 |     | <span class='neutral'>import {IVariableDebtToken} from &quot;aave-v3/interfaces/IVariableDebtToken.sol&quot;;</span>
   12 |     | <span class='neutral'>import {IPoolDataProvider} from &quot;aave-v3/interfaces/IPoolDataProvider.sol&quot;;</span>
   13 |     | <span class='neutral'></span>
   14 |     | <span class='neutral'>import {Constants as C} from &quot;../src/lib/Constants.sol&quot;;</span>
   15 |     | <span class='neutral'>import {sc4626} from &quot;../src/sc4626.sol&quot;;</span>
   16 |     | <span class='neutral'>import {scUSDC} from &quot;../src/steth/scUSDC.sol&quot;;</span>
   17 |     | <span class='neutral'>import {scWETH} from &quot;../src/steth/scWETH.sol&quot;;</span>
   18 |     | <span class='neutral'>import {ISwapRouter} from &quot;../src/interfaces/uniswap/ISwapRouter.sol&quot;;</span>
   19 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
   20 |     | <span class='neutral'>import {IVault} from &quot;../src/interfaces/balancer/IVault.sol&quot;;</span>
   21 |     | <span class='neutral'>import {ICurvePool} from &quot;../src/interfaces/curve/ICurvePool.sol&quot;;</span>
   22 |     | <span class='neutral'>import {ILido} from &quot;../src/interfaces/lido/ILido.sol&quot;;</span>
   23 |     | <span class='neutral'>import {IwstETH} from &quot;../src/interfaces/lido/IwstETH.sol&quot;;</span>
   24 |     | <span class='neutral'>import {MockSwapRouter} from &quot;./mocks/uniswap/MockSwapRouter.sol&quot;;</span>
   25 |     | <span class='neutral'>import &quot;../src/errors/scErrors.sol&quot;;</span>
   26 |     | <span class='unexecuted'></span>
   27 |     | <span class='neutral'>contract scUSDCTest is Test {</span>
   28 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    event NewTargetLtvApplied(address indexed admin, uint256 newTargetLtv);</span>
   31 |     | <span class='neutral'>    event SlippageToleranceUpdated(address indexed admin, uint256 newSlippageTolerance);</span>
   32 |     | <span class='neutral'>    event EmergencyExitExecuted(</span>
   33 |     | <span class='neutral'>        address indexed admin, uint256 wethWithdrawn, uint256 debtRepaid, uint256 collateralReleased</span>
   34 |     | <span class='neutral'>    );</span>
   35 |     | <span class='neutral'>    event Rebalanced(</span>
   36 |     | <span class='neutral'>        uint256 targetLtv,</span>
   37 |     | <span class='neutral'>        uint256 initialDebt,</span>
   38 |     | <span class='neutral'>        uint256 finalDebt,</span>
   39 |     | <span class='neutral'>        uint256 initialCollateral,</span>
   40 |     | <span class='neutral'>        uint256 finalCollateral,</span>
   41 |     | <span class='neutral'>        uint256 initialUsdcBalance,</span>
   42 |     | <span class='neutral'>        uint256 finalUsdcBalance</span>
   43 |     | <span class='neutral'>    );</span>
   44 |     | <span class='neutral'>    event ProfitSold(uint256 wethSold, uint256 usdcReceived);</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    uint256 mainnetFork;</span>
   47 |     | <span class='neutral'>    uint256 constant ethWstEthMaxLtv = 0.7735e18;</span>
   48 |     | <span class='neutral'>    uint256 constant slippageTolerance = 0.999e18;</span>
   49 |     | <span class='neutral'>    uint256 constant flashLoanLtv = 0.5e18;</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='unexecuted'>    address constant keeper = address(0x05);</span>
   52 |     | <span class='unexecuted'>    address constant alice = address(0x06);</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>    scUSDC vault;</span>
   55 |     | <span class='neutral'>    scWETH wethVault;</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    WETH weth;</span>
   58 |     | <span class='neutral'>    ERC20 usdc;</span>
   59 |     | <span class='neutral'></span>
   60 |     | <span class='unexecuted'>    function setUp() public {</span>
   61 |     | <span class='unexecuted'>        vm.createFork(vm.envString(&quot;RPC_URL_MAINNET&quot;));</span>
   62 |     | <span class='unexecuted'>        vm.selectFork(mainnetFork);</span>
   63 |     | <span class='unexecuted'>        vm.rollFork(16643381);</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='unexecuted'>        usdc = ERC20(C.USDC);</span>
   66 |     | <span class='unexecuted'>        weth = WETH(payable(C.WETH));</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory scWethParams = scWETH.ConstructorParams({</span>
   69 |     | <span class='unexecuted'>            admin: address(this),</span>
   70 |     | <span class='neutral'>            keeper: keeper,</span>
   71 |     | <span class='unexecuted'>            targetLtv: 0.7e18,</span>
   72 |     | <span class='unexecuted'>            slippageTolerance: 0.99e18,</span>
   73 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
   74 |     | <span class='neutral'>            aaveAwstEth: IAToken(C.AAVE_AWSTETH_TOKEN),</span>
   75 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
   76 |     | <span class='neutral'>            curveEthStEthPool: ICurvePool(C.CURVE_ETH_STETH_POOL),</span>
   77 |     | <span class='neutral'>            stEth: ILido(C.STETH),</span>
   78 |     | <span class='neutral'>            wstEth: IwstETH(C.WSTETH),</span>
   79 |     | <span class='neutral'>            weth: WETH(payable(C.WETH)),</span>
   80 |     | <span class='neutral'>            stEthToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_STETH_ETH_PRICE_FEED),</span>
   81 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
   82 |     | <span class='neutral'>        });</span>
   83 |     | <span class='neutral'></span>
   84 |     | <span class='unexecuted'>        wethVault = new scWETH(scWethParams);</span>
   85 |     | <span class='neutral'></span>
   86 |     | <span class='unexecuted'>        scUSDC.ConstructorParams memory params = _createDefaultUsdcVaultConstructorParams(wethVault);</span>
   87 |     | <span class='neutral'></span>
   88 |     | <span class='unexecuted'>        vault = new scUSDC(params);</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>        // set vault eth balance to zero</span>
   91 |     | <span class='unexecuted'>        vm.deal(address(vault), 0);</span>
   92 |     | <span class='neutral'>    }</span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>    /// #constructor ///</span>
   95 |     | <span class='neutral'></span>
   96 |     | <span class='unexecuted'>    function test_constructor() public {</span>
   97 |     | <span class='unexecuted'>        assertEq(address(vault.asset()), address(usdc));</span>
   98 |     | <span class='unexecuted'>        assertEq(address(vault.scWETH()), address(wethVault));</span>
   99 |     | <span class='neutral'></span>
  100 |     | <span class='neutral'>        // check approvals</span>
  101 |     | <span class='unexecuted'>        assertEq(usdc.allowance(address(vault), address(vault.aavePool())), type(uint256).max, &quot;usdc-&gt;aave appor&quot;);</span>
  102 |     | <span class='neutral'></span>
  103 |     | <span class='unexecuted'>        assertEq(weth.allowance(address(vault), address(vault.aavePool())), type(uint256).max, &quot;weth-&gt;aave allowance&quot;);</span>
  104 |     | <span class='unexecuted'>        assertEq(</span>
  105 |     | <span class='unexecuted'>            weth.allowance(address(vault), address(vault.swapRouter())), type(uint256).max, &quot;weth-&gt;swapRouter allowance&quot;</span>
  106 |     | <span class='neutral'>        );</span>
  107 |     | <span class='unexecuted'>        assertEq(weth.allowance(address(vault), address(vault.scWETH())), type(uint256).max, &quot;weth-&gt;scWETH allowance&quot;);</span>
  108 |     | <span class='neutral'>    }</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='neutral'>    /// #getMaxLtv ///</span>
  111 |     | <span class='neutral'></span>
  112 |     | <span class='unexecuted'>    function test_getMaxLtv() public {</span>
  113 |     | <span class='neutral'>        // max ltv for usdc reserve asset on aave is 0.74 at forked block</span>
  114 |     | <span class='unexecuted'>        assertEq(vault.getMaxLtv(), 0.74e18);</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    /// #deposit ///</span>
  118 |     | <span class='neutral'></span>
  119 |     | <span class='unexecuted'>    function testFuzz_deposit(uint256 amount) public {</span>
  120 |     | <span class='unexecuted'>        amount = bound(amount, 1, 1e18);</span>
  121 |     | <span class='unexecuted'>        deal(address(usdc), alice, amount);</span>
  122 |     | <span class='neutral'></span>
  123 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  124 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  125 |     | <span class='neutral'></span>
  126 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
  127 |     | <span class='neutral'></span>
  128 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(vault.balanceOf(alice)), amount, &quot;balance&quot;);</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    /// #rebalance ///</span>
  134 |     | <span class='neutral'></span>
  135 |     | <span class='unexecuted'>    function test_rebalance_FailsIfCallerIsNotKeeper() public {</span>
  136 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  137 |     | <span class='unexecuted'>        vm.expectRevert(CallerNotKeeper.selector);</span>
  138 |     | <span class='unexecuted'>        vault.rebalance();</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='unexecuted'>    function test_rebalance_DepositsUsdcAndBorrowsWeth() public {</span>
  142 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  143 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  146 |     | <span class='unexecuted'>        vault.rebalance();</span>
  147 |     | <span class='neutral'></span>
  148 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.getCollateral(), amount.mulWadDown(0.99e18), 1, &quot;collateral&quot;); // - float</span>
  149 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), 3_758780025000000000, &quot;debt&quot;);</span>
  150 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), amount.mulWadUp(vault.floatPercentage()), &quot;float&quot;);</span>
  151 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), amount, 1, &quot;total assets&quot;);</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='unexecuted'>    function test_rebalance_EmitsEventOnSuccess() public {</span>
  155 |     | <span class='unexecuted'>        uint256 initialBalance = 10000e6;</span>
  156 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), initialBalance);</span>
  157 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  158 |     | <span class='unexecuted'>        vault.rebalance();</span>
  159 |     | <span class='unexecuted'>        uint256 currentFloat = usdc.balanceOf(address(vault));</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>        // double the initial balance</span>
  162 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), initialBalance);</span>
  163 |     | <span class='neutral'></span>
  164 |     | <span class='unexecuted'>        uint256 finalFloat = 199000000;</span>
  165 |     | <span class='unexecuted'>        assertApproxEqRel(currentFloat * 2, finalFloat, 0.01e18, &quot;float&quot;);</span>
  166 |     | <span class='unexecuted'>        uint256 currentDebt = vault.getDebt();</span>
  167 |     | <span class='unexecuted'>        uint256 finalDebt = 7479972249750000000;</span>
  168 |     | <span class='unexecuted'>        assertApproxEqRel(currentDebt * 2, finalDebt, 0.01e18, &quot;debt&quot;);</span>
  169 |     | <span class='unexecuted'>        uint256 currentCollateral = vault.getCollateral();</span>
  170 |     | <span class='unexecuted'>        uint256 finalCollateral = 19701000000;</span>
  171 |     | <span class='unexecuted'>        assertApproxEqRel(currentCollateral * 2, finalCollateral, 0.01e18, &quot;collateral&quot;);</span>
  172 |     | <span class='unexecuted'>        uint256 targetLtv = vault.targetLtv();</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true);</span>
  175 |     | <span class='unexecuted'>        emit Rebalanced(</span>
  176 |     | <span class='neutral'>            targetLtv, currentDebt, finalDebt, currentCollateral, finalCollateral, initialBalance, finalFloat</span>
  177 |     | <span class='neutral'>        );</span>
  178 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  179 |     | <span class='unexecuted'>        vault.rebalance();</span>
  180 |     | <span class='neutral'>    }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='unexecuted'>    function test_rebalance_DoesntDepositIfFloatRequirementIsGreaterThanBalance() public {</span>
  183 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), 10000e6);</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  186 |     | <span class='unexecuted'>        vault.rebalance();</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>        // set float to 2%</span>
  189 |     | <span class='unexecuted'>        vault.setFloatPercentage(0.02e18);</span>
  190 |     | <span class='neutral'></span>
  191 |     | <span class='unexecuted'>        uint256 floatExpected = vault.floatPercentage().mulWadDown(vault.totalAssets());</span>
  192 |     | <span class='unexecuted'>        assertTrue(vault.getUsdcBalance() &lt; floatExpected, &quot;float requirement is not greater than balance&quot;);</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
  195 |     | <span class='neutral'></span>
  196 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  197 |     | <span class='unexecuted'>        vault.rebalance();</span>
  198 |     | <span class='neutral'></span>
  199 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), collateralBefore, &quot;collateral&quot;);</span>
  200 |     | <span class='neutral'>    }</span>
  201 |     | <span class='neutral'></span>
  202 |     | <span class='unexecuted'>    function test_rebalance_DoesntDepositIfAssetsLessThanMin() public {</span>
  203 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), vault.rebalanceMinimum() - 1);</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='unexecuted'>        vault.setFloatPercentage(0);</span>
  206 |     | <span class='neutral'></span>
  207 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  208 |     | <span class='unexecuted'>        vault.rebalance();</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), 0, &quot;collateral&quot;);</span>
  211 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.getUsdcBalance(), vault.rebalanceMinimum(), 1, &quot;float&quot;);</span>
  212 |     | <span class='neutral'>    }</span>
  213 |     | <span class='neutral'></span>
  214 |     | <span class='unexecuted'>    function test_rebalance_DoesntDepositIfAssetsLessThanMin2() public {</span>
  215 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), vault.rebalanceMinimum());</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='unexecuted'>        vault.setFloatPercentage(0);</span>
  218 |     | <span class='neutral'></span>
  219 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  220 |     | <span class='unexecuted'>        vault.rebalance();</span>
  221 |     | <span class='neutral'></span>
  222 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.getCollateral(), vault.rebalanceMinimum(), 1, &quot;collateral&quot;);</span>
  223 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), 0, &quot;float&quot;);</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='unexecuted'>    function test_rebalance_RespectsRequiredFloatAmount() public {</span>
  227 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  228 |     | <span class='unexecuted'>        uint256 floatRequired = 200e6; // 2%</span>
  229 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  230 |     | <span class='unexecuted'>        vault.setFloatPercentage(0.02e18);</span>
  231 |     | <span class='neutral'></span>
  232 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  233 |     | <span class='unexecuted'>        vault.rebalance();</span>
  234 |     | <span class='neutral'></span>
  235 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), floatRequired, &quot;float&quot;);</span>
  236 |     | <span class='unexecuted'>        uint256 collateralExpected = amount - floatRequired;</span>
  237 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.getCollateral(), collateralExpected, 1, &quot;collateral&quot;);</span>
  238 |     | <span class='neutral'>    }</span>
  239 |     | <span class='neutral'></span>
  240 |     | <span class='unexecuted'>    function test_rebalance_RespectsTargetLtvPercentage() public {</span>
  241 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), 10000e6);</span>
  242 |     | <span class='neutral'></span>
  243 |     | <span class='neutral'>        // no debt yet</span>
  244 |     | <span class='unexecuted'>        assertEq(vault.getLtv(), 0);</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  247 |     | <span class='unexecuted'>        vault.rebalance();</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), vault.targetLtv(), 0.005e18);</span>
  250 |     | <span class='neutral'>    }</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='unexecuted'>    function test_rebalance_DoesntRebalanceWhenLtvIsWithinRange() public {</span>
  253 |     | <span class='unexecuted'>        uint256 initialBalance = 10000e6;</span>
  254 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), initialBalance);</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>        // no debt yet</span>
  257 |     | <span class='unexecuted'>        assertEq(vault.getLtv(), 0);</span>
  258 |     | <span class='neutral'></span>
  259 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  260 |     | <span class='unexecuted'>        vault.rebalance();</span>
  261 |     | <span class='neutral'></span>
  262 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
  263 |     | <span class='unexecuted'>        uint256 debtBefore = vault.getDebt();</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>        // add 1% more assets</span>
  266 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), vault.totalAssets().mulWadUp(0.01e18));</span>
  267 |     | <span class='neutral'></span>
  268 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  269 |     | <span class='unexecuted'>        vault.rebalance();</span>
  270 |     | <span class='neutral'></span>
  271 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), collateralBefore);</span>
  272 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), debtBefore);</span>
  273 |     | <span class='neutral'>    }</span>
  274 |     | <span class='neutral'></span>
  275 |     | <span class='unexecuted'>    function test_rebalance_DoesntRebalanceForSmallProfit() public {</span>
  276 |     | <span class='unexecuted'>        uint256 initialBalance = 10000e6;</span>
  277 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), initialBalance);</span>
  278 |     | <span class='neutral'></span>
  279 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  280 |     | <span class='unexecuted'>        vault.rebalance();</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
  283 |     | <span class='unexecuted'>        uint256 debtBefore = vault.getDebt();</span>
  284 |     | <span class='unexecuted'>        uint256 floatBefore = vault.getUsdcBalance();</span>
  285 |     | <span class='unexecuted'>        uint256 totalAssetsBefore = vault.totalAssets();</span>
  286 |     | <span class='neutral'></span>
  287 |     | <span class='neutral'>        // add 1% profit to the weth vault</span>
  288 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  289 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested.mulWadUp(1.01e18));</span>
  290 |     | <span class='neutral'></span>
  291 |     | <span class='unexecuted'>        assertTrue(vault.totalAssets() &gt; totalAssetsBefore);</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  294 |     | <span class='unexecuted'>        vault.rebalance();</span>
  295 |     | <span class='neutral'></span>
  296 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), collateralBefore);</span>
  297 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), debtBefore);</span>
  298 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), floatBefore);</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='unexecuted'>    function testFuzz_rebalance(uint256 amount) public {</span>
  302 |     | <span class='unexecuted'>        vault.setFloatPercentage(0);</span>
  303 |     | <span class='unexecuted'>        uint256 lowerBound = vault.rebalanceMinimum().divWadUp(1e18 - vault.floatPercentage());</span>
  304 |     | <span class='unexecuted'>        amount = bound(amount, lowerBound, 10_000_000e6);</span>
  305 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  306 |     | <span class='neutral'></span>
  307 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  308 |     | <span class='unexecuted'>        vault.rebalance();</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
  311 |     | <span class='unexecuted'>        uint256 debtBefore = vault.getDebt();</span>
  312 |     | <span class='unexecuted'>        uint256 floatBefore = vault.getUsdcBalance();</span>
  313 |     | <span class='unexecuted'>        uint256 totalAssetsBefore = vault.totalAssets();</span>
  314 |     | <span class='neutral'></span>
  315 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  316 |     | <span class='neutral'>        // add enough profit to make total assets double</span>
  317 |     | <span class='unexecuted'>        uint256 profit = wethInvested + wethInvested.mulDivUp(1.02e18, vault.getLtv());</span>
  318 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), profit);</span>
  319 |     | <span class='unexecuted'>        assertTrue(vault.totalAssets() &gt;= totalAssetsBefore * 2, &quot;totalAssets less than doubled&quot;);</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
  322 |     | <span class='unexecuted'>        vault.sellProfit(0);</span>
  323 |     | <span class='unexecuted'>        vault.rebalance();</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), totalAssetsBefore * 2, 0.01e18);</span>
  326 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getCollateral(), collateralBefore * 2, 0.01e18, &quot;collateral&quot;);</span>
  327 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getDebt(), debtBefore * 2, 0.01e18, &quot;debt&quot;);</span>
  328 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getUsdcBalance(), floatBefore * 2, 0.01e18, &quot;float&quot;);</span>
  329 |     | <span class='neutral'>    }</span>
  330 |     | <span class='neutral'></span>
  331 |     | <span class='neutral'>    /// #sellProfit ///</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='unexecuted'>    function test_sellProfit_FailsIfCallerIsNotKeeper() public {</span>
  334 |     | <span class='unexecuted'>        vm.prank(alice);</span>
  335 |     | <span class='unexecuted'>        vm.expectRevert(CallerNotKeeper.selector);</span>
  336 |     | <span class='unexecuted'>        vault.sellProfit(0);</span>
  337 |     | <span class='neutral'>    }</span>
  338 |     | <span class='neutral'></span>
  339 |     | <span class='unexecuted'>    function test_sellProfit_FailsIfProfitsAre0() public {</span>
  340 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  341 |     | <span class='unexecuted'>        vm.expectRevert(NoProfitsToSell.selector);</span>
  342 |     | <span class='neutral'>        vault.sellProfit(0);</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='unexecuted'>    function test_sellProfit_onlySellsProfit() public {</span>
  346 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  347 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  350 |     | <span class='unexecuted'>        vault.rebalance();</span>
  351 |     | <span class='neutral'></span>
  352 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  353 |     | <span class='unexecuted'>        uint256 initialWethInvested = vault.getInvested();</span>
  354 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), initialWethInvested * 2);</span>
  355 |     | <span class='neutral'></span>
  356 |     | <span class='unexecuted'>        uint256 usdcBalanceBefore = vault.getUsdcBalance();</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  359 |     | <span class='unexecuted'>        vault.sellProfit(0);</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='unexecuted'>        uint256 expectedUsdcBalance = usdcBalanceBefore + vault.getCollateral().mulWadDown(vault.targetLtv());</span>
  362 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getUsdcBalance(), expectedUsdcBalance, 0.01e18, &quot;usdc balance&quot;);</span>
  363 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getInvested(), initialWethInvested, 0.001e18, &quot;sold more than actual profit&quot;);</span>
  364 |     | <span class='neutral'>    }</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='unexecuted'>    function test_sellProfit_emitsEvent() public {</span>
  367 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  368 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  369 |     | <span class='neutral'></span>
  370 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  371 |     | <span class='unexecuted'>        vault.rebalance();</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  374 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  375 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  376 |     | <span class='unexecuted'>        uint256 profit = vault.getProfit();</span>
  377 |     | <span class='neutral'></span>
  378 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true);</span>
  379 |     | <span class='unexecuted'>        emit ProfitSold(profit, 6438_101822);</span>
  380 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  381 |     | <span class='unexecuted'>        vault.sellProfit(0);</span>
  382 |     | <span class='neutral'>    }</span>
  383 |     | <span class='neutral'></span>
  384 |     | <span class='unexecuted'>    function test_sellProfit_FailsIfAmountReceivedIsLeessThanAmountOutMin() public {</span>
  385 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  386 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  387 |     | <span class='neutral'></span>
  388 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  389 |     | <span class='unexecuted'>        vault.rebalance();</span>
  390 |     | <span class='neutral'></span>
  391 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  392 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  393 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  394 |     | <span class='neutral'></span>
  395 |     | <span class='unexecuted'>        uint256 tooLargeUsdcAmountOutMin = vault.getCollateral().mulWadDown(vault.targetLtv()).mulWadDown(1.05e18); // add 5% more than expected</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  398 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Too little received&quot;);</span>
  399 |     | <span class='unexecuted'>        vault.sellProfit(tooLargeUsdcAmountOutMin);</span>
  400 |     | <span class='neutral'>    }</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='neutral'>    /// #applyNewTargetLtv ///</span>
  403 |     | <span class='neutral'></span>
  404 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_FailsIfCallerIsNotKeeper() public {</span>
  405 |     | <span class='unexecuted'>        uint256 newTargetLtv = vault.targetLtv() / 2;</span>
  406 |     | <span class='neutral'></span>
  407 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  408 |     | <span class='unexecuted'>        vm.expectRevert(CallerNotKeeper.selector);</span>
  409 |     | <span class='neutral'>        vault.applyNewTargetLtv(newTargetLtv);</span>
  410 |     | <span class='neutral'>    }</span>
  411 |     | <span class='neutral'></span>
  412 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_EmitsEventOnSuccess() public {</span>
  413 |     | <span class='unexecuted'>        uint256 newTargetLtv = vault.targetLtv() / 2;</span>
  414 |     | <span class='neutral'></span>
  415 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true);</span>
  416 |     | <span class='unexecuted'>        emit NewTargetLtvApplied(keeper, newTargetLtv);</span>
  417 |     | <span class='neutral'></span>
  418 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  419 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(newTargetLtv);</span>
  420 |     | <span class='neutral'>    }</span>
  421 |     | <span class='neutral'></span>
  422 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_ChangesLtvUpAndRebalances() public {</span>
  423 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), 10000e6);</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  426 |     | <span class='unexecuted'>        vault.rebalance();</span>
  427 |     | <span class='neutral'></span>
  428 |     | <span class='unexecuted'>        uint256 oldTargetLtv = vault.targetLtv();</span>
  429 |     | <span class='unexecuted'>        uint256 debtBefore = vault.getDebt();</span>
  430 |     | <span class='neutral'>        // add 10% to target ltv</span>
  431 |     | <span class='unexecuted'>        uint256 newTargetLtv = oldTargetLtv.mulWadUp(1.1e18);</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  434 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(newTargetLtv);</span>
  435 |     | <span class='neutral'></span>
  436 |     | <span class='unexecuted'>        assertEq(vault.targetLtv(), newTargetLtv, &quot;target ltv&quot;);</span>
  437 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), newTargetLtv, 0.005e18, &quot;ltv&quot;);</span>
  438 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getDebt(), debtBefore.mulWadUp(1.1e18), 0.001e18, &quot;debt&quot;);</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_ChangesLtvDownAndRebalances() public {</span>
  442 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), 10000e6);</span>
  443 |     | <span class='neutral'></span>
  444 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
  445 |     | <span class='unexecuted'>        vault.rebalance();</span>
  446 |     | <span class='unexecuted'>        wethVault.harvest();</span>
  447 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='unexecuted'>        uint256 oldTargetLtv = vault.targetLtv();</span>
  450 |     | <span class='unexecuted'>        uint256 debtBefore = vault.getDebt();</span>
  451 |     | <span class='neutral'>        // subtract 10% from target ltv</span>
  452 |     | <span class='unexecuted'>        uint256 newTargetLtv = oldTargetLtv.mulWadDown(0.9e18);</span>
  453 |     | <span class='neutral'></span>
  454 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  455 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(newTargetLtv);</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='unexecuted'>        assertEq(vault.targetLtv(), newTargetLtv, &quot;target ltv&quot;);</span>
  458 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), newTargetLtv, 0.005e18, &quot;ltv&quot;);</span>
  459 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getDebt(), debtBefore.mulWadUp(0.9e18), 0.001e18, &quot;debt&quot;);</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_FailsIfNewLtvIsTooHigh() public {</span>
  463 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), 10000e6);</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='unexecuted'>        uint256 tooHighLtv = vault.getMaxLtv() + 1;</span>
  466 |     | <span class='neutral'></span>
  467 |     | <span class='unexecuted'>        vm.expectRevert(InvalidTargetLtv.selector);</span>
  468 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  469 |     | <span class='neutral'>        vault.applyNewTargetLtv(tooHighLtv);</span>
  470 |     | <span class='neutral'>    }</span>
  471 |     | <span class='neutral'></span>
  472 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_WorksIfNewLtvIs0() public {</span>
  473 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), 10000e6);</span>
  474 |     | <span class='neutral'></span>
  475 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  476 |     | <span class='unexecuted'>        vault.rebalance();</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='unexecuted'>        assertTrue(vault.getLtv() &gt; 0);</span>
  479 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  482 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(0);</span>
  483 |     | <span class='neutral'></span>
  484 |     | <span class='unexecuted'>        assertEq(vault.getLtv(), 0, &quot;ltv&quot;);</span>
  485 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), 0, &quot;debt&quot;);</span>
  486 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), collateralBefore, &quot;collateral&quot;);</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    /// #totalAssets ///</span>
  490 |     | <span class='neutral'></span>
  491 |     | <span class='unexecuted'>    function test_totalAssets_CorrectlyAccountsAssetsAndLiabilities() public {</span>
  492 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  493 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  494 |     | <span class='neutral'></span>
  495 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
  496 |     | <span class='unexecuted'>        vault.rebalance();</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), amount, 1, &quot;total assets before ltv change&quot;);</span>
  499 |     | <span class='neutral'></span>
  500 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(0.5e18);</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), amount, 1, &quot;total assets after ltv change&quot;);</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='unexecuted'>    function test_totalAssets_AccountProfitsMade() public {</span>
  506 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  507 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  510 |     | <span class='unexecuted'>        vault.rebalance();</span>
  511 |     | <span class='neutral'></span>
  512 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  513 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  514 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  515 |     | <span class='neutral'></span>
  516 |     | <span class='neutral'>        // ~65% profit because of 65% target ltv</span>
  517 |     | <span class='unexecuted'>        uint256 expectedProfit = amount.mulWadDown(vault.getLtv()).mulWadDown(vault.slippageTolerance());</span>
  518 |     | <span class='neutral'></span>
  519 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), amount + expectedProfit, 0.005e18, &quot;total assets&quot;);</span>
  520 |     | <span class='neutral'>    }</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='unexecuted'>    function test_totalAssets_AccountSlippageOnProfitsMade() public {</span>
  523 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  524 |     | <span class='unexecuted'>        deal(address(usdc), address(vault), amount);</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  527 |     | <span class='unexecuted'>        vault.rebalance();</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  530 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  531 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='unexecuted'>        uint256 totalBefore = vault.totalAssets();</span>
  534 |     | <span class='unexecuted'>        uint256 profit = totalBefore - amount;</span>
  535 |     | <span class='neutral'></span>
  536 |     | <span class='neutral'>        // decrease slippage tolerance by 1%</span>
  537 |     | <span class='unexecuted'>        uint256 newSlippageTolerance = vault.slippageTolerance() - 0.01e18;</span>
  538 |     | <span class='unexecuted'>        vault.setSlippageTolerance(newSlippageTolerance);</span>
  539 |     | <span class='neutral'></span>
  540 |     | <span class='unexecuted'>        assertTrue(vault.totalAssets() &lt; totalBefore, &quot;total assets should be less than before&quot;);</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='unexecuted'>        assertApproxEqRel(</span>
  543 |     | <span class='unexecuted'>            vault.totalAssets(),</span>
  544 |     | <span class='unexecuted'>            totalBefore - profit.mulWadDown(1e18 - vault.slippageTolerance()),</span>
  545 |     | <span class='unexecuted'>            0.005e18,</span>
  546 |     | <span class='neutral'>            &quot;total assets&quot;</span>
  547 |     | <span class='neutral'>        );</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    /// #withdraw ///</span>
  551 |     | <span class='neutral'></span>
  552 |     | <span class='unexecuted'>    function test_withdraw_UsesAssetsFromFloatFirst() public {</span>
  553 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  554 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  555 |     | <span class='neutral'></span>
  556 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  557 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  558 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  559 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='unexecuted'>        vault.setFloatPercentage(0.5e18);</span>
  562 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  563 |     | <span class='unexecuted'>        vault.rebalance();</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='unexecuted'>        uint256 floatBefore = vault.getUsdcBalance();</span>
  566 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
  567 |     | <span class='neutral'></span>
  568 |     | <span class='unexecuted'>        assertApproxEqAbs(floatBefore, deposit / 2, 1, &quot;float before&quot;);</span>
  569 |     | <span class='unexecuted'>        assertApproxEqAbs(collateralBefore, deposit / 2, 1, &quot;collateral before&quot;);</span>
  570 |     | <span class='neutral'></span>
  571 |     | <span class='unexecuted'>        uint256 withdrawAmount = 5000e6;</span>
  572 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  573 |     | <span class='unexecuted'>        vault.withdraw(withdrawAmount, address(alice), address(alice));</span>
  574 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  575 |     | <span class='neutral'></span>
  576 |     | <span class='unexecuted'>        assertApproxEqAbs(usdc.balanceOf(alice), withdrawAmount, 1, &quot;alice&#39;s usdc balance&quot;);</span>
  577 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), deposit - withdrawAmount, 1, &quot;vault total assets&quot;);</span>
  578 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), floatBefore - withdrawAmount, &quot;vault float&quot;);</span>
  579 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), collateralBefore, &quot;vault collateral&quot;);</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='unexecuted'>    function test_withdraw_UsesAssetsFromProfitsSecond() public {</span>
  583 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  584 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  585 |     | <span class='neutral'></span>
  586 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  587 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  588 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  589 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  590 |     | <span class='neutral'></span>
  591 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  592 |     | <span class='unexecuted'>        vault.rebalance();</span>
  593 |     | <span class='neutral'></span>
  594 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  595 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  596 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
  599 |     | <span class='unexecuted'>        uint256 totalAssetsBefore = vault.totalAssets();</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='unexecuted'>        uint256 withdrawAmount = 5000e6;</span>
  602 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  603 |     | <span class='unexecuted'>        vault.withdraw(withdrawAmount, address(alice), address(alice));</span>
  604 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='unexecuted'>        assertApproxEqAbs(usdc.balanceOf(alice), withdrawAmount, 1, &quot;alice&#39;s usdc balance&quot;);</span>
  607 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), totalAssetsBefore - withdrawAmount, 0.001e18, &quot;vault total assets&quot;);</span>
  608 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), collateralBefore, &quot;vault collateral&quot;);</span>
  609 |     | <span class='neutral'>        // float is maintained</span>
  610 |     | <span class='unexecuted'>        uint256 floatExpeced = vault.totalAssets().mulWadDown(vault.floatPercentage());</span>
  611 |     | <span class='unexecuted'>        assertTrue(vault.getUsdcBalance() &gt;= floatExpeced, &quot;vault float&quot;);</span>
  612 |     | <span class='neutral'>    }</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='unexecuted'>    function test_withdraw_UsesAssetsFromProfitsOnlyWhenFloatIs0() public {</span>
  615 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  616 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='unexecuted'>        vault.setFloatPercentage(0);</span>
  619 |     | <span class='neutral'></span>
  620 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  621 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  622 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  623 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  626 |     | <span class='unexecuted'>        vault.rebalance();</span>
  627 |     | <span class='neutral'></span>
  628 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), 0, &quot;vault float&quot;);</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  631 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  632 |     | <span class='neutral'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>        uint256 collateralBefore = vault.getCollateral();</span>
  635 |     | <span class='neutral'>        uint256 totalAssetsBefore = vault.totalAssets();</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>        uint256 withdrawAmount = 5000e6;</span>
  638 |     | <span class='neutral'>        vm.startPrank(alice);</span>
  639 |     | <span class='neutral'>        vault.withdraw(withdrawAmount, address(alice), address(alice));</span>
  640 |     | <span class='neutral'>        vm.stopPrank();</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>        assertApproxEqAbs(usdc.balanceOf(alice), withdrawAmount, 1, &quot;alice&#39;s usdc balance&quot;);</span>
  643 |     | <span class='neutral'>        assertApproxEqAbs(vault.totalAssets(), totalAssetsBefore - withdrawAmount, 0.001e18, &quot;vault total assets&quot;);</span>
  644 |     | <span class='neutral'>        assertEq(vault.getCollateral(), collateralBefore, &quot;vault collateral&quot;);</span>
  645 |     | <span class='neutral'>        // float is maintained</span>
  646 |     | <span class='neutral'>        uint256 floatExpeced = vault.totalAssets().mulWadDown(vault.floatPercentage());</span>
  647 |     | <span class='neutral'>        assertTrue(vault.getUsdcBalance() &gt;= floatExpeced, &quot;vault float&quot;);</span>
  648 |     | <span class='neutral'>    }</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='unexecuted'>    function test_withdraw_UsesAssetsFromCollateralLast() public {</span>
  651 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  652 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  655 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  656 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  657 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  658 |     | <span class='neutral'></span>
  659 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  660 |     | <span class='unexecuted'>        vault.rebalance();</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  663 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  664 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='unexecuted'>        uint256 totalAssetsBefore = vault.totalAssets();</span>
  667 |     | <span class='neutral'></span>
  668 |     | <span class='unexecuted'>        uint256 withdrawAmount = 15000e6; // this amount forces selling of whole profits</span>
  669 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  670 |     | <span class='unexecuted'>        vault.withdraw(withdrawAmount, address(alice), address(alice));</span>
  671 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='unexecuted'>        assertApproxEqAbs(usdc.balanceOf(alice), withdrawAmount, 1, &quot;alice&#39;s usdc balance&quot;);</span>
  674 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), totalAssetsBefore - withdrawAmount, 0.05e18, &quot;vault total assets&quot;);</span>
  675 |     | <span class='neutral'>        // float is maintained</span>
  676 |     | <span class='unexecuted'>        uint256 floatExpeced = vault.totalAssets().mulWadDown(vault.floatPercentage());</span>
  677 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getUsdcBalance(), floatExpeced, 0.05e18, &quot;vault float&quot;);</span>
  678 |     | <span class='unexecuted'>        uint256 collateralExpected = totalAssetsBefore - floatExpeced - withdrawAmount;</span>
  679 |     | <span class='unexecuted'>        assertTrue(vault.getCollateral() &gt;= collateralExpected, &quot;vault collateral&quot;);</span>
  680 |     | <span class='neutral'>    }</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='unexecuted'>    function test_withdraw_WorksWhenWithdrawingMaxAvailable() public {</span>
  683 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  684 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  687 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  688 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  689 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  690 |     | <span class='neutral'></span>
  691 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  692 |     | <span class='unexecuted'>        vault.rebalance();</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  695 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  696 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='unexecuted'>        uint256 totalAssetsBefore = vault.totalAssets();</span>
  699 |     | <span class='unexecuted'>        uint256 totalCollateralBefore = vault.getCollateral();</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  702 |     | <span class='unexecuted'>        vault.withdraw(totalAssetsBefore, address(alice), address(alice));</span>
  703 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='unexecuted'>        assertApproxEqAbs(usdc.balanceOf(alice), totalAssetsBefore, 1, &quot;alice&#39;s usdc balance&quot;);</span>
  706 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getUsdcBalance(), 0, 0.05e18, &quot;vault float&quot;);</span>
  707 |     | <span class='neutral'>        // some dust can be left in as collateral</span>
  708 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getCollateral(), totalCollateralBefore.mulWadUp(0.005e18), 1e18, &quot;vault collateral&quot;);</span>
  709 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), totalAssetsBefore.mulWadUp(0.005e18), 1e18, &quot;vault total assets&quot;);</span>
  710 |     | <span class='neutral'>    }</span>
  711 |     | <span class='neutral'></span>
  712 |     | <span class='unexecuted'>    function test_withdraw_WorksWithdrawingMaxWhenFloatIs0() public {</span>
  713 |     | <span class='neutral'>        // redeploy vault with mock router because swapping usdc at current block results in &quot;positive&quot; slippage</span>
  714 |     | <span class='unexecuted'>        MockSwapRouter mockRouter = new MockSwapRouter();</span>
  715 |     | <span class='unexecuted'>        deal(address(usdc), address(mockRouter), 10_000_000e6);</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='unexecuted'>        scUSDC.ConstructorParams memory params = _createDefaultUsdcVaultConstructorParams(wethVault);</span>
  718 |     | <span class='unexecuted'>        params.uniswapSwapRouter = mockRouter;</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='unexecuted'>        vault = new scUSDC(params);</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='unexecuted'>        vault.setFloatPercentage(0);</span>
  723 |     | <span class='neutral'></span>
  724 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  725 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  726 |     | <span class='neutral'></span>
  727 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  728 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  729 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  730 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  731 |     | <span class='neutral'></span>
  732 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  733 |     | <span class='unexecuted'>        vault.rebalance();</span>
  734 |     | <span class='neutral'></span>
  735 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  736 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  737 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested.mulWadUp(2e18));</span>
  738 |     | <span class='neutral'></span>
  739 |     | <span class='unexecuted'>        uint256 totalAssetsBefore = vault.totalAssets();</span>
  740 |     | <span class='unexecuted'>        uint256 totalCollateralBefore = vault.getCollateral();</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  743 |     | <span class='unexecuted'>        vault.withdraw(totalAssetsBefore, address(alice), address(alice));</span>
  744 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='unexecuted'>        assertApproxEqAbs(usdc.balanceOf(alice), totalAssetsBefore, 1, &quot;alice&#39;s usdc balance&quot;);</span>
  747 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getUsdcBalance(), 0, 0.05e18, &quot;vault float&quot;);</span>
  748 |     | <span class='neutral'>        // some dust can be left in as collateral</span>
  749 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getCollateral(), totalCollateralBefore.mulWadUp(0.0005e18), 1e18, &quot;vault collateral&quot;);</span>
  750 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), totalAssetsBefore.mulWadUp(0.0005e18), 1e18, &quot;vault total assets&quot;);</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='unexecuted'>    function test_withdraw_FailsIfAmountOutIsLessThanMinWhenSellingProfits() public {</span>
  754 |     | <span class='unexecuted'>        uint256 deposit = 1_000_000e6;</span>
  755 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  758 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  759 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  760 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  763 |     | <span class='unexecuted'>        vault.rebalance();</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  766 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  767 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='unexecuted'>        vault.setSlippageTolerance(1e18);</span>
  770 |     | <span class='neutral'></span>
  771 |     | <span class='unexecuted'>        uint256 withdrawAmount = 1_000_000e6; // this amount forces selling of whole profits</span>
  772 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  773 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Too little received&quot;);</span>
  774 |     | <span class='unexecuted'>        vault.withdraw(withdrawAmount, address(alice), address(alice));</span>
  775 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  776 |     | <span class='neutral'>    }</span>
  777 |     | <span class='neutral'></span>
  778 |     | <span class='unexecuted'>    function test_withdraw_WorksWhenVaultIsUnderwater() public {</span>
  779 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  780 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  783 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  784 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  785 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  786 |     | <span class='neutral'></span>
  787 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  788 |     | <span class='unexecuted'>        vault.rebalance();</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>        // 50% loss to the weth vault</span>
  791 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  792 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested / 2);</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='unexecuted'>        uint256 totalBefore = vault.totalAssets();</span>
  795 |     | <span class='unexecuted'>        uint256 ltvBefore = vault.getLtv();</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>        // we should be able to withdraw half of the deposit</span>
  798 |     | <span class='unexecuted'>        uint256 withdrawAmount = deposit / 2;</span>
  799 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  800 |     | <span class='unexecuted'>        vault.withdraw(withdrawAmount, address(alice), address(alice));</span>
  801 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  802 |     | <span class='neutral'></span>
  803 |     | <span class='unexecuted'>        assertApproxEqAbs(usdc.balanceOf(alice), withdrawAmount, 1, &quot;alice&#39;s usdc balance&quot;);</span>
  804 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), totalBefore - withdrawAmount, 0.005e18, &quot;vault total assets&quot;);</span>
  805 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getCollateral(), deposit - withdrawAmount, 0.01e18, &quot;vault collateral&quot;);</span>
  806 |     | <span class='neutral'>        // ltv should not change</span>
  807 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), ltvBefore, 0.001e18, &quot;vault ltv&quot;);</span>
  808 |     | <span class='neutral'>    }</span>
  809 |     | <span class='neutral'></span>
  810 |     | <span class='unexecuted'>    function test_withdraw_FailsIfWithdrawingMoreWhenVaultIsUnderwater() public {</span>
  811 |     | <span class='unexecuted'>        uint256 deposit = 10000e6;</span>
  812 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  813 |     | <span class='neutral'></span>
  814 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  815 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  816 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  817 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  818 |     | <span class='neutral'></span>
  819 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  820 |     | <span class='unexecuted'>        vault.rebalance();</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>        // 50% loss to the weth vault</span>
  823 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  824 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested / 2);</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>        // we cannot withdraw evertying because we don&#39;t have enough to repay the debt</span>
  827 |     | <span class='unexecuted'>        uint256 withdrawAmount = vault.totalAssets();</span>
  828 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  829 |     | <span class='unexecuted'>        vm.expectRevert();</span>
  830 |     | <span class='unexecuted'>        vault.withdraw(withdrawAmount, address(alice), address(alice));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='unexecuted'>    function testFuzz_withdraw(uint256 amount) public {</span>
  834 |     | <span class='unexecuted'>        amount = bound(amount, 1, 10_000_000e6); // upper limit constrained by weth available on aave</span>
  835 |     | <span class='unexecuted'>        deal(address(usdc), alice, amount);</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  838 |     | <span class='neutral'></span>
  839 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  840 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
  841 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  842 |     | <span class='neutral'></span>
  843 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  844 |     | <span class='unexecuted'>        vault.rebalance();</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='unexecuted'>        uint256 assets = vault.convertToAssets(vault.balanceOf(alice));</span>
  847 |     | <span class='neutral'>        // due to rounding errors, we can&#39;t assert exact equality</span>
  848 |     | <span class='unexecuted'>        assertApproxEqAbs(assets, amount, 1, &quot;assets&quot;);</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  851 |     | <span class='unexecuted'>        vault.withdraw(assets, alice, alice);</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.balanceOf(alice), 0, 1, &quot;balance&quot;);</span>
  854 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), 0, 1, &quot;total assets&quot;);</span>
  855 |     | <span class='unexecuted'>        assertApproxEqAbs(usdc.balanceOf(alice), amount, 0.01e6, &quot;usdc balance&quot;);</span>
  856 |     | <span class='neutral'>    }</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='unexecuted'>    function testFuzz_withdraw_WhenInProfit(uint256 amount) public {</span>
  859 |     | <span class='unexecuted'>        uint256 lowerBound = vault.rebalanceMinimum().divWadUp(1e18 - vault.floatPercentage());</span>
  860 |     | <span class='unexecuted'>        amount = bound(amount, lowerBound, 10_000_000e6); // upper limit constrained by weth available on aave</span>
  861 |     | <span class='unexecuted'>        deal(address(usdc), alice, amount);</span>
  862 |     | <span class='neutral'></span>
  863 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  866 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
  867 |     | <span class='neutral'></span>
  868 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  871 |     | <span class='unexecuted'>        vault.rebalance();</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  874 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  875 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='unexecuted'>        uint256 assets = vault.convertToAssets(vault.balanceOf(alice));</span>
  878 |     | <span class='neutral'>        // some assets can be left in the vault because of slippage when selling profits</span>
  879 |     | <span class='unexecuted'>        uint256 toleratedLeftover = vault.totalAssets().mulWadUp(1e18 - vault.slippageTolerance());</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='unexecuted'>        assertApproxEqRel(assets, amount.mulWadDown(1e18 + vault.getLtv()), 0.01e18, &quot;assets&quot;);</span>
  882 |     | <span class='neutral'></span>
  883 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  884 |     | <span class='unexecuted'>        vault.withdraw(assets, alice, alice);</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.balanceOf(alice), 0, 1, &quot;balance&quot;);</span>
  887 |     | <span class='neutral'>        assertApproxEqRel(usdc.balanceOf(alice), amount.mulWadDown(1e18 + vault.targetLtv()), 0.01e18, &quot;usdc balance&quot;);</span>
  888 |     | <span class='neutral'>        assertTrue(vault.totalAssets() &lt;= toleratedLeftover, &quot;total assets&quot;);</span>
  889 |     | <span class='neutral'>    }</span>
  890 |     | <span class='neutral'></span>
  891 |     | <span class='neutral'>    /// #redeem ///</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='unexecuted'>    function testFuzz_redeem_WhenInProfit(uint256 amount) public {</span>
  894 |     | <span class='unexecuted'>        uint256 lowerBound = vault.rebalanceMinimum().divWadUp(1e18 - vault.floatPercentage());</span>
  895 |     | <span class='unexecuted'>        amount = bound(amount, lowerBound, 10_000_000e6); // upper limit constrained by weth available on aave</span>
  896 |     | <span class='unexecuted'>        deal(address(usdc), alice, amount);</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  899 |     | <span class='neutral'></span>
  900 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  901 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
  902 |     | <span class='neutral'></span>
  903 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  906 |     | <span class='unexecuted'>        vault.rebalance();</span>
  907 |     | <span class='neutral'></span>
  908 |     | <span class='neutral'>        // add 100% profit to the weth vault</span>
  909 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  910 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested * 2);</span>
  911 |     | <span class='neutral'></span>
  912 |     | <span class='unexecuted'>        uint256 shares = vault.balanceOf(alice);</span>
  913 |     | <span class='neutral'>        // some assets can be left in the vault because of slippage when selling profits</span>
  914 |     | <span class='unexecuted'>        uint256 toleratedLeftover = vault.totalAssets().mulWadUp(1e18 - vault.slippageTolerance());</span>
  915 |     | <span class='neutral'></span>
  916 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  917 |     | <span class='unexecuted'>        vault.redeem(shares, alice, alice);</span>
  918 |     | <span class='neutral'></span>
  919 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(alice), 0, &quot;balance&quot;);</span>
  920 |     | <span class='unexecuted'>        assertApproxEqRel(usdc.balanceOf(alice), amount.mulWadDown(1e18 + vault.targetLtv()), 0.01e18, &quot;usdc balance&quot;);</span>
  921 |     | <span class='unexecuted'>        assertTrue(vault.totalAssets() &lt;= toleratedLeftover, &quot;total assets&quot;);</span>
  922 |     | <span class='neutral'>    }</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>    /// #setSlippageTolerance ///</span>
  925 |     | <span class='neutral'></span>
  926 |     | <span class='unexecuted'>    function test_setSlippageTolerance_FailsIfCallerIsNotAdmin() public {</span>
  927 |     | <span class='unexecuted'>        uint256 tolerance = 0.01e18;</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  930 |     | <span class='unexecuted'>        vm.expectRevert(CallerNotAdmin.selector);</span>
  931 |     | <span class='unexecuted'>        vault.setSlippageTolerance(tolerance);</span>
  932 |     | <span class='neutral'>    }</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='unexecuted'>    function test_setSlippageTolearnce_UpdatesSlippageTolerance() public {</span>
  935 |     | <span class='unexecuted'>        uint256 newTolerance = 0.01e18;</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true);</span>
  938 |     | <span class='unexecuted'>        emit SlippageToleranceUpdated(address(this), newTolerance);</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='unexecuted'>        vault.setSlippageTolerance(newTolerance);</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='unexecuted'>        assertEq(vault.slippageTolerance(), newTolerance, &quot;slippage tolerance&quot;);</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    /// #exitAllPositions ///</span>
  946 |     | <span class='neutral'></span>
  947 |     | <span class='unexecuted'>    function test_exitAllPositions_FailsIfCallerIsNotAdmin() public {</span>
  948 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  949 |     | <span class='unexecuted'>        vm.expectRevert(CallerNotAdmin.selector);</span>
  950 |     | <span class='unexecuted'>        vault.exitAllPositions(0);</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='unexecuted'>    function test_exitAllPositions_FailsIfVaultIsNotUnderawater() public {</span>
  954 |     | <span class='unexecuted'>        uint256 deposit = 1_000_000e6;</span>
  955 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  958 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  959 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  960 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  961 |     | <span class='neutral'></span>
  962 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  963 |     | <span class='unexecuted'>        vault.rebalance();</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='unexecuted'>        vm.expectRevert(VaultNotUnderwater.selector);</span>
  966 |     | <span class='unexecuted'>        vault.exitAllPositions(0);</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='unexecuted'>    function test_exitAllPositions_RepaysDebtAndReleasesCollateral() public {</span>
  970 |     | <span class='unexecuted'>        uint256 deposit = 1_000_000e6;</span>
  971 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  974 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  975 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
  976 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  979 |     | <span class='unexecuted'>        vault.rebalance();</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>        // simulate 50% loss</span>
  982 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
  983 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested / 2);</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='unexecuted'>        uint256 totalBefore = vault.totalAssets();</span>
  986 |     | <span class='neutral'></span>
  987 |     | <span class='unexecuted'>        vault.exitAllPositions(0);</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getUsdcBalance(), totalBefore, 0.01e18, &quot;vault usdc balance&quot;);</span>
  990 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), 0, &quot;vault collateral&quot;);</span>
  991 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), 0, &quot;vault debt&quot;);</span>
  992 |     | <span class='neutral'>    }</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='unexecuted'>    function test_exitAllPositions_EmitsEventOnSuccess() public {</span>
  995 |     | <span class='unexecuted'>        uint256 deposit = 1_000_000e6;</span>
  996 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  999 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
 1000 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
 1001 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 1002 |     | <span class='neutral'></span>
 1003 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 1004 |     | <span class='unexecuted'>        vault.rebalance();</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>        // simulate 50% loss</span>
 1007 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
 1008 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested / 2);</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='unexecuted'>        uint256 invested = vault.getInvested();</span>
 1011 |     | <span class='unexecuted'>        uint256 debt = vault.getDebt();</span>
 1012 |     | <span class='unexecuted'>        uint256 collateral = vault.getCollateral();</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='unexecuted'>        vm.expectEmit(true, true, true, true);</span>
 1015 |     | <span class='unexecuted'>        emit EmergencyExitExecuted(address(this), invested, debt, collateral);</span>
 1016 |     | <span class='unexecuted'>        vault.exitAllPositions(0);</span>
 1017 |     | <span class='neutral'>    }</span>
 1018 |     | <span class='neutral'></span>
 1019 |     | <span class='unexecuted'>    function test_exitAllPositions_FailsIfEndBalanceIsLowerThanMin() public {</span>
 1020 |     | <span class='unexecuted'>        uint256 deposit = 1_000_000e6;</span>
 1021 |     | <span class='unexecuted'>        deal(address(usdc), alice, deposit);</span>
 1022 |     | <span class='neutral'></span>
 1023 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 1024 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
 1025 |     | <span class='unexecuted'>        vault.deposit(deposit, alice);</span>
 1026 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 1029 |     | <span class='unexecuted'>        vault.rebalance();</span>
 1030 |     | <span class='neutral'></span>
 1031 |     | <span class='neutral'>        // simulate 50% loss</span>
 1032 |     | <span class='unexecuted'>        uint256 wethInvested = weth.balanceOf(address(wethVault));</span>
 1033 |     | <span class='unexecuted'>        deal(address(weth), address(wethVault), wethInvested / 2);</span>
 1034 |     | <span class='neutral'></span>
 1035 |     | <span class='unexecuted'>        uint256 invalidEndUsdcBalanceMin = vault.totalAssets().mulWadDown(1.05e18);</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='unexecuted'>        vm.expectRevert(EndUsdcBalanceTooLow.selector);</span>
 1038 |     | <span class='unexecuted'>        vault.exitAllPositions(invalidEndUsdcBalanceMin);</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    /// #receiveFlashLoan ///</span>
 1042 |     | <span class='neutral'></span>
 1043 |     | <span class='unexecuted'>    function test_receiveFlashLoan_FailsIfCallerIsNotFlashLoaner() public {</span>
 1044 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 1045 |     | <span class='unexecuted'>        vm.expectRevert(InvalidFlashLoanCaller.selector);</span>
 1046 |     | <span class='unexecuted'>        address[] memory tokens = new address[](1);</span>
 1047 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1);</span>
 1048 |     | <span class='unexecuted'>        uint256[] memory feeAmounts = new uint256[](1);</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='unexecuted'>        vault.receiveFlashLoan(tokens, amounts, feeAmounts, bytes(&quot;0&quot;));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='unexecuted'>    function test_receiveFlashLoan_FailsIfInitiatorIsNotVault() public {</span>
 1054 |     | <span class='unexecuted'>        IVault balancer = IVault(C.BALANCER_VAULT);</span>
 1055 |     | <span class='unexecuted'>        address[] memory tokens = new address[](1);</span>
 1056 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1);</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='unexecuted'>        tokens[0] = address(weth);</span>
 1059 |     | <span class='unexecuted'>        amounts[0] = 100e18;</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='unexecuted'>        vm.expectRevert(InvalidFlashLoanCaller.selector);</span>
 1062 |     | <span class='unexecuted'>        balancer.flashLoan(address(vault), tokens, amounts, abi.encode(0, 0));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    /// internal helper functions ///</span>
 1066 |     | <span class='neutral'></span>
 1067 |     | <span class='unexecuted'>    function _createDefaultUsdcVaultConstructorParams(scWETH scWeth)</span>
 1068 |     | <span class='neutral'>        internal</span>
 1069 |     | <span class='neutral'>        view</span>
 1070 |     | <span class='neutral'>        returns (scUSDC.ConstructorParams memory)</span>
 1071 |     | <span class='neutral'>    {</span>
 1072 |     | <span class='unexecuted'>        return scUSDC.ConstructorParams({</span>
 1073 |     | <span class='unexecuted'>            admin: address(this),</span>
 1074 |     | <span class='neutral'>            keeper: keeper,</span>
 1075 |     | <span class='neutral'>            scWETH: scWeth,</span>
 1076 |     | <span class='neutral'>            usdc: ERC20(C.USDC),</span>
 1077 |     | <span class='neutral'>            weth: WETH(payable(C.WETH)),</span>
 1078 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
 1079 |     | <span class='neutral'>            aavePoolDataProvider: IPoolDataProvider(C.AAVE_POOL_DATA_PROVIDER),</span>
 1080 |     | <span class='neutral'>            aaveAUsdc: IAToken(C.AAVE_AUSDC_TOKEN),</span>
 1081 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
 1082 |     | <span class='neutral'>            uniswapSwapRouter: ISwapRouter(C.UNISWAP_V3_SWAP_ROUTER),</span>
 1083 |     | <span class='neutral'>            chainlinkUsdcToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_USDC_ETH_PRICE_FEED),</span>
 1084 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
 1085 |     | <span class='neutral'>        });</span>
 1086 |     | <span class='neutral'>    }</span>
 1087 |     | <span class='neutral'>}</span>
 1088 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/scUSDC.unit.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/console2.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ERC4626} from &quot;solmate/mixins/ERC4626.sol&quot;;</span>
   9 |     | <span class='neutral'>import {MockERC4626} from &quot;solmate/test/utils/mocks/MockERC4626.sol&quot;;</span>
  10 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  12 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  13 |     | <span class='neutral'>import {IPoolDataProvider} from &quot;aave-v3/interfaces/IPoolDataProvider.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>import {scUSDC} from &quot;../src/steth/scUSDC.sol&quot;;</span>
  16 |     | <span class='neutral'>import {ISwapRouter} from &quot;../src/interfaces/uniswap/ISwapRouter.sol&quot;;</span>
  17 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IVault} from &quot;../src/interfaces/balancer/IVault.sol&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>import {MockWETH} from &quot;./mocks/MockWETH.sol&quot;;</span>
  21 |     | <span class='neutral'>import {MockUSDC} from &quot;./mocks/MockUSDC.sol&quot;;</span>
  22 |     | <span class='neutral'>import {MockAavePool} from &quot;./mocks/aave-v3/MockAavePool.sol&quot;;</span>
  23 |     | <span class='neutral'>import {MockAavePoolDataProvider} from &quot;./mocks/aave-v3/MockAavePoolDataProvider.sol&quot;;</span>
  24 |     | <span class='neutral'>import {MockAUsdc} from &quot;./mocks/aave-v3/MockAUsdc.sol&quot;;</span>
  25 |     | <span class='neutral'>import {MockVarDebtWETH} from &quot;./mocks/aave-v3/MockVarDebtWETH.sol&quot;;</span>
  26 |     | <span class='neutral'>import {MockChainlinkPriceFeed} from &quot;./mocks/chainlink/MockChainlinkPriceFeed.sol&quot;;</span>
  27 |     | <span class='neutral'>import {MockBalancerVault} from &quot;./mocks/balancer/MockBalancerVault.sol&quot;;</span>
  28 |     | <span class='neutral'>import {MockSwapRouter} from &quot;./mocks/uniswap/MockSwapRouter.sol&quot;;</span>
  29 |     | <span class='unexecuted'></span>
  30 |     | <span class='neutral'>contract scUSDCUnitTest is Test {</span>
  31 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    address constant keeper = address(0x05);</span>
  34 |     | <span class='unexecuted'>    address constant alice = address(0x06);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    scUSDC vault;</span>
  37 |     | <span class='neutral'>    ERC4626 wethVault;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    MockUSDC usdc;</span>
  40 |     | <span class='neutral'>    MockWETH weth;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    IPoolDataProvider aavePoolDataProvider;</span>
  43 |     | <span class='neutral'>    MockAavePool aavePool;</span>
  44 |     | <span class='neutral'>    MockAUsdc aaveAUsdc;</span>
  45 |     | <span class='neutral'>    MockVarDebtWETH aaveVarDWeth;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    MockChainlinkPriceFeed usdcToEthPriceFeed;</span>
  48 |     | <span class='neutral'>    MockBalancerVault balancerVault;</span>
  49 |     | <span class='neutral'>    MockSwapRouter uniswapRouter;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function setUp() public {</span>
  52 |     | <span class='unexecuted'>        usdc = new MockUSDC();</span>
  53 |     | <span class='unexecuted'>        weth = new MockWETH();</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>        wethVault = new MockERC4626(weth, &quot;Mock WETH Vault&quot;, &quot;mWETH&quot;);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        aavePoolDataProvider = new MockAavePoolDataProvider(address(usdc), address(weth));</span>
  58 |     | <span class='unexecuted'>        usdcToEthPriceFeed = new MockChainlinkPriceFeed(address(usdc), address(weth), 0.001e18);</span>
  59 |     | <span class='unexecuted'>        aavePool = new MockAavePool();</span>
  60 |     | <span class='unexecuted'>        aavePool.setUsdcWethPriceFeed(usdcToEthPriceFeed, usdc, weth);</span>
  61 |     | <span class='unexecuted'>        aaveAUsdc = new MockAUsdc(aavePool, usdc);</span>
  62 |     | <span class='unexecuted'>        aaveVarDWeth = new MockVarDebtWETH(aavePool, weth);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>        balancerVault = new MockBalancerVault(weth);</span>
  65 |     | <span class='unexecuted'>        uniswapRouter = new MockSwapRouter();</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        scUSDC.ConstructorParams memory scUsdcParams = scUSDC.ConstructorParams({</span>
  68 |     | <span class='unexecuted'>            admin: address(this),</span>
  69 |     | <span class='neutral'>            keeper: keeper,</span>
  70 |     | <span class='unexecuted'>            scWETH: wethVault,</span>
  71 |     | <span class='unexecuted'>            usdc: usdc,</span>
  72 |     | <span class='unexecuted'>            weth: WETH(payable(weth)),</span>
  73 |     | <span class='unexecuted'>            aavePool: aavePool,</span>
  74 |     | <span class='unexecuted'>            aavePoolDataProvider: aavePoolDataProvider,</span>
  75 |     | <span class='unexecuted'>            aaveAUsdc: IAToken(address(aaveAUsdc)),</span>
  76 |     | <span class='unexecuted'>            aaveVarDWeth: ERC20(address(aaveVarDWeth)),</span>
  77 |     | <span class='neutral'>            uniswapSwapRouter: uniswapRouter,</span>
  78 |     | <span class='unexecuted'>            chainlinkUsdcToEthPriceFeed: usdcToEthPriceFeed,</span>
  79 |     | <span class='unexecuted'>            balancerVault: balancerVault</span>
  80 |     | <span class='neutral'>        });</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        vault = new scUSDC(scUsdcParams);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        weth.mint(address(aavePool), 100e18);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function test_rebalance() public {</span>
  88 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
  89 |     | <span class='unexecuted'>        deal(address(usdc), address(alice), amount);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  92 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
  93 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
  94 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  97 |     | <span class='unexecuted'>        vault.rebalance();</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.getCollateral(), amount.mulWadDown(0.99e18), 1, &quot;collateral&quot;);</span>
 100 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), 6.435e18, &quot;debt&quot;);</span>
 101 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), amount.mulWadUp(vault.floatPercentage()), &quot;float&quot;);</span>
 102 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), amount, 1, &quot;total assets&quot;);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function test_withdraw() public {</span>
 106 |     | <span class='unexecuted'>        uint256 depositAmount = 10000e6;</span>
 107 |     | <span class='unexecuted'>        deal(address(usdc), address(alice), depositAmount);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 110 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
 111 |     | <span class='unexecuted'>        vault.deposit(depositAmount, alice);</span>
 112 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 115 |     | <span class='unexecuted'>        vault.rebalance();</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 118 |     | <span class='unexecuted'>        uint256 withdrawAmount = 1000e6;</span>
 119 |     | <span class='unexecuted'>        vault.withdraw(1000e6, alice, alice);</span>
 120 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        assertEq(usdc.balanceOf(alice), withdrawAmount, &quot;alice usdc balance&quot;);</span>
 123 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.getCollateral(), (depositAmount - withdrawAmount).mulWadDown(0.99e18), 1, &quot;collateral&quot;); // - float</span>
 124 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), uint256(6.435e18).mulWadDown(0.9e18), &quot;debt&quot;);</span>
 125 |     | <span class='unexecuted'>        assertEq(vault.getUsdcBalance(), (depositAmount - withdrawAmount).mulWadUp(vault.floatPercentage()), &quot;float&quot;);</span>
 126 |     | <span class='unexecuted'>        assertApproxEqAbs(vault.totalAssets(), (depositAmount - withdrawAmount), 1, &quot;total assets&quot;);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function test_getCollateral_AccountsForInterestOnSuppliedUsdc() public {</span>
 130 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
 131 |     | <span class='unexecuted'>        deal(address(usdc), address(alice), amount);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 134 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
 135 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
 136 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 139 |     | <span class='unexecuted'>        vault.rebalance();</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        usdc.mint(address(this), 1_000_000e6);</span>
 142 |     | <span class='unexecuted'>        usdc.approve(address(aavePool), type(uint256).max);</span>
 143 |     | <span class='unexecuted'>        uint256 collateralBefore = vault.getCollateral();</span>
 144 |     | <span class='unexecuted'>        uint256 interest = 0.05e18;</span>
 145 |     | <span class='unexecuted'>        aavePool.addInterestOnSupply(address(vault), address(usdc), collateralBefore.mulWadDown(interest));</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), collateralBefore.mulWadDown(1e18 + interest), &quot;collateral with interest&quot;);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function test_getDebt_AccountsForInterestOnBorrowedWeth() public {</span>
 151 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
 152 |     | <span class='unexecuted'>        deal(address(usdc), address(alice), amount);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 155 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
 156 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
 157 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 160 |     | <span class='unexecuted'>        vault.rebalance();</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>        uint256 debtBefore = vault.getDebt();</span>
 163 |     | <span class='unexecuted'>        uint256 interest = 0.05e18;</span>
 164 |     | <span class='unexecuted'>        aavePool.addInterestOnDebt(address(vault), address(weth), debtBefore.mulWadDown(interest));</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), debtBefore.mulWadDown(1e18 + interest), &quot;debt with interest&quot;);</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='unexecuted'>    function test_getLtv() public {</span>
 170 |     | <span class='unexecuted'>        uint256 amount = 10000e6;</span>
 171 |     | <span class='unexecuted'>        deal(address(usdc), alice, amount);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 174 |     | <span class='unexecuted'>        usdc.approve(address(vault), type(uint256).max);</span>
 175 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
 176 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 179 |     | <span class='unexecuted'>        vault.rebalance();</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        aavePool.setUsdcWethPriceFeed(usdcToEthPriceFeed, usdc, weth);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        assertEq(vault.getLtv(), vault.targetLtv(), &quot;ltv&quot;);</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>    function test_getUsdcFromWeth_precisionLoss() public {</span>
 187 |     | <span class='unexecuted'>        uint256 wethAmount = 1e13;</span>
 188 |     | <span class='unexecuted'>        uint256 wethAmountPlusSome = wethAmount + 1e10; // a bit more</span>
 189 |     | <span class='unexecuted'>        usdcToEthPriceFeed.setLatestAnswer(512640446503388);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>        assertTrue(vault.getUsdcFromWeth(wethAmount) &lt; vault.getUsdcFromWeth(wethAmountPlusSome), &quot;precision loss&quot;);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/scWETH.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;forge-std/console2.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import {DSTestPlus} from &quot;solmate/test/utils/DSTestPlus.sol&quot;;</span>
   8 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
   9 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IVariableDebtToken} from &quot;aave-v3/interfaces/IVariableDebtToken.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Errors} from &quot;aave-v3/protocol/libraries/helpers/Errors.sol&quot;;</span>
  13 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>import {Constants as C} from &quot;../src/lib/Constants.sol&quot;;</span>
  16 |     | <span class='neutral'>import {scWETH} from &quot;../src/steth/scWETH.sol&quot;;</span>
  17 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
  18 |     | <span class='neutral'>import {ILido} from &quot;../src/interfaces/lido/ILido.sol&quot;;</span>
  19 |     | <span class='neutral'>import {IwstETH} from &quot;../src/interfaces/lido/IwstETH.sol&quot;;</span>
  20 |     | <span class='neutral'>import {ICurvePool} from &quot;../src/interfaces/curve/ICurvePool.sol&quot;;</span>
  21 |     | <span class='neutral'>import {IVault} from &quot;../src/interfaces/balancer/IVault.sol&quot;;</span>
  22 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  23 |     | <span class='neutral'>import {sc4626} from &quot;../src/sc4626.sol&quot;;</span>
  24 |     | <span class='neutral'>import &quot;../src/errors/scErrors.sol&quot;;</span>
  25 |     | <span class='unexecuted'></span>
  26 |     | <span class='neutral'>contract scWETHTest is Test {</span>
  27 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    uint256 mainnetFork;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    address constant keeper = address(0x05);</span>
  32 |     | <span class='unexecuted'>    address constant alice = address(0x06);</span>
  33 |     | <span class='unexecuted'>    address constant treasury = address(0x07);</span>
  34 |     | <span class='unexecuted'>    uint256 boundMinimum = 1e10; // below this amount, aave doesn&#39;t count it as collateral</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    address admin = address(this);</span>
  37 |     | <span class='neutral'>    scWETH vault;</span>
  38 |     | <span class='unexecuted'>    uint256 initAmount = 100e18;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    WETH weth;</span>
  41 |     | <span class='neutral'>    ILido stEth;</span>
  42 |     | <span class='neutral'>    IwstETH wstEth;</span>
  43 |     | <span class='neutral'>    IAToken aToken;</span>
  44 |     | <span class='neutral'>    ERC20 debtToken;</span>
  45 |     | <span class='neutral'>    IPool aavePool;</span>
  46 |     | <span class='neutral'>    ICurvePool curvePool;</span>
  47 |     | <span class='unexecuted'>    uint256 slippageTolerance = 0.99e18;</span>
  48 |     | <span class='neutral'>    uint256 maxLtv;</span>
  49 |     | <span class='unexecuted'>    uint256 targetLtv = 0.7e18;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function setUp() public {</span>
  52 |     | <span class='unexecuted'>        vm.createFork(vm.envString(&quot;RPC_URL_MAINNET&quot;));</span>
  53 |     | <span class='unexecuted'>        vm.selectFork(mainnetFork);</span>
  54 |     | <span class='unexecuted'>        vm.rollFork(16784444);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory params = _createDefaultWethVaultConstructorParams();</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>        vault = new scWETH(params);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        // set vault eth balance to zero</span>
  61 |     | <span class='unexecuted'>        vm.deal(address(vault), 0);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        weth = vault.weth();</span>
  64 |     | <span class='unexecuted'>        stEth = vault.stEth();</span>
  65 |     | <span class='unexecuted'>        wstEth = vault.wstETH();</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        maxLtv = vault.getMaxLtv();</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        aToken = vault.aToken();</span>
  70 |     | <span class='unexecuted'>        debtToken = vault.variableDebtToken();</span>
  71 |     | <span class='unexecuted'>        aavePool = vault.aavePool();</span>
  72 |     | <span class='unexecuted'>        curvePool = vault.curvePool();</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function test_constructor() public {</span>
  76 |     | <span class='unexecuted'>        assertEq(aavePool.getUserEMode(address(vault)), 1, &quot;Efficiency mode not 1&quot;);</span>
  77 |     | <span class='unexecuted'>        assertEq(vault.treasury(), admin, &quot;treasury not set&quot;);</span>
  78 |     | <span class='unexecuted'>        assertEq(vault.hasRole(vault.DEFAULT_ADMIN_ROLE(), admin), true, &quot;admin role not set&quot;);</span>
  79 |     | <span class='unexecuted'>        assertEq(vault.hasRole(vault.KEEPER_ROLE(), keeper), true, &quot;keeper role not set&quot;);</span>
  80 |     | <span class='unexecuted'>        assertEq(vault.targetLtv(), targetLtv, &quot;targetLtv not set&quot;);</span>
  81 |     | <span class='unexecuted'>        assertEq(vault.slippageTolerance(), slippageTolerance, &quot;slippageTolerance not set&quot;);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function test_constructor_invalidAdmin() public {</span>
  85 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory params = _createDefaultWethVaultConstructorParams();</span>
  86 |     | <span class='unexecuted'>        params.admin = address(0x00); // invalid address</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        vm.expectRevert(ZeroAddress.selector);</span>
  89 |     | <span class='neutral'>        vault = new scWETH(params);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function test_constructor_invalidKeeper() public {</span>
  93 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory params = _createDefaultWethVaultConstructorParams();</span>
  94 |     | <span class='unexecuted'>        params.keeper = address(0x00); // invalid address</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        vm.expectRevert(ZeroAddress.selector);</span>
  97 |     | <span class='unexecuted'>        vault = new scWETH(params);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function test_constructor_invalidTargetLtv() public {</span>
 101 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory params = _createDefaultWethVaultConstructorParams();</span>
 102 |     | <span class='unexecuted'>        params.targetLtv = 0.9e18; // invalid target ltv</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        vm.expectRevert(InvalidTargetLtv.selector);</span>
 105 |     | <span class='neutral'>        vault = new scWETH(params);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function test_constructor_invalidSlippageTolerance() public {</span>
 109 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory params = _createDefaultWethVaultConstructorParams();</span>
 110 |     | <span class='unexecuted'>        params.slippageTolerance = 1.01e18; // invalid slippage tolerance</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        vm.expectRevert(InvalidSlippageTolerance.selector);</span>
 113 |     | <span class='neutral'>        vault = new scWETH(params);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>    function test_setPerformanceFee() public {</span>
 117 |     | <span class='unexecuted'>        uint256 fee = 1000;</span>
 118 |     | <span class='unexecuted'>        vault.setPerformanceFee(fee);</span>
 119 |     | <span class='unexecuted'>        assertEq(vault.performanceFee(), fee);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        // revert if called by another user</span>
 122 |     | <span class='unexecuted'>        vm.expectRevert(0x06d919f2);</span>
 123 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 124 |     | <span class='unexecuted'>        vault.setPerformanceFee(fee);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        vm.expectRevert(FeesTooHigh.selector);</span>
 127 |     | <span class='unexecuted'>        vault.setPerformanceFee(1.1e18);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>    function test_setTreasury() public {</span>
 131 |     | <span class='neutral'>        address newTreasury = alice;</span>
 132 |     | <span class='unexecuted'>        vault.setTreasury(newTreasury);</span>
 133 |     | <span class='unexecuted'>        assertEq(vault.treasury(), newTreasury);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>        // revert if called by another user</span>
 136 |     | <span class='unexecuted'>        vm.expectRevert(0x06d919f2);</span>
 137 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 138 |     | <span class='unexecuted'>        vault.setTreasury(address(this));</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        vm.expectRevert(TreasuryCannotBeZero.selector);</span>
 141 |     | <span class='unexecuted'>        vault.setTreasury(address(0x00));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function test_setSlippageTolerance() public {</span>
 145 |     | <span class='unexecuted'>        vault.setSlippageTolerance(0.5e18);</span>
 146 |     | <span class='unexecuted'>        assertEq(vault.slippageTolerance(), 0.5e18, &quot;slippageTolerance not set&quot;);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>        // revert if called by another user</span>
 149 |     | <span class='unexecuted'>        vm.expectRevert(CallerNotAdmin.selector);</span>
 150 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 151 |     | <span class='unexecuted'>        vault.setSlippageTolerance(0.5e18);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        vm.expectRevert(InvalidSlippageTolerance.selector);</span>
 154 |     | <span class='unexecuted'>        vault.setSlippageTolerance(1.1e18);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>    function test_setStEThToEthPriceFeed() public {</span>
 158 |     | <span class='neutral'>        address newStEthPriceFeed = alice;</span>
 159 |     | <span class='unexecuted'>        vault.setStEThToEthPriceFeed(newStEthPriceFeed);</span>
 160 |     | <span class='unexecuted'>        assertEq(address(vault.stEThToEthPriceFeed()), newStEthPriceFeed);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        // revert if called by another user</span>
 163 |     | <span class='unexecuted'>        vm.expectRevert(CallerNotAdmin.selector);</span>
 164 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 165 |     | <span class='unexecuted'>        vault.setStEThToEthPriceFeed(newStEthPriceFeed);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        vm.expectRevert(ZeroAddress.selector);</span>
 168 |     | <span class='unexecuted'>        vault.setStEThToEthPriceFeed(address(0x00));</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function test_deposit_redeem(uint256 amount) public {</span>
 172 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e27);</span>
 173 |     | <span class='unexecuted'>        vm.deal(address(this), amount);</span>
 174 |     | <span class='unexecuted'>        weth.deposit{value: amount}();</span>
 175 |     | <span class='unexecuted'>        weth.approve(address(vault), amount);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        uint256 preDepositBal = weth.balanceOf(address(this));</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>        vault.deposit(amount, address(this));</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        _depositChecks(amount, preDepositBal);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        vault.redeem(vault.balanceOf(address(this)), address(this), address(this));</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>        _redeemChecks(preDepositBal);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>    function testFail_Deposit_WithInsufficientApproval(uint256 amount) public {</span>
 189 |     | <span class='unexecuted'>        vm.deal(address(this), amount / 2);</span>
 190 |     | <span class='unexecuted'>        weth.deposit{value: amount / 2}();</span>
 191 |     | <span class='unexecuted'>        weth.approve(address(vault), amount / 2);</span>
 192 |     | <span class='unexecuted'>        vault.deposit(amount, address(this));</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function testFail_Withdraw(uint256 amount) public {</span>
 196 |     | <span class='unexecuted'>        vm.deal(address(this), amount / 2);</span>
 197 |     | <span class='unexecuted'>        weth.deposit{value: amount / 2}();</span>
 198 |     | <span class='unexecuted'>        weth.approve(address(vault), amount / 2);</span>
 199 |     | <span class='unexecuted'>        vault.deposit(amount / 2, address(this));</span>
 200 |     | <span class='unexecuted'>        vault.withdraw(amount, address(this), address(this));</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>    function testFail_Redeem_WithInsufficientBalance(uint256 amount) public {</span>
 204 |     | <span class='unexecuted'>        vm.deal(address(this), amount / 2);</span>
 205 |     | <span class='unexecuted'>        weth.deposit{value: amount / 2}();</span>
 206 |     | <span class='unexecuted'>        weth.approve(address(vault), amount / 2);</span>
 207 |     | <span class='unexecuted'>        vault.deposit(amount / 2, address(this));</span>
 208 |     | <span class='unexecuted'>        vault.redeem(amount, address(this), address(this));</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function testFail_Withdraw_WithNoBalance(uint256 amount) public {</span>
 212 |     | <span class='unexecuted'>        if (amount == 0) amount = 1;</span>
 213 |     | <span class='unexecuted'>        vault.withdraw(amount, address(this), address(this));</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>    function testFail_Redeem_WithNoBalance(uint256 amount) public {</span>
 217 |     | <span class='unexecuted'>        vault.redeem(amount, address(this), address(this));</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='unexecuted'>    function testFail_Deposit_WithNoApproval(uint256 amount) public {</span>
 221 |     | <span class='unexecuted'>        vault.deposit(amount, address(this));</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='unexecuted'>    function test_atomic_deposit_invest_redeem(uint256 amount) public {</span>
 225 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e22); //max ~$280m flashloan</span>
 226 |     | <span class='unexecuted'>        vm.deal(address(this), amount);</span>
 227 |     | <span class='unexecuted'>        weth.deposit{value: amount}();</span>
 228 |     | <span class='unexecuted'>        weth.approve(address(vault), amount);</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>        uint256 preDepositBal = weth.balanceOf(address(this));</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>        uint256 shares = vault.deposit(amount, address(this));</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>        _depositChecks(amount, preDepositBal);</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 237 |     | <span class='unexecuted'>        vault.harvest();</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>        // account for value loss if stETH worth less than ETH</span>
 240 |     | <span class='unexecuted'>        (, int256 price,,,) = vault.stEThToEthPriceFeed().latestRoundData();</span>
 241 |     | <span class='unexecuted'>        amount = amount.mulWadDown(uint256(price));</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>        // account for unrealized slippage loss</span>
 244 |     | <span class='unexecuted'>        amount = amount.mulWadDown(slippageTolerance);</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), amount, 0.01e18);</span>
 247 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(address(this)), shares);</span>
 248 |     | <span class='unexecuted'>        assertApproxEqRel(vault.convertToAssets(vault.balanceOf(address(this))), amount, 0.01e18);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='unexecuted'>        vault.redeem(shares, address(this), address(this));</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(10 ** vault.decimals()), 1e18);</span>
 253 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(address(this)), 0);</span>
 254 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);</span>
 255 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(address(this)), amount, 0.01e18);</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>    function test_twoDeposits_invest_twoRedeems(uint256 depositAmount1, uint256 depositAmount2) public {</span>
 259 |     | <span class='unexecuted'>        depositAmount1 = bound(depositAmount1, boundMinimum, 10000 ether);</span>
 260 |     | <span class='unexecuted'>        depositAmount2 = bound(depositAmount2, boundMinimum, 10000 ether);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>        uint256 minDelta = 0.017e18;</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>        uint256 shares1 = _depositToVault(address(this), depositAmount1);</span>
 265 |     | <span class='unexecuted'>        uint256 shares2 = _depositToVault(alice, depositAmount2);</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 268 |     | <span class='unexecuted'>        vault.harvest();</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        uint256 ltv = vault.targetLtv();</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>        uint256 expectedRedeem = vault.previewRedeem(shares1 / 2);</span>
 273 |     | <span class='unexecuted'>        vault.redeem(shares1 / 2, address(this), address(this));</span>
 274 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(address(this)), expectedRedeem, minDelta, &quot;redeem1&quot;);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), ltv, 0.013e18, &quot;ltv&quot;);</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='unexecuted'>        expectedRedeem = vault.previewRedeem(shares2 / 2);</span>
 279 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 280 |     | <span class='unexecuted'>        vault.redeem(shares2 / 2, alice, alice);</span>
 281 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(alice), expectedRedeem, minDelta, &quot;redeem2&quot;);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), ltv, 0.01e18, &quot;ltv&quot;);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        uint256 initBalance = weth.balanceOf(address(this));</span>
 286 |     | <span class='unexecuted'>        expectedRedeem = vault.previewRedeem(shares1 / 2);</span>
 287 |     | <span class='unexecuted'>        vault.redeem(vault.balanceOf(address(this)), address(this), address(this));</span>
 288 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(address(this)) - initBalance, expectedRedeem, minDelta, &quot;redeem3&quot;);</span>
 289 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), ltv, 0.01e18, &quot;ltv&quot;);</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='unexecuted'>        initBalance = weth.balanceOf(alice);</span>
 292 |     | <span class='unexecuted'>        expectedRedeem = vault.previewRedeem(shares2 / 2);</span>
 293 |     | <span class='unexecuted'>        uint256 remainingShares = vault.balanceOf(alice);</span>
 294 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 295 |     | <span class='unexecuted'>        vault.redeem(remainingShares, alice, alice);</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(alice) - initBalance, expectedRedeem, 0.025e18, &quot;redeem4&quot;);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>        assertEq(vault.getLtv(), 0);</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_higherLtv(uint256 amount, uint256 newLtv) public {</span>
 303 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e20);</span>
 304 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 307 |     | <span class='unexecuted'>        vault.harvest();</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='unexecuted'>        newLtv = bound(newLtv, vault.getLtv() + 1e15, maxLtv - 0.001e18);</span>
 310 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(newLtv);</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), newLtv, 0.01e18, &quot;leverage change failed&quot;);</span>
 313 |     | <span class='neutral'>    }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_lowerLtv(uint256 amount, uint256 newLtv) public {</span>
 316 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e20);</span>
 317 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 320 |     | <span class='unexecuted'>        vault.harvest();</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='unexecuted'>        newLtv = bound(newLtv, 0.01e18, vault.getLtv() - 0.01e18);</span>
 323 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(newLtv);</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        // some amount will be left in vault, unrealized slippage</span>
 326 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), newLtv, 0.03e18, &quot;leverage change failed&quot;);</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='unexecuted'>    function test_applyNewTargetLtv_invalidMaxLtv() public {</span>
 330 |     | <span class='unexecuted'>        uint256 amount = 100 ether;</span>
 331 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 334 |     | <span class='unexecuted'>        vault.harvest();</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>        vm.expectRevert(InvalidTargetLtv.selector);</span>
 337 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(maxLtv + 1);</span>
 338 |     | <span class='unexecuted'>        vm.expectRevert(InvalidTargetLtv.selector);</span>
 339 |     | <span class='unexecuted'>        vault.applyNewTargetLtv(maxLtv);</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='unexecuted'>    function test_receiveFlashLoan_InvalidFlashLoanCaller() public {</span>
 343 |     | <span class='unexecuted'>        address[] memory empty;</span>
 344 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint[](1);</span>
 345 |     | <span class='unexecuted'>        amounts[0] = 1;</span>
 346 |     | <span class='unexecuted'>        vm.expectRevert(InvalidFlashLoanCaller.selector);</span>
 347 |     | <span class='unexecuted'>        vault.receiveFlashLoan(empty, amounts, amounts, abi.encode(1));</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='unexecuted'>    function test_receiveFlashLoan_FailsIfInitiatorIsNotVault() public {</span>
 351 |     | <span class='unexecuted'>        IVault balancer = IVault(C.BALANCER_VAULT);</span>
 352 |     | <span class='unexecuted'>        address[] memory tokens = new address[](1);</span>
 353 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1);</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='unexecuted'>        tokens[0] = address(weth);</span>
 356 |     | <span class='unexecuted'>        amounts[0] = 100e18;</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        vm.expectRevert(InvalidFlashLoanCaller.selector);</span>
 359 |     | <span class='unexecuted'>        balancer.flashLoan(address(vault), tokens, amounts, abi.encode(0, 0));</span>
 360 |     | <span class='neutral'>    }</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='unexecuted'>    function test_maxLtv(uint256 amount) public {</span>
 363 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e21);</span>
 364 |     | <span class='unexecuted'>        vm.deal(address(this), amount);</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='unexecuted'>        aavePool.setUserEMode(1);</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='unexecuted'>        stEth.approve(address(wstEth), type(uint256).max);</span>
 369 |     | <span class='unexecuted'>        stEth.approve(address(curvePool), type(uint256).max);</span>
 370 |     | <span class='unexecuted'>        wstEth.approve(address(aavePool), type(uint256).max);</span>
 371 |     | <span class='unexecuted'>        weth.approve(address(aavePool), type(uint256).max);</span>
 372 |     | <span class='unexecuted'>        stEth.submit{value: amount}(address(0));</span>
 373 |     | <span class='unexecuted'>        wstEth.wrap(stEth.balanceOf(address(this)));</span>
 374 |     | <span class='unexecuted'>        aavePool.supply(address(wstEth), wstEth.balanceOf(address(this)), address(this), 0);</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>        // borrow at max ltv should fail</span>
 377 |     | <span class='unexecuted'>        vm.expectRevert(bytes(Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW));</span>
 378 |     | <span class='unexecuted'>        aavePool.borrow(address(weth), amount.mulWadDown(maxLtv), 2, 0, address(this));</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>        // borrow at a little less than maxLtv should pass without errors</span>
 381 |     | <span class='unexecuted'>        aavePool.borrow(address(weth), amount.mulWadDown(maxLtv - 1e16), 2, 0, address(this));</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='unexecuted'>    function test_withdraw_revert() public {</span>
 385 |     | <span class='unexecuted'>        vm.expectRevert(PleaseUseRedeemMethod.selector);</span>
 386 |     | <span class='unexecuted'>        vault.withdraw(1e18, address(this), address(this));</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='unexecuted'>    function test_harvest(uint256 amount, uint64 tP) public {</span>
 390 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e21);</span>
 391 |     | <span class='neutral'>        // simulate wstETH supply interest to EULER</span>
 392 |     | <span class='unexecuted'>        uint256 timePeriod = bound(tP, 260 days, 365 days);</span>
 393 |     | <span class='unexecuted'>        uint256 annualPeriod = 365 days;</span>
 394 |     | <span class='unexecuted'>        uint256 stEthStakingApy = 0.071e18;</span>
 395 |     | <span class='unexecuted'>        uint256 stEthStakingInterest = 1e18 + stEthStakingApy.mulDivDown(timePeriod, annualPeriod);</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 400 |     | <span class='unexecuted'>        vault.harvest();</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(timePeriod, stEthStakingInterest);</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='unexecuted'>        assertEq(vault.totalProfit(), 0);</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 407 |     | <span class='unexecuted'>        vault.harvest();</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='unexecuted'>        uint256 minimumExpectedApy = 0.07e18;</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='unexecuted'>        assertGt(</span>
 412 |     | <span class='unexecuted'>            vault.totalProfit(),</span>
 413 |     | <span class='unexecuted'>            amount.mulWadDown(minimumExpectedApy.mulDivDown(timePeriod, annualPeriod)),</span>
 414 |     | <span class='neutral'>            &quot;atleast 7% APY&quot;</span>
 415 |     | <span class='neutral'>        );</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='unexecuted'>        vault.redeem(vault.balanceOf(address(this)), address(this), address(this));</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='unexecuted'>        assertGt(</span>
 420 |     | <span class='unexecuted'>            weth.balanceOf(address(this)) - amount,</span>
 421 |     | <span class='unexecuted'>            amount.mulWadDown(minimumExpectedApy.mulDivDown(timePeriod, annualPeriod)),</span>
 422 |     | <span class='neutral'>            &quot;atleast 7% APY after withdraw&quot;</span>
 423 |     | <span class='neutral'>        );</span>
 424 |     | <span class='neutral'>    }</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='unexecuted'>    function test_withdrawToVault(uint256 amount) public {</span>
 427 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 10000 ether);</span>
 428 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 431 |     | <span class='unexecuted'>        vault.harvest();</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='unexecuted'>        _withdrawToVaultChecks(0.018e18);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='unexecuted'>    function test_harvest_withdrawToVault() public {</span>
 437 |     | <span class='neutral'>        // amount = bound(amount, boundMinimum, 10000 ether);</span>
 438 |     | <span class='unexecuted'>        uint256 amount = 10000 ether;</span>
 439 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 442 |     | <span class='unexecuted'>        vault.harvest();</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 1.071e18);</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='unexecuted'>        vault.harvest();</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>        // harvest must automatically rebalance</span>
 449 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), vault.targetLtv(), 0.001e18, &quot;ltv not rebalanced&quot;);</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='unexecuted'>        _withdrawToVaultChecks(0.025e18);</span>
 452 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='unexecuted'>        uint256 minimumExpectedApy = 0.05e18;</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='unexecuted'>        assertGt(vault.totalProfit(), amount.mulWadDown(minimumExpectedApy), &quot;atleast 5% APY&quot;);</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='unexecuted'>        vault.redeem(vault.balanceOf(address(this)), address(this), address(this));</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='unexecuted'>        assertGt(</span>
 461 |     | <span class='unexecuted'>            weth.balanceOf(address(this)) - amount,</span>
 462 |     | <span class='unexecuted'>            amount.mulWadDown(minimumExpectedApy - 0.005e18),</span>
 463 |     | <span class='neutral'>            &quot;atleast 5% APY after withdraw&quot;</span>
 464 |     | <span class='neutral'>        );</span>
 465 |     | <span class='neutral'>    }</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='unexecuted'>    function test_harvest_performanceFees(uint256 amount) public {</span>
 468 |     | <span class='unexecuted'>        vault.setTreasury(treasury);</span>
 469 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 10000 ether);</span>
 470 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 473 |     | <span class='unexecuted'>        vault.harvest();</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 1.071e18);</span>
 476 |     | <span class='unexecuted'>        vault.harvest();</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='unexecuted'>        uint256 balance = vault.convertToAssets(vault.balanceOf(treasury));</span>
 479 |     | <span class='unexecuted'>        uint256 profit = vault.totalProfit();</span>
 480 |     | <span class='unexecuted'>        assertApproxEqRel(balance, profit.mulWadDown(vault.performanceFee()), 0.015e18);</span>
 481 |     | <span class='neutral'>    }</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='unexecuted'>    function test_mint_redeem(uint256 amount) public {</span>
 484 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e27);</span>
 485 |     | <span class='unexecuted'>        vm.deal(address(this), amount);</span>
 486 |     | <span class='unexecuted'>        weth.deposit{value: amount}();</span>
 487 |     | <span class='unexecuted'>        weth.approve(address(vault), amount);</span>
 488 |     | <span class='neutral'></span>
 489 |     | <span class='unexecuted'>        uint256 preDepositBal = weth.balanceOf(address(this));</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='unexecuted'>        uint256 shares = vault.previewMint(amount);</span>
 492 |     | <span class='unexecuted'>        vault.mint(shares, address(this));</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='unexecuted'>        _depositChecks(amount, preDepositBal);</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='unexecuted'>        vault.redeem(vault.balanceOf(address(this)), address(this), address(this));</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='unexecuted'>        _redeemChecks(preDepositBal);</span>
 499 |     | <span class='neutral'>    }</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='unexecuted'>    function test_mint_invest_redeem(uint256 amount) public {</span>
 502 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e22); //max ~$280m flashloan</span>
 503 |     | <span class='unexecuted'>        vm.deal(address(this), amount);</span>
 504 |     | <span class='unexecuted'>        weth.deposit{value: amount}();</span>
 505 |     | <span class='unexecuted'>        weth.approve(address(vault), amount);</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='unexecuted'>        uint256 shares = vault.previewMint(amount);</span>
 508 |     | <span class='unexecuted'>        vault.mint(shares, address(this));</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 511 |     | <span class='unexecuted'>        vault.harvest();</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='neutral'>        // account for value loss if stETH worth less than ETH</span>
 514 |     | <span class='unexecuted'>        (, int256 price,,,) = vault.stEThToEthPriceFeed().latestRoundData();</span>
 515 |     | <span class='unexecuted'>        amount = amount.mulWadDown(uint256(price));</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='neutral'>        // account for unrealized slippage loss</span>
 518 |     | <span class='unexecuted'>        amount = amount.mulWadDown(slippageTolerance);</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalAssets(), amount, 0.01e18);</span>
 521 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(address(this)), shares);</span>
 522 |     | <span class='unexecuted'>        assertApproxEqRel(vault.convertToAssets(vault.balanceOf(address(this))), amount, 0.01e18);</span>
 523 |     | <span class='neutral'></span>
 524 |     | <span class='unexecuted'>        vault.redeem(shares, address(this), address(this));</span>
 525 |     | <span class='neutral'></span>
 526 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(10 ** vault.decimals()), 1e18);</span>
 527 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(address(this)), 0);</span>
 528 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);</span>
 529 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(address(this)), amount, 0.01e18);</span>
 530 |     | <span class='neutral'>    }</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='unexecuted'>    function test_mint_invest_harvest_redeem(uint256 amount) public {</span>
 533 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 534 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e22); //max ~$280m flashloan</span>
 535 |     | <span class='unexecuted'>        vm.deal(alice, amount);</span>
 536 |     | <span class='unexecuted'>        weth.deposit{value: amount}();</span>
 537 |     | <span class='unexecuted'>        weth.approve(address(vault), amount);</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='unexecuted'>        uint256 shares = vault.previewMint(amount);</span>
 540 |     | <span class='unexecuted'>        vault.mint(shares, alice);</span>
 541 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 544 |     | <span class='unexecuted'>        vault.harvest();</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='unexecuted'>        uint256 interest = 1.071e18;</span>
 547 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, interest);</span>
 548 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 549 |     | <span class='unexecuted'>        vault.harvest();</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 552 |     | <span class='unexecuted'>        vault.redeem(shares, alice, alice);</span>
 553 |     | <span class='neutral'></span>
 554 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(alice), 0);</span>
 555 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);</span>
 556 |     | <span class='unexecuted'>        assertGt(weth.balanceOf(alice), amount, &quot;no profits after harvest&quot;);</span>
 557 |     | <span class='neutral'>    }</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='unexecuted'>    function test_deposit_eth(uint256 amount) public {</span>
 560 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e21);</span>
 561 |     | <span class='unexecuted'>        vm.deal(address(this), amount);</span>
 562 |     | <span class='neutral'></span>
 563 |     | <span class='unexecuted'>        assertEq(weth.balanceOf(address(this)), 0);</span>
 564 |     | <span class='unexecuted'>        assertEq(address(this).balance, amount);</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='unexecuted'>        vault.deposit{value: amount}(address(this));</span>
 567 |     | <span class='neutral'></span>
 568 |     | <span class='unexecuted'>        assertEq(address(this).balance, 0, &quot;eth not transferred from user&quot;);</span>
 569 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(address(this)), amount, &quot;shares not minted&quot;);</span>
 570 |     | <span class='unexecuted'>        assertEq(weth.balanceOf(address(vault)), amount, &quot;weth not transferred to vault&quot;);</span>
 571 |     | <span class='neutral'>    }</span>
 572 |     | <span class='neutral'></span>
 573 |     | <span class='unexecuted'>    function test_deposit_rebalance_deposit_rebalance() public {</span>
 574 |     | <span class='unexecuted'>        vault.setTreasury(treasury);</span>
 575 |     | <span class='unexecuted'>        uint256 amount = 100 ether;</span>
 576 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 577 |     | <span class='neutral'></span>
 578 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 579 |     | <span class='unexecuted'>        vault.harvest();</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(treasury), 0, &quot;profit must be zero&quot;);</span>
 582 |     | <span class='unexecuted'>        assertEq(vault.totalProfit(), 0, &quot;profit must be zero&quot;);</span>
 583 |     | <span class='neutral'></span>
 584 |     | <span class='unexecuted'>        _depositToVault(alice, amount);</span>
 585 |     | <span class='neutral'></span>
 586 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 587 |     | <span class='unexecuted'>        vault.harvest();</span>
 588 |     | <span class='neutral'></span>
 589 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(treasury), 0, &quot;profit must be zero&quot;);</span>
 590 |     | <span class='unexecuted'>        assertEq(vault.totalProfit(), 0, &quot;profit must be zero&quot;);</span>
 591 |     | <span class='neutral'>    }</span>
 592 |     | <span class='neutral'></span>
 593 |     | <span class='unexecuted'>    function test_disinvest_invest_should_not_increase_invested(uint256 amount) public {</span>
 594 |     | <span class='unexecuted'>        vault.setTreasury(treasury);</span>
 595 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e21);</span>
 596 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 597 |     | <span class='neutral'></span>
 598 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 599 |     | <span class='unexecuted'>        vault.harvest();</span>
 600 |     | <span class='neutral'></span>
 601 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(treasury), 0, &quot;profit must be zero&quot;);</span>
 602 |     | <span class='unexecuted'>        assertEq(vault.totalProfit(), 0, &quot;profit must be zero&quot;);</span>
 603 |     | <span class='neutral'></span>
 604 |     | <span class='unexecuted'>        _depositToVault(alice, amount);</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 607 |     | <span class='unexecuted'>        vault.harvest();</span>
 608 |     | <span class='neutral'></span>
 609 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(treasury), 0, &quot;profit must be zero&quot;);</span>
 610 |     | <span class='unexecuted'>        assertEq(vault.totalProfit(), 0, &quot;profit must be zero&quot;);</span>
 611 |     | <span class='neutral'></span>
 612 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 613 |     | <span class='unexecuted'>        uint256 all = vault.totalInvested();</span>
 614 |     | <span class='unexecuted'>        vault.withdrawToVault(all);</span>
 615 |     | <span class='unexecuted'>        vault.harvest();</span>
 616 |     | <span class='unexecuted'>        assertApproxEqRel(all, vault.totalInvested(), 0.01e18);</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='unexecuted'>        all = vault.totalInvested();</span>
 619 |     | <span class='unexecuted'>        vault.withdrawToVault(all);</span>
 620 |     | <span class='unexecuted'>        vault.harvest();</span>
 621 |     | <span class='unexecuted'>        assertApproxEqRel(all, vault.totalInvested(), 0.01e18);</span>
 622 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(treasury), 0, &quot;profit must be zero&quot;);</span>
 623 |     | <span class='unexecuted'>        assertEq(vault.totalProfit(), 0, &quot;profit must be zero&quot;);</span>
 624 |     | <span class='neutral'>    }</span>
 625 |     | <span class='neutral'></span>
 626 |     | <span class='neutral'>    // harvest should never count new deposits as profit</span>
 627 |     | <span class='unexecuted'>    function test_deposit_profit_deposit_harvest(uint256 amount) public {</span>
 628 |     | <span class='unexecuted'>        vault.setTreasury(treasury);</span>
 629 |     | <span class='unexecuted'>        amount = bound(amount, boundMinimum, 1e20);</span>
 630 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 631 |     | <span class='neutral'></span>
 632 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 633 |     | <span class='unexecuted'>        vault.harvest();</span>
 634 |     | <span class='neutral'></span>
 635 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(treasury), 0, &quot;profit must be zero&quot;);</span>
 636 |     | <span class='unexecuted'>        assertEq(vault.totalProfit(), 0, &quot;profit must be zero&quot;);</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='unexecuted'>        uint256 invested = vault.totalAssets();</span>
 639 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 1.071e18);</span>
 640 |     | <span class='unexecuted'>        uint256 profit = vault.totalAssets() - invested;</span>
 641 |     | <span class='unexecuted'>        console.log(&quot;vault.totalProfit()&quot;, vault.totalProfit());</span>
 642 |     | <span class='unexecuted'>        console.log(&quot;profit&quot;, profit);</span>
 643 |     | <span class='unexecuted'>        _depositToVault(alice, amount);</span>
 644 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 645 |     | <span class='unexecuted'>        vault.harvest();</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>        // new deposits should not increase profits</span>
 648 |     | <span class='unexecuted'>        assertGt(profit, vault.totalProfit());</span>
 649 |     | <span class='neutral'>    }</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='unexecuted'>    function test_deposit_rebalance_deposit_rebalance_withSimulatedProfits() public {</span>
 652 |     | <span class='unexecuted'>        vault.setTreasury(treasury);</span>
 653 |     | <span class='unexecuted'>        uint256 deposit1 = 10 ether;</span>
 654 |     | <span class='unexecuted'>        uint256 deposit2 = deposit1 * 10;</span>
 655 |     | <span class='unexecuted'>        uint256 deposit3 = deposit1 * 50;</span>
 656 |     | <span class='unexecuted'>        _depositToVault(address(this), deposit1);</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 659 |     | <span class='unexecuted'>        vault.harvest();</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 1.071e18);</span>
 662 |     | <span class='neutral'></span>
 663 |     | <span class='unexecuted'>        _depositToVault(alice, deposit2);</span>
 664 |     | <span class='unexecuted'>        uint256 slippage = vault.totalAssets();</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 667 |     | <span class='unexecuted'>        vault.harvest();</span>
 668 |     | <span class='unexecuted'>        slippage -= vault.totalAssets();</span>
 669 |     | <span class='neutral'></span>
 670 |     | <span class='unexecuted'>        uint256 profit1 = vault.totalProfit();</span>
 671 |     | <span class='neutral'></span>
 672 |     | <span class='unexecuted'>        assertApproxEqRel(profit1, deposit1.mulWadDown(0.15e18) - slippage, 0.1e18);</span>
 673 |     | <span class='neutral'></span>
 674 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 1.071e18);</span>
 675 |     | <span class='unexecuted'>        _depositToVault(address(this), deposit3);</span>
 676 |     | <span class='unexecuted'>        slippage = vault.totalAssets();</span>
 677 |     | <span class='neutral'></span>
 678 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 679 |     | <span class='unexecuted'>        vault.harvest();</span>
 680 |     | <span class='unexecuted'>        slippage -= vault.totalAssets();</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='unexecuted'>        assertApproxEqRel(vault.totalProfit(), (vault.totalAssets() - deposit1 - deposit2 - deposit3), 0.01e18);</span>
 683 |     | <span class='unexecuted'>        assertApproxEqRel(</span>
 684 |     | <span class='unexecuted'>            vault.totalProfit(), profit1 + (profit1 + deposit1 + deposit2).mulWadDown(0.15e18) - slippage, 0.01e18</span>
 685 |     | <span class='neutral'>        );</span>
 686 |     | <span class='neutral'>    }</span>
 687 |     | <span class='neutral'></span>
 688 |     | <span class='unexecuted'>    function test_harvest_DoesntTakePerfFeeWhenRecoveringFromLoss() public {</span>
 689 |     | <span class='unexecuted'>        uint256 amount = 1 ether;</span>
 690 |     | <span class='unexecuted'>        vault.setTreasury(treasury);</span>
 691 |     | <span class='neutral'></span>
 692 |     | <span class='unexecuted'>        _depositToVault(address(this), amount);</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='unexecuted'>        vm.startPrank(keeper);</span>
 695 |     | <span class='unexecuted'>        vault.harvest();</span>
 696 |     | <span class='neutral'></span>
 697 |     | <span class='neutral'>        // earn some profits</span>
 698 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 1.1e18);</span>
 699 |     | <span class='unexecuted'>        vault.harvest();</span>
 700 |     | <span class='unexecuted'>        uint256 perfFees = vault.balanceOf(treasury);</span>
 701 |     | <span class='neutral'></span>
 702 |     | <span class='neutral'>        // loose some profits</span>
 703 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 0.954545455e18);</span>
 704 |     | <span class='unexecuted'>        vault.harvest();</span>
 705 |     | <span class='neutral'></span>
 706 |     | <span class='neutral'>        // earn back some</span>
 707 |     | <span class='unexecuted'>        _simulate_stEthStakingInterest(365 days, 1.047619048e18);</span>
 708 |     | <span class='unexecuted'>        vault.harvest();</span>
 709 |     | <span class='neutral'></span>
 710 |     | <span class='neutral'>        // we should not mint any perf fee shares when recovering from a loss</span>
 711 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(treasury), perfFees, &quot;perf fee must be the same&quot;);</span>
 712 |     | <span class='neutral'>    }</span>
 713 |     | <span class='neutral'></span>
 714 |     | <span class='neutral'>    //////////////////////////// INTERNAL METHODS ////////////////////////////////////////</span>
 715 |     | <span class='neutral'></span>
 716 |     | <span class='unexecuted'>    function _createDefaultWethVaultConstructorParams() internal view returns (scWETH.ConstructorParams memory) {</span>
 717 |     | <span class='unexecuted'>        return scWETH.ConstructorParams({</span>
 718 |     | <span class='unexecuted'>            admin: admin,</span>
 719 |     | <span class='neutral'>            keeper: keeper,</span>
 720 |     | <span class='unexecuted'>            targetLtv: targetLtv,</span>
 721 |     | <span class='unexecuted'>            slippageTolerance: slippageTolerance,</span>
 722 |     | <span class='neutral'>            aavePool: IPool(C.AAVE_POOL),</span>
 723 |     | <span class='neutral'>            aaveAwstEth: IAToken(C.AAVE_AWSTETH_TOKEN),</span>
 724 |     | <span class='neutral'>            aaveVarDWeth: ERC20(C.AAVAAVE_VAR_DEBT_WETH_TOKEN),</span>
 725 |     | <span class='neutral'>            curveEthStEthPool: ICurvePool(C.CURVE_ETH_STETH_POOL),</span>
 726 |     | <span class='neutral'>            stEth: ILido(C.STETH),</span>
 727 |     | <span class='neutral'>            wstEth: IwstETH(C.WSTETH),</span>
 728 |     | <span class='neutral'>            weth: WETH(payable(C.WETH)),</span>
 729 |     | <span class='neutral'>            stEthToEthPriceFeed: AggregatorV3Interface(C.CHAINLINK_STETH_ETH_PRICE_FEED),</span>
 730 |     | <span class='neutral'>            balancerVault: IVault(C.BALANCER_VAULT)</span>
 731 |     | <span class='neutral'>        });</span>
 732 |     | <span class='neutral'>    }</span>
 733 |     | <span class='neutral'></span>
 734 |     | <span class='unexecuted'>    function _depositToVault(address user, uint256 amount) internal returns (uint256 shares) {</span>
 735 |     | <span class='unexecuted'>        vm.deal(user, amount);</span>
 736 |     | <span class='unexecuted'>        vm.startPrank(user);</span>
 737 |     | <span class='unexecuted'>        weth.deposit{value: amount}();</span>
 738 |     | <span class='unexecuted'>        weth.approve(address(vault), amount);</span>
 739 |     | <span class='unexecuted'>        shares = vault.deposit(amount, user);</span>
 740 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 741 |     | <span class='neutral'>    }</span>
 742 |     | <span class='neutral'></span>
 743 |     | <span class='unexecuted'>    function _depositChecks(uint256 amount, uint256 preDepositBal) internal {</span>
 744 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(10 ** vault.decimals()), 1e18);</span>
 745 |     | <span class='unexecuted'>        assertEq(vault.totalAssets(), amount);</span>
 746 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(address(this)), amount);</span>
 747 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), amount);</span>
 748 |     | <span class='unexecuted'>        assertEq(weth.balanceOf(address(this)), preDepositBal - amount);</span>
 749 |     | <span class='neutral'>    }</span>
 750 |     | <span class='neutral'></span>
 751 |     | <span class='unexecuted'>    function _redeemChecks(uint256 preDepositBal) internal {</span>
 752 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(10 ** vault.decimals()), 1e18);</span>
 753 |     | <span class='unexecuted'>        assertEq(vault.totalAssets(), 0);</span>
 754 |     | <span class='unexecuted'>        assertEq(vault.balanceOf(address(this)), 0);</span>
 755 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);</span>
 756 |     | <span class='unexecuted'>        assertEq(weth.balanceOf(address(this)), preDepositBal);</span>
 757 |     | <span class='neutral'>    }</span>
 758 |     | <span class='neutral'></span>
 759 |     | <span class='unexecuted'>    function _withdrawToVaultChecks(uint256 maxAssetsDelta) internal {</span>
 760 |     | <span class='unexecuted'>        uint256 assets = vault.totalAssets();</span>
 761 |     | <span class='neutral'></span>
 762 |     | <span class='unexecuted'>        assertEq(weth.balanceOf(address(vault)), 0);</span>
 763 |     | <span class='neutral'></span>
 764 |     | <span class='unexecuted'>        uint256 ltv = vault.getLtv();</span>
 765 |     | <span class='unexecuted'>        uint256 lev = vault.getLeverage();</span>
 766 |     | <span class='neutral'></span>
 767 |     | <span class='unexecuted'>        vault.withdrawToVault(assets / 2);</span>
 768 |     | <span class='neutral'></span>
 769 |     | <span class='neutral'>        // net ltv and leverage must not change after withdraw</span>
 770 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLtv(), ltv, 0.001e18);</span>
 771 |     | <span class='unexecuted'>        assertApproxEqRel(vault.getLeverage(), lev, 0.001e18);</span>
 772 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(address(vault)), assets / 2, maxAssetsDelta);</span>
 773 |     | <span class='neutral'></span>
 774 |     | <span class='neutral'>        // withdraw the remaining assets</span>
 775 |     | <span class='unexecuted'>        vault.withdrawToVault(assets / 2);</span>
 776 |     | <span class='neutral'></span>
 777 |     | <span class='unexecuted'>        uint256 dust = 100;</span>
 778 |     | <span class='unexecuted'>        assertLt(vault.getDebt(), dust, &quot;test_withdrawToVault getDebt error&quot;);</span>
 779 |     | <span class='unexecuted'>        assertLt(vault.getCollateral(), dust, &quot;test_withdrawToVault getCollateral error&quot;);</span>
 780 |     | <span class='unexecuted'>        assertApproxEqRel(weth.balanceOf(address(vault)), assets, maxAssetsDelta, &quot;test_withdrawToVault asset balance&quot;);</span>
 781 |     | <span class='neutral'>    }</span>
 782 |     | <span class='neutral'></span>
 783 |     | <span class='unexecuted'>    function _simulate_stEthStakingInterest(uint256 timePeriod, uint256 stEthStakingInterest) internal {</span>
 784 |     | <span class='neutral'>        // fast forward time to simulate supply and borrow interests</span>
 785 |     | <span class='unexecuted'>        vm.warp(block.timestamp + timePeriod);</span>
 786 |     | <span class='unexecuted'>        uint256 prevBalance = read_storage_uint(address(stEth), keccak256(abi.encodePacked(&quot;lido.Lido.beaconBalance&quot;)));</span>
 787 |     | <span class='unexecuted'>        vm.store(</span>
 788 |     | <span class='unexecuted'>            address(stEth),</span>
 789 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(&quot;lido.Lido.beaconBalance&quot;)),</span>
 790 |     | <span class='unexecuted'>            bytes32(prevBalance.mulWadDown(stEthStakingInterest))</span>
 791 |     | <span class='neutral'>        );</span>
 792 |     | <span class='neutral'>    }</span>
 793 |     | <span class='neutral'></span>
 794 |     | <span class='unexecuted'>    function read_storage_uint(address addr, bytes32 key) internal view returns (uint256) {</span>
 795 |     | <span class='unexecuted'>        return abi.decode(abi.encode(vm.load(addr, key)), (uint256));</span>
 796 |     | <span class='neutral'>    }</span>
 797 |     | <span class='neutral'></span>
 798 |     | <span class='neutral'>    receive() external payable {}</span>
 799 |     | <span class='neutral'>}</span>
 800 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/asdf/sc/lev/test/scWETH.unit.t.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;forge-std/console2.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
   6 |     | <span class='neutral'>import {ERC20} from &quot;solmate/tokens/ERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {WETH} from &quot;solmate/tokens/WETH.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ERC4626} from &quot;solmate/mixins/ERC4626.sol&quot;;</span>
   9 |     | <span class='neutral'>import {FixedPointMathLib} from &quot;solmate/utils/FixedPointMathLib.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IPool} from &quot;aave-v3/interfaces/IPool.sol&quot;;</span>
  11 |     | <span class='neutral'>import {IAToken} from &quot;aave-v3/interfaces/IAToken.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>import {Constants as C} from &quot;../src/lib/Constants.sol&quot;;</span>
  14 |     | <span class='neutral'>import {scWETH} from &quot;../src/steth/scWETH.sol&quot;;</span>
  15 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;../src/interfaces/chainlink/AggregatorV3Interface.sol&quot;;</span>
  16 |     | <span class='neutral'>import {IVault} from &quot;../src/interfaces/balancer/IVault.sol&quot;;</span>
  17 |     | <span class='neutral'>import {ICurvePool} from &quot;../src/interfaces/curve/ICurvePool.sol&quot;;</span>
  18 |     | <span class='neutral'>import {ILido} from &quot;../src/interfaces/lido/ILido.sol&quot;;</span>
  19 |     | <span class='neutral'>import {IwstETH} from &quot;../src/interfaces/lido/IwstETH.sol&quot;;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>import {MockWETH} from &quot;./mocks/MockWETH.sol&quot;;</span>
  22 |     | <span class='neutral'>import {MockAavePool} from &quot;./mocks/aave-v3/MockAavePool.sol&quot;;</span>
  23 |     | <span class='neutral'>import {MockVarDebtWETH} from &quot;./mocks/aave-v3/MockVarDebtWETH.sol&quot;;</span>
  24 |     | <span class='neutral'>import {MockAwstETH} from &quot;./mocks/aave-v3/MockAwstETH.sol&quot;;</span>
  25 |     | <span class='neutral'>import {MockStETH} from &quot;./mocks/lido/MockStETH.sol&quot;;</span>
  26 |     | <span class='neutral'>import {MockWstETH} from &quot;./mocks/lido/MockWstETH.sol&quot;;</span>
  27 |     | <span class='neutral'>import {MockChainlinkPriceFeed} from &quot;./mocks/chainlink/MockChainlinkPriceFeed.sol&quot;;</span>
  28 |     | <span class='neutral'>import {MockCurvePool} from &quot;./mocks/curve/MockCurvePool.sol&quot;;</span>
  29 |     | <span class='neutral'>import {MockBalancerVault} from &quot;./mocks/balancer/MockBalancerVault.sol&quot;;</span>
  30 |     | <span class='unexecuted'></span>
  31 |     | <span class='neutral'>contract scWETHUnitTest is Test {</span>
  32 |     | <span class='neutral'>    using FixedPointMathLib for uint256;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    address constant keeper = address(0x05);</span>
  35 |     | <span class='unexecuted'>    address constant alice = address(0x06);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    scWETH vault;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    MockWETH weth;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    MockAavePool aavePool;</span>
  42 |     | <span class='neutral'>    MockVarDebtWETH aaveVarDWeth;</span>
  43 |     | <span class='neutral'>    MockStETH stEth;</span>
  44 |     | <span class='neutral'>    MockWstETH wstEth;</span>
  45 |     | <span class='neutral'>    MockAwstETH aaveAWstEth;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    MockCurvePool curveEthStEthPool;</span>
  48 |     | <span class='neutral'>    MockChainlinkPriceFeed stEthToEthPriceFeed;</span>
  49 |     | <span class='neutral'>    MockBalancerVault balancerVault;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function setUp() public {</span>
  52 |     | <span class='unexecuted'>        weth = new MockWETH();</span>
  53 |     | <span class='unexecuted'>        stEth = new MockStETH();</span>
  54 |     | <span class='unexecuted'>        wstEth = new MockWstETH(stEth);</span>
  55 |     | <span class='unexecuted'>        stEthToEthPriceFeed = new MockChainlinkPriceFeed(address(stEth), address(weth), 1e18);</span>
  56 |     | <span class='unexecuted'>        aavePool = new MockAavePool();</span>
  57 |     | <span class='unexecuted'>        aavePool.setStEthToEthPriceFeed(stEthToEthPriceFeed, wstEth, weth);</span>
  58 |     | <span class='unexecuted'>        aaveVarDWeth = new MockVarDebtWETH(aavePool, weth);</span>
  59 |     | <span class='unexecuted'>        aaveAWstEth = new MockAwstETH(aavePool, wstEth);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        curveEthStEthPool = new MockCurvePool(stEth);</span>
  62 |     | <span class='unexecuted'>        balancerVault = new MockBalancerVault(weth);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>        scWETH.ConstructorParams memory scWethParams = scWETH.ConstructorParams({</span>
  65 |     | <span class='unexecuted'>            admin: address(this),</span>
  66 |     | <span class='neutral'>            keeper: keeper,</span>
  67 |     | <span class='unexecuted'>            targetLtv: 0.7e18,</span>
  68 |     | <span class='unexecuted'>            slippageTolerance: 0.99e18,</span>
  69 |     | <span class='unexecuted'>            aavePool: aavePool,</span>
  70 |     | <span class='unexecuted'>            aaveAwstEth: IAToken(address(aaveAWstEth)),</span>
  71 |     | <span class='unexecuted'>            aaveVarDWeth: ERC20(address(aaveVarDWeth)),</span>
  72 |     | <span class='unexecuted'>            curveEthStEthPool: curveEthStEthPool,</span>
  73 |     | <span class='unexecuted'>            stEth: ILido(address(stEth)),</span>
  74 |     | <span class='unexecuted'>            wstEth: IwstETH(address(wstEth)),</span>
  75 |     | <span class='unexecuted'>            weth: WETH(payable(weth)),</span>
  76 |     | <span class='unexecuted'>            stEthToEthPriceFeed: stEthToEthPriceFeed,</span>
  77 |     | <span class='neutral'>            balancerVault: balancerVault</span>
  78 |     | <span class='neutral'>        });</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        vault = new scWETH(scWethParams);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        vm.deal(address(weth), 100e18);</span>
  83 |     | <span class='unexecuted'>        vm.deal(address(curveEthStEthPool), 100e18);</span>
  84 |     | <span class='unexecuted'>        weth.mint(address(balancerVault), 100e18);</span>
  85 |     | <span class='unexecuted'>        weth.mint(address(aavePool), 100e18);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function test_harvest() public {</span>
  89 |     | <span class='unexecuted'>        uint256 depositAmount = 10e18;</span>
  90 |     | <span class='unexecuted'>        deal(address(weth), alice, depositAmount);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
  93 |     | <span class='unexecuted'>        weth.approve(address(vault), type(uint256).max);</span>
  94 |     | <span class='unexecuted'>        vault.deposit(depositAmount, alice);</span>
  95 |     | <span class='unexecuted'>        vm.stopPrank();</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
  98 |     | <span class='unexecuted'>        vault.harvest();</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        uint256 aliceShares = vault.balanceOf(alice);</span>
 101 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(aliceShares), depositAmount, &quot;alice&#39;s assets&quot;);</span>
 102 |     | <span class='unexecuted'>        assertEq(vault.totalAssets(), depositAmount, &quot;total assets&quot;);</span>
 103 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), depositAmount.divWadDown(1e18 - vault.targetLtv()), &quot;collateral&quot;);</span>
 104 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), vault.getCollateral().mulWadDown(vault.targetLtv()), &quot;debt&quot;);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function test_redeem() public {</span>
 108 |     | <span class='unexecuted'>        uint256 depositAmount = 10e18;</span>
 109 |     | <span class='unexecuted'>        deal(address(weth), alice, depositAmount);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 112 |     | <span class='unexecuted'>        weth.approve(address(vault), type(uint256).max);</span>
 113 |     | <span class='unexecuted'>        vault.deposit(depositAmount, alice);</span>
 114 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 117 |     | <span class='unexecuted'>        vault.harvest();</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        uint256 stEthToEthSlippage = 0.99e18;</span>
 120 |     | <span class='unexecuted'>        curveEthStEthPool.setSlippage(stEthToEthSlippage);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        uint256 withdrawAmount = 1e18;</span>
 123 |     | <span class='unexecuted'>        uint256 sharesToReddem = vault.convertToShares(withdrawAmount);</span>
 124 |     | <span class='unexecuted'>        vm.prank(alice);</span>
 125 |     | <span class='unexecuted'>        vault.redeem(sharesToReddem, alice, alice);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        uint256 aliceShares = vault.balanceOf(alice);</span>
 128 |     | <span class='unexecuted'>        assertEq(vault.convertToAssets(aliceShares), depositAmount - withdrawAmount, &quot;alice&#39;s assets&quot;);</span>
 129 |     | <span class='unexecuted'>        uint256 totalAssets = vault.totalAssets();</span>
 130 |     | <span class='unexecuted'>        assertEq(totalAssets, depositAmount - withdrawAmount, &quot;total assets&quot;);</span>
 131 |     | <span class='unexecuted'>        assertEq(vault.getCollateral(), totalAssets.divWadDown(1e18 - vault.targetLtv()), &quot;collateral&quot;);</span>
 132 |     | <span class='unexecuted'>        assertEq(vault.getDebt(), vault.getCollateral().mulWadDown(vault.targetLtv()), &quot;debt&quot;);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        uint256 leverage = uint256(1e18).divWadDown(1e18 - vault.targetLtv());</span>
 135 |     | <span class='unexecuted'>        uint256 expectedPctDiff = uint256(1e18 - stEthToEthSlippage).mulWadDown(leverage);</span>
 136 |     | <span class='unexecuted'>        assertApproxEqAbs(weth.balanceOf(alice), withdrawAmount.mulWadDown(1e18 - expectedPctDiff), 1, &quot;alice&#39;s weth&quot;);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function test_getLtv() public {</span>
 140 |     | <span class='unexecuted'>        uint256 amount = 10e18;</span>
 141 |     | <span class='unexecuted'>        deal(address(weth), alice, amount);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        vm.startPrank(alice);</span>
 144 |     | <span class='unexecuted'>        weth.approve(address(vault), type(uint256).max);</span>
 145 |     | <span class='unexecuted'>        vault.deposit(amount, alice);</span>
 146 |     | <span class='unexecuted'>        vm.stopPrank();</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        vm.prank(keeper);</span>
 149 |     | <span class='unexecuted'>        vault.harvest();</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        aavePool.setStEthToEthPriceFeed(stEthToEthPriceFeed, wstEth, weth);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        assertEq(vault.getLtv(), vault.targetLtv(), &quot;ltv&quot;);</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'>}</span>
 156 |     | <span class='neutral'></span>

</code>
<br />

